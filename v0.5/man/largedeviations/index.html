<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Large deviation theory · CriticalTransitions.jl</title><meta name="title" content="Large deviation theory · CriticalTransitions.jl"/><meta property="og:title" content="Large deviation theory · CriticalTransitions.jl"/><meta property="twitter:title" content="Large deviation theory · CriticalTransitions.jl"/><meta name="description" content="Documentation for CriticalTransitions.jl."/><meta property="og:description" content="Documentation for CriticalTransitions.jl."/><meta property="twitter:description" content="Documentation for CriticalTransitions.jl."/><meta property="og:url" content="https://juliadynamics.github.io/CriticalTransitions.jl/man/largedeviations/"/><meta property="twitter:url" content="https://juliadynamics.github.io/CriticalTransitions.jl/man/largedeviations/"/><link rel="canonical" href="https://juliadynamics.github.io/CriticalTransitions.jl/man/largedeviations/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CriticalTransitions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../CoupledSDEs/">Define a CoupledSDEs system</a></li><li><a class="tocitem" href="../simulation/">Simulating the system</a></li><li><a class="tocitem" href="../sampling/">Sampling transitions</a></li><li class="is-active"><a class="tocitem" href>Large deviation theory</a><ul class="internal"><li><a class="tocitem" href="#Action-functionals"><span>Action functionals</span></a></li><li><a class="tocitem" href="#Minimum-action-paths"><span>Minimum action paths</span></a></li></ul></li><li><a class="tocitem" href="../utils/">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Large deviation theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Large deviation theory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/CriticalTransitions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/main/docs/src/man/largedeviations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Large-deviation-theory"><a class="docs-heading-anchor" href="#Large-deviation-theory">Large deviation theory</a><a id="Large-deviation-theory-1"></a><a class="docs-heading-anchor-permalink" href="#Large-deviation-theory" title="Permalink"></a></h1><h2 id="Action-functionals"><a class="docs-heading-anchor" href="#Action-functionals">Action functionals</a><a id="Action-functionals-1"></a><a class="docs-heading-anchor-permalink" href="#Action-functionals" title="Permalink"></a></h2><h3 id="Freidlin-Wentzell-action"><a class="docs-heading-anchor" href="#Freidlin-Wentzell-action">Freidlin-Wentzell action</a><a id="Freidlin-Wentzell-action-1"></a><a class="docs-heading-anchor-permalink" href="#Freidlin-Wentzell-action" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.fw_action" href="#CriticalTransitions.fw_action"><code>CriticalTransitions.fw_action</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fw_action(sys::CoupledSDEs, path, time) -&gt; Any
</code></pre><p>Calculates the Freidlin-Wentzell action of a given <code>path</code> with time points <code>time</code> in a drift field specified by the deterministic dynamics <code>f = dynamic_rule(sys)</code> and (normalized) noise covariance matrix <code>covariance_matrix(sys)</code>.</p><p>The path must be a <code>(D x N)</code> matrix, where <code>D</code> is the dimensionality of the system <code>sys</code> and <code>N</code> is the number of path points. The <code>time</code> array must have length <code>N</code>.</p><p>Returns a single number, which is the value of the action functional</p><p><span>$S_T[\phi_t] = \frac{1}{2} \int_0^T || \dot \phi_t - f(\phi_t) ||^2_Q \text{d}t$</span></p><p>where <span>$\phi_t$</span> denotes the path in state space, <span>$b$</span> the drift field, and <span>$T$</span> the total time of the path. The subscript <span>$Q$</span> refers to the generalized norm <span>$||a||_Q^2 := \langle a, Q^{-1} b \rangle$</span> (see <code>anorm</code>). Here <span>$Q$</span> is the noise covariance matrix normalized by <span>$D/L_1(Q)$</span>, with <span>$L_1$</span> being the L1 matrix norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/4f86c4e3c48daee8589fb9812006afedd9ed7f22/src/largedeviations/action.jl#L1">source</a></section></article><h3 id="Geometric-Freidlin-Wentzell-action"><a class="docs-heading-anchor" href="#Geometric-Freidlin-Wentzell-action">Geometric Freidlin-Wentzell action</a><a id="Geometric-Freidlin-Wentzell-action-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-Freidlin-Wentzell-action" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.geometric_action" href="#CriticalTransitions.geometric_action"><code>CriticalTransitions.geometric_action</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geometric_action(sys::CoupledSDEs, path) -&gt; Any
geometric_action(sys::CoupledSDEs, path, arclength) -&gt; Any
</code></pre><p>Calculates the geometric action of a given <code>path</code> with specified <code>arclength</code> for the drift field specified by the deterministic dynamics <code>f = dynamic_rule(sys)</code> and (normalized) noise covariance matrix <code>covariance_matrix(sys)</code>.</p><p>For a given path <span>$\varphi$</span>, the geometric action <span>$\bar S$</span> corresponds to the minimum of the Freidlin-Wentzell action <span>$S_T(\varphi)$</span> over all travel times <span>$T&gt;0$</span>, where <span>$\varphi$</span> denotes the path&#39;s parameterization in physical time (see <a href="#CriticalTransitions.fw_action"><code>fw_action</code></a>). It is given by the integral</p><p><span>$\bar S[\varphi] = \int_0^L \left( ||\varphi&#39;||_Q \, ||f(\varphi)||_Q - \langle \varphi&#39;, \,     f(\varphi) \rangle_Q \right) \, \text{d}s$</span></p><p>where <span>$s$</span> is the arclength coordinate, <span>$L$</span> the arclength, <span>$f$</span> the drift field, and the subscript <span>$Q$</span> refers to the generalized dot product <span>$\langle a, b \rangle_Q := a^{\top} \cdot Q^{-1} b$</span> (see <code>anorm</code>). Here <span>$Q$</span> is the noise covariance matrix normalized by <span>$D/L_1(Q)$</span>, with <span>$L_1$</span> being the L1 matrix norm.</p><p>Returns the value of the geometric action <span>$\bar S$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/4f86c4e3c48daee8589fb9812006afedd9ed7f22/src/largedeviations/action.jl#L89">source</a></section></article><h3 id="Onsager-Machlup-action"><a class="docs-heading-anchor" href="#Onsager-Machlup-action">Onsager-Machlup action</a><a id="Onsager-Machlup-action-1"></a><a class="docs-heading-anchor-permalink" href="#Onsager-Machlup-action" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.om_action" href="#CriticalTransitions.om_action"><code>CriticalTransitions.om_action</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">om_action(sys::CoupledSDEs, path, time, noise_strength)</code></pre><p>Calculates the Onsager-Machlup action of a given <code>path</code> with time points <code>time</code> for the drift field <code>f = dynamic_rule(sys)</code> at given <code>noise_strength</code>.</p><p>The path must be a <code>(D x N)</code> matrix, where <code>D</code> is the dimensionality of the system <code>sys</code> and <code>N</code> is the number of path points. The <code>time</code> array must have length <code>N</code>.</p><p>Returns a single number, which is the value of the action functional</p><p><span>$S^{\sigma}_T[\phi_t] = \frac{1}{2} \int_0^T \left( || \dot \phi_t - f(\phi_t) ||^2_Q + \sigma^2 \nabla \cdot f \right) \, \text{d} t$</span></p><p>where <span>$\phi_t$</span> denotes the path in state space, <span>$b$</span> the drift field, <span>$T$</span> the total time of the path, and <span>$\sigma$</span> the noise strength. The subscript <span>$Q$</span> refers to the generalized norm <span>$||a||_Q^2 := \langle a, Q^{-1} b \rangle$</span> (see <code>anorm</code>). Here <span>$Q$</span> is the noise covariance matrix normalized by <span>$D/L_1(Q)$</span>, with <span>$L_1$</span> being the L1 matrix norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/4f86c4e3c48daee8589fb9812006afedd9ed7f22/src/largedeviations/action.jl#L36-L54">source</a></section></article><p>For convenience, a general <a href="#CriticalTransitions.action"><code>action</code></a> function is available where the type of functional is set as an argument:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.action" href="#CriticalTransitions.action"><code>CriticalTransitions.action</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">action(
    sys::CoupledSDEs,
    path::Matrix,
    time,
    functional;
    noise_strength
) -&gt; Any
</code></pre><p>Computes the action functional specified by <code>functional</code> for a given CoupledSDEs <code>sys</code> and <code>path</code> parameterized by <code>time</code>.</p><ul><li><code>functional = &quot;FW&quot;</code>: Returns the Freidlin-Wentzell action (<a href="#CriticalTransitions.fw_action"><code>fw_action</code></a>)</li><li><code>functional = &quot;OM&quot;</code>: Returns the Onsager-Machlup action (<a href="#CriticalTransitions.om_action"><code>om_action</code></a>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/4f86c4e3c48daee8589fb9812006afedd9ed7f22/src/largedeviations/action.jl#L71">source</a></section></article><h2 id="Minimum-action-paths"><a class="docs-heading-anchor" href="#Minimum-action-paths">Minimum action paths</a><a id="Minimum-action-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Minimum-action-paths" title="Permalink"></a></h2><p>We provide the following two methods to calculate <em>instantons</em>, or minimum action paths, between two states of a <code>CoupledSDEs</code> system.</p><h3 id="Minimum-action-method-(MAM)"><a class="docs-heading-anchor" href="#Minimum-action-method-(MAM)">Minimum action method (MAM)</a><a id="Minimum-action-method-(MAM)-1"></a><a class="docs-heading-anchor-permalink" href="#Minimum-action-method-(MAM)" title="Permalink"></a></h3><p>Minimization of the Freidlin-Wentzell action using the L-BFGS algorithm of <code>Optim.jl</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.min_action_method" href="#CriticalTransitions.min_action_method"><code>CriticalTransitions.min_action_method</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">min_action_method(
    sys::CoupledSDEs,
    x_i,
    x_f,
    N::Int64,
    T::Real;
    functional,
    maxiter,
    blocks,
    method,
    save_iterations,
    show_progress,
    verbose
) -&gt; Any
</code></pre><p>Runs the Minimum Action Method (MAM) to find the minimum action path (instanton) between an initial state <code>x_i</code> and final state <code>x_f</code>.</p><p>This algorithm uses the minimizers of the <a href="https://julianlsolvers.github.io/Optim.jl/stable/#"><code>Optim</code></a> package to minimize the Freidlin-Wentzell action functional (see <a href="#CriticalTransitions.fw_action"><code>fw_action</code></a>) for the given CoupledSDEs <code>sys</code>. The path is initialized as a straight line between <code>x_i</code> and <code>x_f</code>, parameterized in time via <code>N</code> equidistant points and total time <code>T</code>. Thus, the time step between discretized path points is <span>$\Delta t = T/N$</span>. To set an initial path different from a straight line, see the multiple dispatch method</p><ul><li><code>min_action_method(sys::CoupledSDEs, init::Matrix, T::Real; kwargs...)</code>.</li></ul><p>The minimization can be performed in blocks to save intermediate results.</p><p><strong>Keyword arguments</strong></p><ul><li><code>functional = &quot;FW&quot;</code>: type of action functional to minimize. Defaults to <a href="#CriticalTransitions.fw_action"><code>fw_action</code></a>, alternative: <a href="#CriticalTransitions.om_action"><code>om_action</code></a>.</li><li><code>maxiter = 100</code>: maximum number of iterations before the algorithm stops.</li><li><code>action_tol=1e-5</code>: relative tolerance of action value to determine convergence</li><li><code>abstol=1e-8</code>: absolute tolerance of action gradient to determine convergence</li><li><code>reltol=1e-8</code>: relative tolerance of action gradient to determine convergence</li><li><code>blocks = 1</code>: number of iterative optimization blocks</li><li><code>method = LBFGS()</code>: minimization algorithm (see <a href="https://julianlsolvers.github.io/Optim.jl/stable/#"><code>Optim</code></a>)</li><li><code>save_iterations = true</code>: whether to save Optim information</li><li><code>verbose = true</code>: whether to print Optim information during the run</li><li><code>show_progress = false</code>: whether to print a progress bar</li></ul><p><strong>Output</strong></p><p>If <code>save_iterations</code>, returns <code>Optim.OptimizationResults</code>. Else, returns only the optimizer (path). If <code>blocks &gt; 1</code>, a vector of results/optimizers is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/4f86c4e3c48daee8589fb9812006afedd9ed7f22/src/largedeviations/min_action_method.jl#L1">source</a></section><section><div><pre><code class="language-julia hljs">min_action_method(
    sys::CoupledSDEs,
    init::Matrix,
    T::Real;
    functional,
    maxiter,
    blocks,
    method,
    action_tol,
    abstol,
    reltol,
    save_iterations,
    verbose,
    show_progress
) -&gt; Any
</code></pre><p>Runs the Minimum Action Method (MAM) to find the minimum action path (instanton) from an initial condition <code>init</code>, given a system <code>sys</code> and total path time <code>T</code>.</p><p>The initial path <code>init</code> must be a matrix of size <code>(D, N)</code>, where <code>D</code> is the dimension of the system and <code>N</code> is the number of path points. The physical time of the path is specified by <code>T</code>, such that the time step between consecutive path points is <span>$\Delta t = T/N$</span>.</p><p>For more information see the main method, <a href="#CriticalTransitions.min_action_method"><code>min_action_method(sys::CoupledSDEs, x_i, x_f, N::Int, T::Real; kwargs...)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/4f86c4e3c48daee8589fb9812006afedd9ed7f22/src/largedeviations/min_action_method.jl#L67">source</a></section></article><h3 id="Geometric-minimum-action-method-(gMAM)"><a class="docs-heading-anchor" href="#Geometric-minimum-action-method-(gMAM)">Geometric minimum action method (gMAM)</a><a id="Geometric-minimum-action-method-(gMAM)-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-minimum-action-method-(gMAM)" title="Permalink"></a></h3><p>Minimization of the geometric action following <a href="https://link.aps.org/doi/10.1103/PhysRevLett.100.140601">Heymann and Vanden-Eijnden, PRL (2008)</a>. The gMAM reformulates MAM to avoid numerical stiffness by reparametrizing the path in terms of arc length. This ensures an even distribution of points along the path, enhancing numerical stability and accuracy. By solving the reparametrized integral, gMAM accurately captures the geometry of the action functional and is well-suited for systems with complex energy landscapes or intricate dynamics.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.geometric_min_action_method" href="#CriticalTransitions.geometric_min_action_method"><code>CriticalTransitions.geometric_min_action_method</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geometric_min_action_method(
    sys::CoupledSDEs,
    x_i,
    x_f;
    N,
    kwargs...
) -&gt; Tuple{Vector{Matrix}, Vector{Float64}}
</code></pre><p>Computes the minimizer of the geometric Freidlin-Wentzell action based on the geometric minimum action method (gMAM), using optimizers of Optim.jl or the original formulation by Heymann and Vanden-Eijnden<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><p>To set an initial path different from a straight line, see the multiple dispatch method</p><ul><li><code>geometric_min_action_method(sys::CoupledSDEs, init::Matrix, arclength::Float64; kwargs...)</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>maxiter::Int=100</code>: maximum number of optimization iterations before the alogrithm stops</li><li><code>action_tol=1e-5</code>: relative tolerance of action value to determine convergence</li><li><code>abstol=1e-8</code>: absolute tolerance of action gradient to determine convergence</li><li><code>reltol=1e-8</code>: relative tolerance of action gradient to determine convergence</li><li><code>method=LBFGS()</code>: optimizer method (see <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/config/">Optim.jl</a>)</li><li><code>iter_per_batch=1</code>: number of iterations per optimization batch</li><li><code>tau=0.1</code>: parameter in HeymannVandenEijnden method</li><li><code>verbose=false</code>: if true, print additional output</li><li><code>show_progress=true</code>: if true, display a progress bar</li></ul><p><strong>Optimization algorithms</strong></p><p>The <code>method</code> keyword argument takes solver methods of the <a href="https://julianlsolvers.github.io/Optim.jl/stable/#"><code>Optim.jl</code></a> package; alternatively, the option <code>solver = &quot;HeymannVandenEijnden&quot;</code> uses the original gMAM algorithm<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/4f86c4e3c48daee8589fb9812006afedd9ed7f22/src/largedeviations/geometric_min_action_method.jl#L1">source</a></section><section><div><pre><code class="language-julia hljs">geometric_min_action_method(
    sys::CoupledSDEs,
    init::Matrix;
    maxiter,
    abstol,
    reltol,
    action_tol,
    method,
    tau,
    iter_per_batch,
    verbose,
    show_progress
) -&gt; Tuple{Vector{Matrix}, Vector{Float64}}
</code></pre><p>Runs the geometric Minimum Action Method (gMAM) to find the minimum action path (instanton) from an initial condition <code>init</code>, given a system <code>sys</code> and total arc length <code>arclength</code>.</p><p>The initial path <code>init</code> must be a matrix of size <code>(D, N)</code>, where <code>D</code> is the dimension of the system and <code>N</code> is the number of path points.</p><p>For more information see the main method, <a href="#CriticalTransitions.geometric_min_action_method"><code>geometric_min_action_method(sys::CoupledSDEs, x_i, x_f, arclength::Float64; kwargs...)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/4f86c4e3c48daee8589fb9812006afedd9ed7f22/src/largedeviations/geometric_min_action_method.jl#L38">source</a></section></article><h3 id="Simple-Geometric-minimum-action-method-(sgMAM)"><a class="docs-heading-anchor" href="#Simple-Geometric-minimum-action-method-(sgMAM)">Simple Geometric minimum action method (sgMAM)</a><a id="Simple-Geometric-minimum-action-method-(sgMAM)-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Geometric-minimum-action-method-(sgMAM)" title="Permalink"></a></h3><p>Simplified minimization of the geometric action following <a href="https://doi.org/10.1007/978-1-4939-6969-2_2">Heymann and Vanden-Eijnden, PRL (2008)</a>. The sgMAM is a streamlined version of the gMAM that simplifies the computation by avoiding explicit reparametrization of the path. Instead, it introduces an implicit reparametrization by rewriting the problem as a constrained optimization.</p><p>The implementation below perform a constrained gradient descent where it assumes an autonomous system with additive Gaussian noise.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.Sgmam.SgmamSystem" href="#CriticalTransitions.Sgmam.SgmamSystem"><code>CriticalTransitions.Sgmam.SgmamSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A structure representing a system with Hamiltonian functions H<em>x and H</em>p.</p><p>This system operates in an extended phase space where the Hamiltonian is assumed to be quadratic in the extended momentum. The phase space coordinates <code>x</code> are doubled to form a 2n-dimensional extended phase space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/4f86c4e3c48daee8589fb9812006afedd9ed7f22/src/largedeviations/sgMAM.jl#L14-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.Sgmam.sgmam" href="#CriticalTransitions.Sgmam.sgmam"><code>CriticalTransitions.Sgmam.sgmam</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sgmam(
    sys::SgmamSystem,
    x_initial;
    ϵ,
    iterations,
    show_progress,
    reltol
) -&gt; Tuple{Any, Float64, Any, Any, Any}
</code></pre><p>Performs the simplified geometric Minimal Action Method (sgMAM) on the given system <code>sys</code>.</p><p>This method computes the optimal path in the phase space of a Hamiltonian system that minimizes the action. The Hamiltonian functions <code>H_x</code> and <code>H_p</code> define the system&#39;s dynamics in a doubled phase. The initial state <code>x_initial</code> is evolved iteratively using constrained gradient descent with step size parameter <code>ϵ</code> over a specified number of iterations. The method can display a progress meter and will stop early if the relative tolerance <code>reltol</code> is achieved.</p><p>The function returns a tuple containing the final state, the action value, the Lagrange multipliers, the momentum, and the state derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/4f86c4e3c48daee8589fb9812006afedd9ed7f22/src/largedeviations/sgMAM.jl#L26">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://link.aps.org/doi/10.1103/PhysRevLett.100.140601">Heymann and Vanden-Eijnden, PRL (2008)</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sampling/">« Sampling transitions</a><a class="docs-footer-nextpage" href="../utils/">Utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 2 December 2024 15:59">Monday 2 December 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"man/dev/#Functionality-under-development","page":"Development stage","title":"Functionality under development","text":"","category":"section"},{"location":"man/dev/#Pathspace-Langevin-MCMC-sampling-for-the-FitzHugh-Nagumo-system","page":"Development stage","title":"Pathspace Langevin MCMC sampling for the FitzHugh-Nagumo system","text":"","category":"section"},{"location":"man/dev/","page":"Development stage","title":"Development stage","text":"fhn_pathspace_sampling\nFitzHughNagumoSPDE","category":"page"},{"location":"man/dev/#CriticalTransitions.fhn_pathspace_sampling","page":"Development stage","title":"CriticalTransitions.fhn_pathspace_sampling","text":"fhn_pathspace_sampling(ϵ, σ, T, dz; kwargs...)\n\nIntegrates the FitzHughNagumoSPDE in virtual time to generate pathspace Langevin MCMC samples.\n\nUnless specified otherwise, the initial condition is a straight line between the fixed points R and L (for the default FHN parameters).\n\nArguments\n\nϵ (float): time scale parameter\nσ (float): noise strength\nT (float): total physical time\ndz (float): physical time step\ninit=nothing: initial path. If nothing, init is the straight line between the attractors.\n\nKeyword arguments\n\ndt (float): virtual time step\ntmax (float): total virtual time\na (float): first diagonal element of covariance matrix\nstart (string): Starting point of the path. Either \"R\" or \"L\" (default \"R\")\nsave_every (int): save the path at every save_every-th instance in virtual time\nβ, α, γ, κ, Ι: FHN parameters\n\nReturns\n\nA list of two matrices, each with columns = coordinates and rows = virtual time instances. The first matrix contains the u coordinates, the second matrix the v coordinates.\n\n\n\n\n\n","category":"function"},{"location":"man/dev/#CriticalTransitions.FitzHughNagumoSPDE","page":"Development stage","title":"CriticalTransitions.FitzHughNagumoSPDE","text":"FitzHughNagumoSPDE(u, p, t)\n\nSystem definition for the pathspace SPDE corresponding to the fitzhugh_nagumo system.\n\nThe parameter vector must contain the following (in this order):\n\nϵ (float): time scale parameter\nβ (float): FHN parameter\nα (float): FHN parameter\nγ (float): FHN parameter\nκ (float): FHN parameter\nΙ (float): FHN parameter\na (float): First diagonal element of covariance matrix \nσ (float): noise strength\ndz (float): physical time step\n\n\n\n\n\n","category":"function"},{"location":"man/noise/#Noise-processes","page":"Noise processes","title":"Noise processes","text":"","category":"section"},{"location":"man/noise/","page":"Noise processes","title":"Noise processes","text":"gauss(sys::StochSystem)","category":"page"},{"location":"man/noise/#CriticalTransitions.gauss-Tuple{StochSystem}","page":"Noise processes","title":"CriticalTransitions.gauss","text":"gauss(sys::StochSystem)\n\nReturns a Wiener process with dimension length(sys.u) and covariance matrix sys.Σ.\n\nThis function is based on the CorrelatedWienerProcess of DiffEqNoiseProcess.jl, a component of DifferentialEquations.jl. The initial condition of the process is set to the zero vector at t=0.\n\n\n\n\n\n","category":"method"},{"location":"man/stochsystem/#Defining-a-StochSystem","page":"Defining a StochSystem","title":"Defining a StochSystem","text":"","category":"section"},{"location":"man/stochsystem/","page":"Defining a StochSystem","title":"Defining a StochSystem","text":"A StochSystem defines a stochastic dynamical system of the form","category":"page"},{"location":"man/stochsystem/","page":"Defining a StochSystem","title":"Defining a StochSystem","text":"textdvec x = f(vec x(t)  p_f)  textdt + sigma g(vec x(t)   p_g)  Gamma cdot textdmathcalN  ","category":"page"},{"location":"man/stochsystem/","page":"Defining a StochSystem","title":"Defining a StochSystem","text":"where vec x in mathbbR^textdim, Sigma = Gamma Gamma^top in mathbb R^Ntimes N is the (positive definite) noise covariance matrix and mathcal N denotes a stochastic process.","category":"page"},{"location":"man/stochsystem/","page":"Defining a StochSystem","title":"Defining a StochSystem","text":"An instance of StochSystem is created via StochSystem(f, pf, u [, σ [, g, pg, Σ , process]]), taking the following arguments:","category":"page"},{"location":"man/stochsystem/","page":"Defining a StochSystem","title":"Defining a StochSystem","text":"f (Function): Dynamical ODE rule describing the drift term of the system, corresponding to f in the ODEProblem of DifferentialEquations. Can be defined in-place (f!(du, u, p, t)) or out-of-place (f(u,p,t)).\npf (Vector or Nothing): Parameter vector for the drift term.\nu (State): Initial state. E.g. zeros(dim), where dim is the system's dimensionality. \nσ (Float64): Noise intensity. Defaults to 1.0.\ng (Function): Dynamical ODE rule describing the noise term of the system. Same format as f. Defaults to idfunc.\npg (Vector or Nothing): Parameter vector of the noise term.\nΣ (Matrix): Noise covariance matrix. Defaults to I (identity matrix).\nprocess (String): Noise process. Defaults to white-gauss (independent n-dimensional Brownian motion).","category":"page"},{"location":"man/stochsystem/#Shortcut-methods","page":"Defining a StochSystem","title":"Shortcut methods","text":"","category":"section"},{"location":"man/stochsystem/","page":"Defining a StochSystem","title":"Defining a StochSystem","text":"StochSystem(f, pf, u)\nStochSystem(f, pf, u, σ)\nStochSystem(f, pf, u, σ, Σ)","category":"page"},{"location":"man/stochsystem/","page":"Defining a StochSystem","title":"Defining a StochSystem","text":"StochSystem","category":"page"},{"location":"man/stochsystem/#CriticalTransitions.StochSystem","page":"Defining a StochSystem","title":"CriticalTransitions.StochSystem","text":"StochSystem(f, pf, dim, σ, g, pg, Σ, process)\n\nDefines a stochastic dynamical system in CriticalTransitions.jl. See documentation.\n\n\n\n\n\n","category":"type"},{"location":"man/simulation/#Simulating-the-system","page":"Simulating the system","title":"Simulating the system","text":"","category":"section"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"We provide two main functions to simulate a StochSystem forward in time:","category":"page"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"relax for the system's deterministic evolution (in the absence of noise) based on the ODEProblem of DifferentialEquations.jl\nsimulate for stochastic dynamics based on the SDEProblem of DifferentialEquations.jl","category":"page"},{"location":"man/simulation/#Deterministic-dynamics","page":"Simulating the system","title":"Deterministic dynamics","text":"","category":"section"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"relax(sys::StochSystem, init::State; kwargs...)","category":"page"},{"location":"man/simulation/#CriticalTransitions.relax-Tuple{StochSystem, Union{Vector, SVector}}","page":"Simulating the system","title":"CriticalTransitions.relax","text":"relax(sys::StochSystem, init::State; kwargs...)\n\nSimulates the deterministic dynamics of StochSystem sys in time, starting at initial condition init.\n\nThis function integrates sys.f forward in time, using the ODEProblem functionality of DifferentialEquations.jl. Thus, relax is identical to simulate when setting the noise strength sys.σ = 0.\n\nKeyword arguments\n\ndt=0.01: time step of integration\ntmax=1e3: total time of simulation\nsolver=Euler(): ODE solver. Defaults to explicit forward Euler\ncallback=nothing: callback condition\nkwargs...: keyword arguments for solve(ODEProblem)\n\nFor more info, see ODEProblem. For stochastic integration, see simulate.\n\nWarning: This function has only been tested for the Euler() solver.\n\n\n\n\n\n","category":"method"},{"location":"man/simulation/#Stochastic-dynamics","page":"Simulating the system","title":"Stochastic dynamics","text":"","category":"section"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"simulate(sys::StochSystem, init::State; kwargs...)","category":"page"},{"location":"man/simulation/#CriticalTransitions.simulate-Tuple{StochSystem, Union{Vector, SVector}}","page":"Simulating the system","title":"CriticalTransitions.simulate","text":"simulate(sys::StochSystem, init::State; kwargs...)\n\nSimulates the StochSystem sys forward in time, starting at initial condition init.\n\nThis function uses the SDEProblem functionality of DifferentialEquations.jl.\n\nKeyword arguments\n\ndt=0.01: time step of integration\ntmax=1e3: total time of simulation\nsolver=EM(): SDE solver. Defaults to Euler-Mayurama\ncallback=nothing: callback condition\nprogress=true: shows a progress bar during simulation\nkwargs...: keyword arguments for solve(ODEProblem)\n\nFor more info, see SDEProblem.\n\nWarning: This function has only been tested for the EM() solver and out-of-place SDEFunctions.\n\n\n\n\n\n","category":"method"},{"location":"man/systems/#Predefined-dynamical-systems","page":"Predefined systems","title":"Predefined dynamical systems","text":"","category":"section"},{"location":"man/systems/#Life-sciences","page":"Predefined systems","title":"Life sciences","text":"","category":"section"},{"location":"man/systems/#FitzHugh-Nagumo-system","page":"Predefined systems","title":"FitzHugh-Nagumo system","text":"","category":"section"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"A 2D system given by","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"beginaligned\nfracdudt = frac1epsilon left( -alpha u^3 + gamma u - kappa v + I right) \nfracdvdt = -beta v + u  \nendaligned","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"where epsilon is the parameter of time scale separation between the state variables u and v. The parameters alpha 0, beta 1, gamma0, and kappa0 are real constants, and I denotes a driving term.","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"fitzhugh_nagumo(u, p, t)\nfitzhugh_nagumo!(du, u, p, t)\nfhn_ϵσ(ϵ, σ)   ","category":"page"},{"location":"man/systems/#CriticalTransitions.fitzhugh_nagumo-Tuple{Any, Any, Any}","page":"Predefined systems","title":"CriticalTransitions.fitzhugh_nagumo","text":"fitzhugh_nagumo(u, p, t)\n\nOut-of-place definition of the FitzHugh-Nagumo system.\n\nSee also fitzhugh_nagumo!.\n\n\n\n\n\n","category":"method"},{"location":"man/systems/#CriticalTransitions.fitzhugh_nagumo!-NTuple{4, Any}","page":"Predefined systems","title":"CriticalTransitions.fitzhugh_nagumo!","text":"fitzhugh_nagumo!(du, u, p, t)\n\nIn-place definition of the FitzHugh-Nagumo system.\n\nSee also fitzhugh_nagumo.\n\n\n\n\n\n","category":"method"},{"location":"man/systems/#CriticalTransitions.fhn_ϵσ-Tuple{Any, Any}","page":"Predefined systems","title":"CriticalTransitions.fhn_ϵσ","text":"fhn_ϵσ(ϵ,σ)\n\nA shortcut command for returning a StochSystem of the FitzHugh Nagumo system in a default setup with additive isotropic noise.\n\nThis setup fixes the parameters β = 3, α =  γ = κ = 1, I = 0 and leaves the value of the time-scale parameter ϵ as a function argument. The prescribed noise process is additive and isotropic: the variables are peturbed by independently drawn identical Gaussian white noise realisations, with standard deviation σ (the other function argument).\n\n\n\n\n\n","category":"method"},{"location":"man/systems/#Population-dynamics","page":"Predefined systems","title":"Population dynamics","text":"","category":"section"},{"location":"man/systems/#Modified-Truscott-Brindley-system","page":"Predefined systems","title":"Modified Truscott-Brindley system","text":"","category":"section"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"A two-dimensional predator-prey system given by ","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"beginaligned\nfractextd Ptextd t = rPbigg(1-fracPKbigg)-fracaP^2h^2+P^2Z \nfractextd Ztextd t = xibigg(fracaP^2h^2+P^2Z - mZ^2bigg)\nendaligned","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"The variables P and Z represent the concentration of phytoplankton (prey) and zooplankton (predator) species respectively. The system parameters can be interpreted as follows: ","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"r = 1: the phytoplankton growth rate\nK = 1: the carrying capacity of the phytoplankton\na = 19: the maximal predation rate\nh = 5112: the half-saturation constant\nxi = 110: the time-scale separation between the evolution of phytoplankton and zooplankton \nm = 00525: the zooplankton mortality rate ","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"The model (as discussed here) is a modified version of the original 1994 Truscott-Brindley system (see here), with a quadratic mortality term to enable bistability. The variable t has units of days. Following a non-dimensionalisation of the system, the dynamical equations convert to:","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"beginaligned\ndisplaystylefractextd tildePtextd tau = alpha tildePbigg(1-betafractildePP_1bigg)-fracgamma (tildePsqrtP_1)^2(tildeZZ_1)1+(tildePP_1)^2 \ndisplaystylefractextd tildeZtextd tau = xitildeZbigg(frac(tildePP_1)^21+(tildePP_1)^2 - fractildeZZ_1bigg)\nendaligned","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"Specifically, here we introduce the dimensionless variables tildeP tildeZ and tau according to the following transformations: ","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"beginaligned\nfractildePP_1 = fracPP_0  fractildeZZ_1 = fracZZ_0  tau = fractt_0\nendaligned","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"where P_1 P_0 Z_1 Z_0 and t_0 are constants to be determined in the non-dimensionalisation process. We take P_0 = h Z_0 = am t_0 = 1a and subsequently introduce the following dimensionless parameters alpha = ra beta = hK gamma = a(mh). The values of the (dimensionless) constants P_1 and Z_1 are tuned according to the user's preference; they can be chosen in  a way such that the fixed points of the system are all contained within the 01times 01 subspace, for instance (for which the values P_1 = beta and Z_0 = 56 are appropriate in this set up).  ","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"Below, the functions modifiedtruscottbrindley and modifiedtruscottbrindley! implement the non-dimensional form of the system. ","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"modifiedtruscottbrindley(u, p, t)\nmodifiedtruscottbrindley!(du, u, p, t)\nmodtb_αξσ(α, ξ, σ)","category":"page"},{"location":"man/systems/#CriticalTransitions.modifiedtruscottbrindley-Tuple{Any, Any, Any}","page":"Predefined systems","title":"CriticalTransitions.modifiedtruscottbrindley","text":"modifiedtruscottbrindley(u, p, t)\n\nOut-of-place definition of the modified Truscott-Brindley system. \n\nSee also modifiedtruscottbrindley!.\n\n\n\n\n\n","category":"method"},{"location":"man/systems/#CriticalTransitions.modifiedtruscottbrindley!-NTuple{4, Any}","page":"Predefined systems","title":"CriticalTransitions.modifiedtruscottbrindley!","text":"modifiedtruscottbrindley!(du, u, p, t)\n\nIn-place definition of the modified Truscott-Brindley system. \n\nSee also modifiedtruscottbrindley.\n\n\n\n\n\n","category":"method"},{"location":"man/systems/#CriticalTransitions.modtb_αξσ-Tuple{Any, Any, Any}","page":"Predefined systems","title":"CriticalTransitions.modtb_αξσ","text":"modtb_αξσ(α, ξ, σ)\n\nA shortcut command for returning a StochSystem of the modified Truscott-Brindley system in a default setup with multiplicative anisotropic noise. \n\nThis setup fixes the parameters β = 5/112, γ = 112/2.3625, P₁ = β, Z₁ = 5/6 and leaves the values of the parameters α and ξ as function arguments. The prescribed noise process is multiplicative and anisotropic: the first variable is peturbed by Gaussian white noise realisations that are multiplied by the variable's current value; the second variable has no stochastic component. The noise strength σ is left as the remaining function argument.\n\n\n\n\n\n","category":"method"},{"location":"man/systems/#Earth-and-Climate","page":"Predefined systems","title":"Earth & Climate","text":"","category":"section"},{"location":"man/systems/#Thermohaline-Circulation-box-models","page":"Predefined systems","title":"Thermohaline Circulation box models","text":"","category":"section"},{"location":"man/systems/#Stommel's-hemispheric-2-box-model","page":"Predefined systems","title":"Stommel's hemispheric 2-box model","text":"","category":"section"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"The famous 2-box model introduced by Stommel (1961) and later studied by Cessi (1994) can be generalized in the following form,","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"beginaligned\nfracdxd tau = 1 - x - nu x f(x-y) - Adelta x \nfracdyd tau = delta (R-y) - nu y f(x-y) \nendaligned","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"where x and y denote non-dimensional gradients of temperature and salinity, respectively, between the equatorial and the polar box.","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"The original Stommel 1961 model (see stommel), defined in terms of the parameters delta, lambda, and R, is obtained by setting tau = ct, nu = 1lambda, f(x-y) = x-y, and A=0.","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"Cessi's 1994 version of the model (cessi), written in terms of the parameters alpha, mu^2, and p, follows from the above equations by setting tau = tt_r, delta = 2alpha, nu=mu^2, f(x-y) = (x-y)^2k, R=pH(2S_0), and A=1.","category":"page"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"stommel(u, p, t; kwargs...)\ncessi(u, p, t)","category":"page"},{"location":"man/systems/#CriticalTransitions.stommel-Tuple{Any, Any, Any}","page":"Predefined systems","title":"CriticalTransitions.stommel","text":"stommel(u, p, t; kwargs...)\n\nStommel's hemispheric 2-box model of the Thermohaline Circulation[Stommel1961].\n\nThe state vector u = [x, y] describes the non-dimensional temperature (x) and salinity (y) gradients between the equatiorial and the polar box (details in the online docs).\n\nThe parameter vector p = [[delta, mu, R]] comprises the ratio delta of the saline and thermal relaxation coefficients, the advective coefficient mu = 1lambda, and the constant R as described in [^Stommel 1961]. The original values in the bistable regime are p = [[1/6, 5, 2]].\n\nKeyword arguments\n\nsmooth = 1e-6: Approximates x approx x tanh(xs), where s = smooth. If smooth=0, the exact absolute value is taken, making the equations non-smooth.\nflow_law: Relation between density difference and flow strength. Options:\n\"abs\": Original Stommel model [Stommel 1961]\n\"diffu_abs\": Absolute flow law Q2 in eq. (2.4) of [Cessi1994]\n\"diffu_sqr\": Absolute flow law Q3 in eq. (2.4) of [Cessi1994]\n\nSee also cessi.\n\n[Stommel1961]: Stommel (1961). Thermohaline Convection with two stable regimes of flow\n\n[Cessi1994]: Cessi (1994). A simple box model of stochastically forced thermohaline flow\n\n\n\n\n\n","category":"method"},{"location":"man/systems/#CriticalTransitions.cessi-Tuple{Any, Any, Any}","page":"Predefined systems","title":"CriticalTransitions.cessi","text":"cessi(u, p, t)\n\nCessi's hemispheric 2-box model of the Thermohaline Circulation (Cessi (1994)).\n\nParameters\n\np = [[alpha, mu2, pflux]]\n\nSee also stommel.\n\n\n\n\n\n","category":"method"},{"location":"man/systems/#Interhemispheric-3-box-model","page":"Predefined systems","title":"Interhemispheric 3-box model","text":"","category":"section"},{"location":"man/systems/","page":"Predefined systems","title":"Predefined systems","text":"rooth_smooth(u, p, t; kwargs...)","category":"page"},{"location":"man/systems/#CriticalTransitions.rooth_smooth-Tuple{Any, Any, Any}","page":"Predefined systems","title":"CriticalTransitions.rooth_smooth","text":"rooth_smooth(u, p, t; kwargs...)\n\nRooth's 3-box model of the interhemispheric Thermohaline Circulation, smooth version.\n\nThe model is slightly modified by including a salinity restoration term and replacing the absolute value of the flow strength q with a smooth hyperbolic tangent approximation.\n\nState vector\n\nu = [T1, T2, T3, S1, S3]\n\nParameters\n\np = [F1, F3, lambd_T, lambd_S, tau1, tau2, tau3, sig1, sig2, sig3, smooth]\n\nKeyword arguments\n\nk = 1.5e-6: hydraulic constant\nalpha = 1.5e-4: thermal expansion coefficient\nbeta = 8e-4: haline expansion coefficient\nV = 2: volume ratio between equatorial and polar boxes\n\n\n\n\n\n","category":"method"},{"location":"man/utils/#Convenience-functions-and-types","page":"Utilities","title":"Convenience functions and types","text":"","category":"section"},{"location":"man/utils/#Interface-to-DynamicalSystems.jl","page":"Utilities","title":"Interface to DynamicalSystems.jl","text":"","category":"section"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"tip: Using the functionality of DynamicalSystems.jl\nA StochSystem can easily be turned into a  CoupledODEs instance of DynamicalSystems.jl using the function CoupledODEs. Vice vera, a CoupledODEs system can be converted into a StochSystem via StochSystem(ds::CoupledODEs).","category":"page"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"This way, many of the methods in DynamicalSystems.jl can be used directly, even if we have not written an analogue method that takes StochSystem as input. For example, the Lyapunov spectrum of a StochSystem, here exemplified by the FitzHugh-Nagumo model, can be computed by typing:","category":"page"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"using CriticalTransitions, DynamicalSystems: lyapunovspectrum\nsys = StochSystem(fitzhugh_nagumo, [1.,3.,1.,1.,1.,0.], zeros(2))\nls = lyapunovspectrum(CoupledODEs(sys), 10000)","category":"page"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"CoupledODEs(sys::StochSystem; diffeq, t0=0.0)\nattractor_mapper(sys::StochSystem, attractors, eps=0.01; kwargs...)","category":"page"},{"location":"man/utils/#DynamicalSystemsBase.CoupledODEs-Tuple{StochSystem}","page":"Utilities","title":"DynamicalSystemsBase.CoupledODEs","text":"CoupledODEs(sys::StochSystem; diffeq, t0=0.0)\n\nConverts a StochSystem into CoupledODEs from DynamicalSystems.jl.\n\n\n\n\n\n","category":"method"},{"location":"man/utils/#CriticalTransitions.attractor_mapper","page":"Utilities","title":"CriticalTransitions.attractor_mapper","text":"attractor_mapper(sys::StochSystem, attractors, eps=0.01; kwargs...)\n\nWrapper around the AttractorsViaProximity mapper from DynamicalSystems.jl. Takes as input sys of type StochSystem, a  vector attractors containing as elements the state vectors of the stable fixed points, and a parameter eps to control the mapping algorithm. For more info, see the docs.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#StochSystem-utility-functions","page":"Utilities","title":"StochSystem utility functions","text":"","category":"section"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"drift(sys::StochSystem, x::State)\nsys_info(sys::StochSystem)\nsys_string(sys::StochSystem; verbose=true)","category":"page"},{"location":"man/utils/#CriticalTransitions.drift-Tuple{StochSystem, Union{Vector, SVector}}","page":"Utilities","title":"CriticalTransitions.drift","text":"drift(sys::StochSystem, x::State)\n\nReturns the drift field b(x) of the StochSystem sys at the state vector x.\n\n\n\n\n\n","category":"method"},{"location":"man/utils/#CriticalTransitions.sys_info-Tuple{StochSystem}","page":"Utilities","title":"CriticalTransitions.sys_info","text":"sys_info(sys::StochSystem)\n\nPrints StochSystem info of sys in structured format.\n\n\n\n\n\n","category":"method"},{"location":"man/utils/#CriticalTransitions.sys_string-Tuple{StochSystem}","page":"Utilities","title":"CriticalTransitions.sys_string","text":"sys_string(sys::StochSystem; verbose=true)\n\nReturns StochSystem info of sys as a string.\n\nKeyword arguments\n\nverbose: if true, the string includes additional descriptions. \n\n\n\n\n\n","category":"method"},{"location":"man/utils/#Noise-functions-for-sys.g","page":"Utilities","title":"Noise functions for sys.g","text":"","category":"section"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"idfunc(u, p, t)\nidfunc!(du, u, p, t)","category":"page"},{"location":"man/utils/#CriticalTransitions.idfunc-Tuple{Any, Any, Any}","page":"Utilities","title":"CriticalTransitions.idfunc","text":"idfunc(u, p, t)\n\nIdentity function for noise function StochSystem.g (out-of-place).\n\n\n\n\n\n","category":"method"},{"location":"man/utils/#CriticalTransitions.idfunc!-NTuple{4, Any}","page":"Utilities","title":"CriticalTransitions.idfunc!","text":"idfunc!(du, u, p, t)\n\nIdentity function for noise function StochSystem.g (in-place).\n\n\n\n\n\n","category":"method"},{"location":"man/utils/#Saving-data","page":"Utilities","title":"Saving data","text":"","category":"section"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"make_jld2(text::String, relpath::String=\"\")\nmake_h5(text::String, relpath::String=\"\")","category":"page"},{"location":"man/utils/#CriticalTransitions.make_jld2","page":"Utilities","title":"CriticalTransitions.make_jld2","text":"make_jld2(text::String, relpath::String=\"\")\n\nCreates/opens a .jld2 file with filename of the format \"ddmmyy_text.jld2\". Relative file path specified by relpath (must end with /).\n\nSee make_h5 for generating a .h5 file.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#CriticalTransitions.make_h5","page":"Utilities","title":"CriticalTransitions.make_h5","text":"make_h5(text::String, relpath::String=\"\")\n\nCreates/opens a .h5 file with filename of the format \"ddmmyy_text.h5\". Relative file path specified by relpath (must end with /).\n\nSee make_jld2 for generating a .jld2 file.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#Miscellaneous","page":"Utilities","title":"Miscellaneous","text":"","category":"section"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"is_iip(f::Function)","category":"page"},{"location":"man/utils/#CriticalTransitions.is_iip-Tuple{Function}","page":"Utilities","title":"CriticalTransitions.is_iip","text":"is_iip(f::Function)\n\nAsserts if f is in-place (true) or out-of-place (false).\n\nWarning: This function simply checks if there is a ! in the function name. Thus, if you do not add a ! to in-place function names (as recommended by the Julia style guide), this test will not work.\n\n\n\n\n\n","category":"method"},{"location":"man/utils/#Generalized-vector-norms","page":"Utilities","title":"Generalized vector norms","text":"","category":"section"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"anorm(vec, A; square=false)\nsubnorm(vec; kwargs...)","category":"page"},{"location":"man/utils/#CriticalTransitions.anorm-Tuple{Any, Any}","page":"Utilities","title":"CriticalTransitions.anorm","text":"anorm(vec, A; square=false)\n\nCalculates the generalized A-norm of the vector vec, v_A = sqrt(v^top cdot A cdot v), where A is a square matrix of dimension (lenth(vec) x length(vec)).\n\nKeyword arguments\n\nsquare: if true, returns square of norm; else, returns norm.\n\n\n\n\n\n","category":"method"},{"location":"man/utils/#CriticalTransitions.subnorm-Tuple{Any}","page":"Utilities","title":"CriticalTransitions.subnorm","text":"subnorm(vec; kwargs...)\n\nReturns the Euclidean norm of the vector vec; however, if directions are specified, the norm is only computed along the specified components of the vector, i.e. in a subspace of dimension length(directions).\n\nKeyword arguments\n\ndirections: a vector containing the indices of the components of vec to\n\nbe included. Defaults to 1:length(vec), i.e. all components.\n\nExample\n\nsubnorm([3,7,4]; directions=[1,3] calculates the norm of only the 1st and 3rd components of the vector [3,7,4]:\n\nsqrt3^2+4^2 = 5.\n\n\n\n\n\n","category":"method"},{"location":"man/utils/#length(sys.u)-dimensional-box","page":"Utilities","title":"length(sys.u)-dimensional box","text":"","category":"section"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"intervals_to_box(bmin::Vector, bmax::Vector)","category":"page"},{"location":"man/utils/#CriticalTransitions.intervals_to_box-Tuple{Vector, Vector}","page":"Utilities","title":"CriticalTransitions.intervals_to_box","text":"intervals_to_box(bmin::Vector, bmax::Vector)\n\nGenerates a box from specifying the interval limits in each dimension.\n\nbmin (Vector): lower limit of the box in each dimension\nbmax (Vector): upper limit\n\nExample\n\nintervals_to_box([-2,-1,0], [2,1,1]) returns a 3D box of dimensions [-2,2] × [-1,1] × [0,1].\n\n\n\n\n\n","category":"method"},{"location":"man/utils/#Custom-types","page":"Utilities","title":"Custom types","text":"","category":"section"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"Parameters = Union{Vector{Float64}, Vector{Int64}, Nothing}\nCovMatrix = Union{Matrix, UniformScaling{Bool}, Diagonal{Bool, Vector{Bool}}}\nState = Union{Vector, SVector}","category":"page"},{"location":"man/largedeviations/#Large-deviation-theory","page":"Large deviation theory","title":"Large deviation theory","text":"","category":"section"},{"location":"man/largedeviations/#Action-functionals","page":"Large deviation theory","title":"Action functionals","text":"","category":"section"},{"location":"man/largedeviations/#Freidlin-Wentzell-action","page":"Large deviation theory","title":"Freidlin-Wentzell action","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"fw_action(sys::StochSystem, path, time; kwargs...)","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.fw_action-Tuple{StochSystem, Any, Any}","page":"Large deviation theory","title":"CriticalTransitions.fw_action","text":"fw_action(sys::StochSystem, path, time; kwargs...)\n\nCalculates the Freidlin-Wentzell action of a given path with time points time in a  drift field specified by the deterministic dynamics of sys.\n\nThe path must be a (D x N) matrix, where D is the dimensionality of the system sys and N is the number of path points. The time array must have length N.\n\nReturns a single number, which is the value of the action functional\n\nS_Tphi_t = frac12 int_0^T  dot phi_t - b(phi_t) ^2_Q dt\n\nwhere phi_t denotes the path in state space, b the drift field, and T the total time of the path. The subscript Q refers to the generalized norm a_Q^2 = langle a Q^-1 b rangle (see anorm). Here Q is the noise covariance matrix sys.Σ.\n\nKeyword arguments\n\ncov_inv = nothing: Inverse of the covariance matrix Sigma. If nothing, Sigma^-1 is computed automatically.\n\n\n\n\n\n","category":"method"},{"location":"man/largedeviations/#Geometric-Freidlin-Wentzell-action","page":"Large deviation theory","title":"Geometric Freidlin-Wentzell action","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"geometric_action(sys::StochSystem, path, arclength=1; kwargs...)","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.geometric_action","page":"Large deviation theory","title":"CriticalTransitions.geometric_action","text":"geometric_action(sys::StochSystem, path, arclength=1; kwargs...)\n\nCalculates the geometric action of a given path with specified arclength for the drift field sys.f.\n\nFor a given path varphi, the geometric action bar S corresponds to the minimum of the Freidlin-Wentzell action S_T(phi) over all travel times T0, where phi denotes the path's parameterization in physical time (see fw_action). It is given by the integral\n\nbar Svarphi = int_0^L left( varphi_Q  b(varphi)_Q - langle varphi      b(varphi) rangle_Q right)  ds\n\nwhere s is the arclength coordinate, L the arclength, b the drift field, and the subscript Q refers to the generalized dot product langle a b rangle_Q = a^top cdot Q^-1 b (see anorm). Here Q is the noise covariance matrix sys.Σ.\n\nKeyword arguments\n\ncov_inv = nothing: Inverse of the covariance matrix Sigma. If nothing, Sigma^-1 is computed automatically. \n\nReturns the value of the geometric action bar S.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Onsager-Machlup-action","page":"Large deviation theory","title":"Onsager-Machlup action","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"om_action(sys::StochSystem, path, time; kwargs...)","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.om_action-Tuple{StochSystem, Any, Any}","page":"Large deviation theory","title":"CriticalTransitions.om_action","text":"om_action(sys::StochSystem, path, time; kwargs...)\n\nCalculates the Onsager-Machlup action of a given path with time points time for the drift field sys.f at noise strength sys.σ.\n\nThe path must be a (D x N) matrix, where D is the dimensionality of the system sys and N is the number of path points. The time array must have length N.\n\nReturns a single number, which is the value of the action functional\n\nI^sigma_Tphi_t = frac12 int_0^T left(  dot phi_t - b(phi_t) ^2_Q + fracsigma^22 div(b) right)  dt\n\nwhere phi_t denotes the path in state space, b the drift field, T the total time of the path, and sigma the noise strength. The subscript Q refers to the generalized norm a_Q^2 = langle a Q^-1 b rangle (see anorm). Here Q is the noise covariance matrix sys.Σ.\n\nKeyword arguments\n\ncov_inv = nothing: Inverse of the covariance matrix Sigma. If nothing, Sigma^-1 is computed automatically.\n\n\n\n\n\n","category":"method"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"For convenience, a general action function is available where the type of functional is set as an argument:","category":"page"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"action(sys::StochSystem, path::Matrix, time, functional; kwargs...)","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.action-Tuple{StochSystem, Matrix, Any, Any}","page":"Large deviation theory","title":"CriticalTransitions.action","text":"action(sys::StochSystem, path::Matrix, time, functional; kwargs...)\n\nComputes the action functional specified by functional for a given StochSystem sys and path parameterized by time.\n\nfunctional = \"FW\": Returns the Freidlin-Wentzell action (fw_action)\nfunctional = \"OM\": Returns the Onsager-Machlup action (om_action)\n\n\n\n\n\n","category":"method"},{"location":"man/largedeviations/#Minimum-action-paths","page":"Large deviation theory","title":"Minimum action paths","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"We provide the following two methods to calculate instantons, or minimum action paths, between two states of a StochSystem.","category":"page"},{"location":"man/largedeviations/#Minimum-action-method-(MAM)","page":"Large deviation theory","title":"Minimum action method (MAM)","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"Minimization of the Freidlin-Wentzell action using the L-BFGS algorithm of Optim.jl.","category":"page"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"min_action_method(sys::StochSystem, x_i::State, x_f::State, N::Int, T::Float64; kwargs...)","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.min_action_method-Tuple{StochSystem, Union{Vector, SVector}, Union{Vector, SVector}, Int64, Float64}","page":"Large deviation theory","title":"CriticalTransitions.min_action_method","text":"min_action_method(sys::StochSystem, x_i::State, x_f::State, N::Int, T::Real; kwargs...)\n\nRuns the Minimum Action Method (MAM) to find the minimum action path (instanton) between an initial state x_i and final state x_f.\n\nThis algorithm uses the minimizers of the Optim package to minimize the Freidlin-Wentzell action functional (see fw_action) for the given StochSystem sys. The path is initialized as a straight line between x_i and x_f, parameterized in time via N equidistant points and total time T. Thus, the time step between discretized path points is Delta t = TN. To set an initial path different from a straight line, see the multiple dispatch method\n\nmin_action_method(sys::StochSystem, init::Matrix, T::Real; kwargs...).\n\nThe minimization can be performed in blocks to save intermediate results.\n\nKeyword arguments\n\nfunctional = \"FW\": type of action functional to minimize.  Defaults to fw_action, alternative: om_action.\nmaxiter = 100: maximum number of iterations before the algorithm stops.\nblocks = 1: number of iterative optimization blocks\nmethod = LBFGS(): minimization algorithm (see Optim)\nsave_info = true: whether to save Optim information\nverbose = true: whether to print Optim information during the run\nshowprogress = false: whether to print a progress bar\nkwargs...: any keyword arguments from Optim.Options (see docs)\n\nOutput\n\nIf save_info, returns Optim.OptimizationResults. Else, returns only the optimizer (path). If blocks > 1, a vector of results/optimizers is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/largedeviations/#Geometric-minimum-action-method-(gMAM)","page":"Large deviation theory","title":"Geometric minimum action method (gMAM)","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"Minimization of the geometric action following Heymann and Vanden-Eijnden, PRL (2008).","category":"page"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"geometric_min_action_method(sys::StochSystem, x_i::State, x_f::State, arclength=1; kwargs...)","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.geometric_min_action_method","page":"Large deviation theory","title":"CriticalTransitions.geometric_min_action_method","text":"geometric_min_action_method(sys::StochSystem, x_i::State, x_f::State, arclength=1; kwargs...)\n\nComputes the minimizer of the Freidlin-Wentzell action using the geometric minimum action method (gMAM). Beta version, to be further documented.\n\nTo set an initial path different from a straight line, see the multiple dispatch method\n\ngeometric_min_action_method(sys::StochSystem, init::Matrix, arclength::Float64; kwargs...).\n\nKeyword arguments\n\nN = 100: number of discretized path points\nmaxiter = 100: maximum number of iterations before the algorithm stops\nconverge = 1e-5: convergence threshold for absolute change in action\nmethod = LBFGS(): choice of optimization algorithm (see below)\ntau = 0.1: step size (used only if method = \"HeymannVandenEijnden\")\n\nOptimization algorithms\n\nThe method keyword argument takes solver methods of the Optim.jl package; alternatively, the option solver = \"HeymannVandenEijnden\" uses the original gMAM algorithm[1].\n\n[1]: Heymann and Vanden-Eijnden, PRL (2008)\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#Analyzing-a-system's-stability-properties","page":"Stability analysis","title":"Analyzing a system's stability properties","text":"","category":"section"},{"location":"man/systemanalysis/#Fixed-points","page":"Stability analysis","title":"Fixed points","text":"","category":"section"},{"location":"man/systemanalysis/","page":"Stability analysis","title":"Stability analysis","text":"equilib(sys::StochSystem, state::State; kwargs...)\nfixedpoints","category":"page"},{"location":"man/systemanalysis/#CriticalTransitions.equilib-Tuple{StochSystem, Union{Vector, SVector}}","page":"Stability analysis","title":"CriticalTransitions.equilib","text":"equilib(sys::StochSystem, state::State; kwargs...)\n\nReturns the equilibrium solution of the system sys for given initial condition state.\n\nWarning: This algorithm simply evolves the deterministic system forward in time until a steady-state condition is satisfied. Thus, the algorithm may output a false solution if it gets stuck in a quasi-equilibrium, or slowly evolving state. For more robust results, use fixedpoints.\n\nKeyword arguments:\n\nabstol = 1e-5: steady-state condition. Simulation ends when the rate of change (Euclidean distance in state space) of the state falls below abstol.\ntmax = 1e5: maximum simulation time before the algorithm stops even if the steady-state condition is not reached.\ndt = 0.01: time step of the ODE solver.\nsolver = Euler(): ODE solver used for evolving the state.\n\n\n\n\n\n","category":"method"},{"location":"man/systemanalysis/#ChaosTools.fixedpoints","page":"Stability analysis","title":"ChaosTools.fixedpoints","text":"fixedpoints(sys::StochSystem, bmin::Vector, bmax::Vector)\n\nReturns fixed points, their eigenvalues and stability of the system sys within the state space volume defined by bmin and bmax.\n\nThis is a wrapper around the fixedpoints function of DynamicalSystems.jl.\n\nInput\n\nbmin (Vector): lower limits of the state space box to be considered, as a vector of coordinates\nbmax (Vector): upper limits\nalternatively box (IntervalBox) can replace bmin and bmax\n\nExample: fixedpoints(sys, [-2,-1,0], [2,1,1]) finds the fixed points of the 3D system sys in a cube defined by the intervals [-2,2] × [-1,1] × [0,1].\n\nOutput\n\n[fp, eigs, stable]\n\nfp: Dataset of fixed points\neigs: vector of Jacobian eigenvalues of each fixed point\nstable: vector of booleans indicating the stability of each fixed point (true=stable, false=unstable)\n\nAdditional methods\n\nfixedpoints(sys::StochSystem, box)\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#Basins-of-attraction","page":"Stability analysis","title":"Basins of attraction","text":"","category":"section"},{"location":"man/systemanalysis/","page":"Stability analysis","title":"Stability analysis","text":"basins(sys::StochSystem, A, B, C, H; kwargs)\nbasinboundary(X, Y, h; kwargs...)\nbasboundary(sys::StochSystem, xrange::Vector, yrange::Vector, xspacing::Float64, attractors::Vector; kwargs...)","category":"page"},{"location":"man/systemanalysis/#CriticalTransitions.basins-Tuple{StochSystem, Vararg{Any, 4}}","page":"Stability analysis","title":"CriticalTransitions.basins","text":"basins(sys::StochSystem, A, B, C, H; kwargs...)\n\nComputes the basins of attraction of StochSystem sys on a plane spanned by the distinct points A, B, C and limited by the box H. Uses the AttractorsViaProximity function from DynamicalSystems.jl to compute the basins of attraction.\n\nA, B, C are elements of mathbbR^d (where d is the dimension of the  sys) and H is a hyperrectangle in mathbbR^d.\n\nThe plane is given by P_UV = A+u(B-A)+v(C-A)inmathbbR^d u in U vin V for some closed and bounded real intervals U and V which are selected such that both\n\nP_UV subseteq H, and\nUtimes VsubseteqmathbbR^2 has maximal area,\n\ni.e. P_UV is the \"largest\" possible plane contained within H. This plane is determined behind the scenes.\n\nThis function returns a four-dimensional vector. The first two entries are discretised versions of the interval U and V (as defined above, of lengths ell_Uell_V respectively); the third entry is a dictionary of the attractors (stable equilibria) of the system within H, and the final entry is an ell_Vtimesell_U matrix of integers that group the initial conditions (written in terms of A+u(B-A)+v(C-A) where uin U and vin V) by which attractor they will in time converge to.\n\nKeyword arguments\n\nbstep = [0.01, 0.01]: a vector of length two whose elements respectively specify the length of the incremental steps taken across each dimension in the discretisation of your plane\npstep = [0.1, 0.1]: a vector of length two whose elements give the increments of the mesh that the maximisation process of finding a plane from a box is taken over (for more information see the source code of the function plane in the src/systemanalysis/planeofbox.jl file)\nϵ_mapper = 0.01: ϵ parameter of AttractorsViaProximity\nkwargs...: keyword arguments passed to the AttractorsViaProximity function (namely, Ttr, Δt, horizon_limit, mx_chk_lost)\n\n\n\n\n\n","category":"method"},{"location":"man/systemanalysis/#CriticalTransitions.basinboundary-Tuple{Any, Any, Any}","page":"Stability analysis","title":"CriticalTransitions.basinboundary","text":"basinboundary(X, Y, h; kwargs...)\n\nComputes the basin boundary for given output X, Y, h of the basins function.\n\nTo be further documented.\n\n\n\n\n\n","category":"method"},{"location":"man/systemanalysis/#CriticalTransitions.basboundary-Tuple{StochSystem, Vector, Vector, Float64, Vector}","page":"Stability analysis","title":"CriticalTransitions.basboundary","text":"basboundary(sys::StochSystem, xrange::Vector, yrange::Vector, xspacing::Float64, attractors::Vector; kwargs...)\n\nThis function computes the basin boundary.\n\n\n\n\n\n","category":"method"},{"location":"man/systemanalysis/#Edge-tracking","page":"Stability analysis","title":"Edge tracking","text":"","category":"section"},{"location":"man/systemanalysis/","page":"Stability analysis","title":"Stability analysis","text":"The edge tracking algorithm is a simple numerical method to find the edge state or (possibly chaotic) saddle on the boundary between two basins of attraction. It is first introduced by Battelino et al. (1988) and further described by Skufca et al. (2006).","category":"page"},{"location":"man/systemanalysis/","page":"Stability analysis","title":"Stability analysis","text":"edgetracking(sys::StochSystem, u1::State, u2::State, attractors::Vector; kwargs...)\nbisect_to_edge(sys::StochSystem, u1::State, u2::State, attractors::Vector; kwargs...)","category":"page"},{"location":"man/systemanalysis/#CriticalTransitions.edgetracking-Tuple{StochSystem, Union{Vector, SVector}, Union{Vector, SVector}, Vector}","page":"Stability analysis","title":"CriticalTransitions.edgetracking","text":"edgetracking(sys::StochSystem, u1::State, u2::State, attractors::Vector; kwargs...)\n\nRuns the edge tracking algorithm.\n\nInput\n\nsys: dynamical system of type StochSystem\nu1, u2: initial states; must belong to different basins of attraction\nattractors: vector of state vectors corresponding to the stable fixed points of sys\n\nKeyword arguments\n\neps1 = 1e-9: tolerance for bisection distance\neps2 = 1e-8: tolerance for divergence of trajectories before re-bisecting\nconverge = 1e-5: convergence criterion for M state accuracy (Euclidean distance)\ndt = 0.01: integration time step \ntmax = Inf: maximum integration time of parallel trajectories until re-bisection \nϵ_mapper = 0.1: distance threshold for AttractorMapper\ndt_mapper = 0.01: time step for AttractorMapper (keyword argument Δt)\nsolver = Vern9(): ODE solver from DifferentialEquations.jl\nmaxit = 100: maximum number of iterations before algorithm stops \nverbose = true: print status updates during run\noutput_all = false: if false, returns M state, else returns all points of the track\nkwargs...: additional keyword arguments of AttractorsViaProximity may be passed\n\nReturns\n\nIf output_all, a single state vector corresponding to the found edge state is returned. Else, a triple edge, track1, track2 is returned, where track1 and track2 are the tracks along the edge within the basin of attraction of u1 and u2, respectively; edge is the track along the edge derived from (track1 + track2)/2.\n\nwarning: Warning\nMay behave erroneously when run with solver = SimpleATsit5(), which is the default solver for AttractorsViaProximity. The recommended solver is Vern9().\n\n\n\n\n\n","category":"method"},{"location":"man/systemanalysis/#CriticalTransitions.bisect_to_edge-Tuple{StochSystem, Union{Vector, SVector}, Union{Vector, SVector}, Vector}","page":"Stability analysis","title":"CriticalTransitions.bisect_to_edge","text":"bisect_to_edge(sys::StochSystem, u1::State, u2::State, attractors::Vector; kwargs...)\n\nBisects to the basin boundary between two initial points u1 and u2. Returns the two  final points, one on each side of the basin boundary, that are less than eps1 apart  from each other. \n\nKeyword arguments\n\neps1=1e-9: tolerance for final distance between the two states\nϵ_mapper=0.1: ϵ parameter for AttractorMapper\ndt_mapper = 0.01: time step for AttractorMapper (keyword argument Δt)\nsolver=Vern9(): solver for AttractorMapper\nkwargs...: additional kwargs that can be passed to AttractorMapper\n\n\n\n\n\n","category":"method"},{"location":"man/sampling/#Sampling-transitions","page":"Sampling transitions","title":"Sampling transitions","text":"","category":"section"},{"location":"man/sampling/#...-by-direct-simulation","page":"Sampling transitions","title":"... by direct simulation","text":"","category":"section"},{"location":"man/sampling/","page":"Sampling transitions","title":"Sampling transitions","text":"These functions generate noise-induced transitions between an initial and final state.","category":"page"},{"location":"man/sampling/","page":"Sampling transitions","title":"Sampling transitions","text":"transition(sys::StochSystem, x_i::State, x_f::State; kwargs...)\ntransitions(sys::StochSystem, x_i::State, x_f::State, N=1; kwargs...)","category":"page"},{"location":"man/sampling/#CriticalTransitions.transition-Tuple{StochSystem, Union{Vector, SVector}, Union{Vector, SVector}}","page":"Sampling transitions","title":"CriticalTransitions.transition","text":"transition(sys::StochSystem, x_i::State, x_f::State; kwargs...)\n\nGenerates a sample transition from point x_i to point x_f.\n\nThis function simulates sys in time, starting from initial condition x_i, until entering a length(sys.u)-dimensional ball of radius rad_f around x_f.\n\nKeyword arguments\n\nrad_i=0.1: radius of ball around x_i\nrad_f=0.1: radius of ball around x_f\ncut_start=true: if false, returns the whole trajectory up to the transition\ndt=0.01: time step of integration\ntmax=1e3: maximum time when the simulation stops even x_f has not been reached\nrad_dims=1:length(sys.u): the directions in phase space to consider when calculating the radii rad_i and rad_f. Defaults to all directions. To consider only a subspace of state space, insert a vector of indices of the dimensions to be included.\nsolver=EM(): numerical solver. Defaults to Euler-Mayurama.\nprogress: shows a progress bar with respect to tmax\n\nOutput\n\n[path, times, success]\n\npath (Matrix): transition path (size [dim × N], where N is the number of time points)\ntimes (Vector): time values (since start of simulation) of the path points (size N)\nsuccess (bool): if true, a transition occured (i.e. the ball around x_f has been reached), else false\nkwargs...: keyword arguments passed to simulate\n\nSee also transitions, simulate.\n\n\n\n\n\n","category":"method"},{"location":"man/sampling/#CriticalTransitions.transitions","page":"Sampling transitions","title":"CriticalTransitions.transitions","text":"transitions(sys::StochSystem, x_i::State, x_f::State, N=1; kwargs...)\n\nGenerates an ensemble of N transition samples of sys from point x_i to point x_f.\n\nThis function repeatedly calls the transition function to efficiently generate an ensemble of transitions, which are saved to a file or returned as an array of paths. Multi-threading is enabled.\n\nKeyword arguments\n\nrad_i=0.1: radius of ball around x_i\nrad_f=0.1: radius of ball around x_f\ncut_start=true: if false, returns the whole trajectory up to the transition\nNmax: number of attempts before the algorithm stops even if less than N transitions occurred.\ndt=0.01: time step of integration\ntmax=1e3: maximum time when the simulation stops even x_f has not been reached\nrad_dims=1:length(sys.u): the directions in phase space to consider when calculating the radii rad_i and rad_f. Defaults to all directions. To consider only a subspace of state space, insert a vector of indices of the dimensions to be included.\nsolver=EM(): numerical solver. Defaults to Euler-Mayurama\nprogress: shows a progress bar with respect to Nmax\nsavefile: if nothing, no data is saved to a file. To save to a file, see below.\n\nSee also transition.\n\nSaving data to file\n\nThe savefile keyword argument allows saving the data to a .jld2 or .h5 file. To do so:\n\nCreate and open a file by typing file = jld2open(\"filename.jld2\", \"a+\") or file = h5open(\"filename.h5\", \"cw\"). This requires JLD2.jl/HDF5.jl; the convenience functions make_jld2, make_h5 provide this out of the box.\nPass the label file to the savefile argument of transitions.\nDon't forget to close(file) at the end.\n\nOutput\n\n[samples, times, idx, N_fail]\n\nsamples (Array of Matrices): sample paths. Each path i has size (dim × Ni), where Ni is the number of path points\ntimes (Array of Vectors): time values (since simulation start) of path points for each path\nidx (Array): list of sample indices i that produced a transition\nN_fail (Int): number of samples that failed to produce a transition\n\nAn example script using transitions is available here.\n\n\n\n\n\n","category":"function"},{"location":"man/sampling/#...-in-pathspace","page":"Sampling transitions","title":"... in pathspace","text":"","category":"section"},{"location":"man/sampling/","page":"Sampling transitions","title":"Sampling transitions","text":"langevinmcmc(sys::StochSystem, init; kwargs...)\nstochastic_bridge(sys::StochSystem, Tphys::Float64, Δz::Float64)\nsymbolise_spde(sys::StochSystem)\nlangevinmcmc_spde(u, p, t)","category":"page"},{"location":"man/sampling/#CriticalTransitions.langevinmcmc-Tuple{StochSystem, Any}","page":"Sampling transitions","title":"CriticalTransitions.langevinmcmc","text":"langevinmcmc(sys::StochSystem, init; kwargs...)\n\nRuns Langevin MCMC bridge sampling for a given system sys and initial path init, using Symbolics.jl to compute the functional derivative.\n\nReturns a three-dimensional array of size (M, length(sys.u), N), where M is the number of virtual time steps, N the number of physical time steps, and length(sys.u) the number of system dimensions.\n\nTo be further documented in following versions.\n\nKeyword arguments\n\nT = 15: physical path time\ntmax = 250: virtual time duration\nΔt = 1e-3: virtual time step\nnoise = sys.σ: noise strength of additive spatio-temporal noise term\nannealing = false: whether to enable simulated annealing\nshowprogress = true: whether to print a progress bar\n\n\n\n\n\n","category":"method"},{"location":"man/sampling/#CriticalTransitions.stochastic_bridge-Tuple{StochSystem, Float64, Float64}","page":"Sampling transitions","title":"CriticalTransitions.stochastic_bridge","text":"stochastic_bridge(sys::StochSystem, Tphys::Float64, Δz::Float64)\n\nGiven a StochSystem sys, this function returns another higher-dimensional StochSystem that enables out-of-the-box Langevin-MCMC-type analysis. The idea is that one can transform the Langevin MCMC SPDE problem into a SDE problem of dimension M =(N+1)d that the StochSystem struct can nicely describe. Here d is the dimension of sys and N+1 is the number of the discrete path points on your transition path (in the context of the Langevin MCMC problem). \n\nFunction arguments\n\nsys::StochSystem: the StochSystem you are carrying out your explorations on.\nTphys::Float64: the total physical time you want to assign to your transition paths. \nΔz::Float64: the physical time-step you wish to have across your transitions.  \n\nThe f-field of the returned StochSystem is namely the langevinmcmc_spde function, and all other fields are chosen appropriately for the conversion between the SPDE boundary-value problem and the SDE initial-value problem. As of right now, the σ-field of the returned StochSystem equals sys.σ√(2/Δz), which is slightly different to how it is written in the original SPDE (see langevinmcmc_spde(u, p, t)); this modification is for numerical purposes, in order to account for the spatial-temporal white-noise in the original SPDE problem.    \n\n\n\n\n\n","category":"method"},{"location":"man/sampling/#CriticalTransitions.symbolise_spde-Tuple{StochSystem}","page":"Sampling transitions","title":"CriticalTransitions.symbolise_spde","text":"symbolise_spde(sys::StochSystem)\n\nGiven a StochSystem sys, this function uses Symbolics.jl to compute symbolic versions of multiple terms that show up in the Langevin MCMC SPDE (see langevinmcmc_spde(u, p, t)).\n\nIn  a vector of length four it returns the state variables of sys, the Jacobian of the drift field nablaboldsymbolb, the term nablalangleboldsymbolb Sigma^-1boldsymbolbrangle which we refer to as grad_dot_term, and nabla(nablacdot boldsymbolb) which we refer to as grad_div_term. \n\n\n\n\n\n","category":"method"},{"location":"man/sampling/#CriticalTransitions.langevinmcmc_spde-Tuple{Any, Any, Any}","page":"Sampling transitions","title":"CriticalTransitions.langevinmcmc_spde","text":"langevinmcmc_spde(u, p, t)\n\nFor a StochSystem sys, given a discretised version of a transition path boldsymbolx(tz) = varphi(z) z in 0 T_textphys that travels between two points in state-space in finite-time T_textphys, this function uses symbolic differentiation to compute the value of the LangevinMCMC SPDE \n\nfracpartial boldsymbolxpartial t = Sigma^-1fracpartial^2boldsymbolxpartial z^2 - big(Sigma^-1nabla boldsymbolb - nablaboldsymbolb^daggerSigma^-1big)fracpartial boldsymbolxpartial z - frac12nablalangleboldsymbolbSigma^-1boldsymbolbranglefracsigma^22nablabig(nablacdotboldsymbolbbig)+sqrt2sigmaboldsymboleta(zt)\n\nacross the range of physical time points z in the discretisation, say  z in k(Delta z) k in 0 1 2  N. In line with the boundary conditions of the Langevin MCMC SPDE problem, this partial derivative has value zero at the physical start and end times zin 0T_textphys. Here boldsymbolb sigma and Sigma are the drift field, noise strength and covariance matrix of sys, respectively.  \n\nFunction arguments:\n\nu: the transition path at virtual time t. Given that the number of discrete points in path space is N+1, and sys is d-dimensional, one should enter a concatenated vector of length M=(N+1)d of the form x_1(t0) x_1(tDelta z)  x_1(t NDelta z)  x_d(t0) x_d(tDelta z)  x_d(t NDelta z).\np: the parameters required for the computation of Langevin MCMC SPDE. One should enter [sys.dim, sys.σ, sys.Σ, Δz, state_vars, jacobian, grad_dot_term, grad_div_term] where Δz is the physical time-step, and state_vars, jacobian, grad_dot_term, grad_div_term are precisely the outputs of the function symbolise_spde(sys::StochSystem).\nt: the current fixed value of virtual time that the transition path corresponds to. One should enter a Float64.\n\nThe function returns an M-dimensional vector of partial-deriviates biggfracpartial x_1partial t(t0) fracpartial x_1partial t(tDelta z)  fracpartial x_1partial t(tNDelta z)  fracpartial x_dpartial t(t0) fracpartial x_dpartial t(tDelta z)  fracpartial x_dpartial t(tNDelta z)bigg. \n\n\n\n\n\n","category":"method"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#Installation","page":"Quickstart","title":"Installation","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"As this module is not published yet, there are two ways to access it:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Option 1 (recommended): Install from GitHub\nEnter the Julia package manager by typing ] in the REPL: julia> ]\ntype add https://github.com/juliadynamics/CriticalTransitions.jl.git\nOption 2: Load module locally\nClone the repo: git clone https://github.com/juliadynamics/CriticalTransitions.jl.git\nIn Julia, include the module file: include(\"PATH/src/CriticalTransitions.jl\"), where PATH is the relative path to the repo you just cloned\nLoad the module: using .CriticalTransitions","category":"page"},{"location":"quickstart/#Basic-usage","page":"Quickstart","title":"Basic usage","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The general workflow of CriticalTransitions essentially follows two steps:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Define your system (see Defining a StochSystem)\nInvestigate the system by calling methods (see Methods)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"info: Extension to RateSystem and TippingSystem\nWe are currently working on extending the types of dynamical systems that can be studied with CriticalTransitions.jl. Particularly, we are planning to introduce the overarching structure TippingSystem, which has two subtypes: StochSystem (as it already exists) and RateSystem, a new dynamical system type in which the system parameters may evolve in time.","category":"page"},{"location":"quickstart/#Methods","page":"Quickstart","title":"Methods","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Currently the following functions are implemented to analyze a StochSystem and  corresponding sample transition paths.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Pages = [\"man/systemanalysis.md\", \"man/simulation.md\", \"man/sampling.md\", \"man/largedeviations.md\"]","category":"page"},{"location":"quickstart/#Systems","page":"Quickstart","title":"Systems","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The following deterministic ODE systems have been implemented so far:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Pages = [\"man/systems.md\"]","category":"page"},{"location":"#CriticalTransitions.jl","page":"Home","title":"CriticalTransitions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for the numerical investigation of noise- and rate-induced transitions in dynamical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Building on DynamicalSystems.jl and DifferentialEquations.jl, this package aims to provide a toolbox for dynamical systems under time-dependent forcing, with a focus on tipping phenomena and metastability.","category":"page"},{"location":"","page":"Home","title":"Home","text":"compat: Compatibility\nThis version (v0.2) is now compatible with DynamicalSystems v3.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: CT.jl infographic)","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Current features\nStability analysis: Fixed points, linear stability, basins of attraction, edge tracking\nStochastic simulation: Gaussian noise, uncorrelated and correlated, additive and multiplicative\nTransition path sampling: Ensemble sampling by direct simulation and Pathspace Langevin MCMC\nLarge deviation theory: Action functionals and minimization algorithms (MAM, gMAM)","category":"page"},{"location":"","page":"Home","title":"Home","text":"ukw: Planned features\nRare event simulation: importance sampling, AMS\nQuasipotentials: Ordered line integral method (OLIM)\nRate-induced tipping tools\n...?","category":"page"},{"location":"","page":"Home","title":"Home","text":"Developers: Reyk Börner, Ryan Deeley, Raphael Römer and Orjan Ameye","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thanks to Jeroen Wouters, Calvin Nesbitt, Tobias Grafke, George Datseris and Oliver Mehling","category":"page"},{"location":"","page":"Home","title":"Home","text":"This work is part of the CriticalEarth project.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To give you an idea of how our package works, this tutorial provides some example code with explanations.","category":"page"},{"location":"tutorial/#Example:-FitzHugh-Nagumo-model","page":"Tutorial","title":"Example: FitzHugh-Nagumo model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Consider the FitzHugh-Nagumo model,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginaligned\nfracdudt = frac1epsilon left( -alpha u^3 + gamma u - kappa v + I right) \nfracdvdt = -beta v + u  \nendaligned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where epsilon is the parameter of time scale separation between the state variables u and v. The parameters alpha 0, beta 1, gamma0, and kappa0 are real constants, and I denotes a driving term.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's investigate this system under stochastic forcing.","category":"page"},{"location":"tutorial/#System-definition","page":"Tutorial","title":"System definition","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, we need to translate the system equations above into Julia code.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This works by defining a function f(u,p,t) which takes as input a vector u of state variables (u,v), a vector p of parameters, and time t. The function must return an array of flow increments (du, dv). For performance reasons, it is advisable to return a StaticArray SA[du, dv] rather than just a Vector [du, dv]. This is why we need the StaticArrays package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CriticalTransitions\n\nfunction fitzhugh_nagumo(u,p,t)\n    u, v = u\n    ϵ, β, α, γ, κ, I = p[1]\n\n    du = (-α*u^3 + γ*u - κ*v + I)/ϵ\n    dv = -β*v + u\n\n    SA[du, dv]\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the system parameters ϵ, β, α, γ, κ, I = p[1] are unpacked as the first component of p. This is necessary because in CriticalTransitions.jl one can also define a separate set of parameters for the stochastic component of the system, which would then make up the second component p[2] ( see Defining a StochSystem).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tip: In-place vs. out-of-place\nThe function fitzhugh_nagumo(u,p,t) is defined out-of-place. It is also possible to define the system in-place as fitzhugh_nagumo!(du,u,p,t). For more info, see here.","category":"page"},{"location":"tutorial/#StochSystem","page":"Tutorial","title":"StochSystem","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we turn the fitzhugh_nagumo system into a stochastic dynamical system. Suppose we would like to force both state variables u and v with additive, uncorrelated Gaussian noise of intensity sigma. This is the default case. We simply write","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p = [1., 3., 1., 1., 1., 0.] # Parameters (ϵ, β, α, γ, κ, I)\nσ = 0.18 # noise strength\n\n# StochSystem\nsys = StochSystem(fitzhugh_nagumo, p, zeros(2), σ)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we have chosen zeros(2) as the initial state of the system. The length of this vector must correspond to the system's dimensionality, but for now the state is just a placeholder that aligns our syntax with that of DifferentialEquations.jl and DynamicalSystems.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Multiplicative and/or correlated noise\nOf course, it is also possible to define more complicated noise processes than simple additive white noise. This is done by specifying a custom noise function and covariance matrix in the StochSystem definition. For more info, see Defining a StochSystem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"That's it! Now we can throw the toolbox of CriticalTransitions at our stochastic FitzHugh-Nagumo system sys.","category":"page"},{"location":"tutorial/#Find-stable-equilibria","page":"Tutorial","title":"Find stable equilibria","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the parameters chosen above, the FitzHugh-Nagumo system is bistable. Let's compute the fixed points using the fixedpoints function from ChaosTools.jl. As this function is from the DynamicalSystems ecosystem, it takes a system of type CoupledODEs as input. We can simply convert the StochSystem sys via the CoupledODEs function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Calculate fixed points\nds = CoupledODEs(sys)\nbox = intervals_to_box([-2,-2], [2,2])\neqs, eigs, stab = fixedpoints(ds, box)\n\n# Store the two stable fixed points\nfp1, fp2 = eqs[stab]","category":"page"},{"location":"tutorial/#Stochastic-simulation","page":"Tutorial","title":"Stochastic simulation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Using the simulate function, we now run a simulation of our system starting out from the fixed point fp1:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sim = simulate(sys, fp1, dt=0.01, tmax=1e3)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the keyword arguments, we have specified the time step dt and total duration tmax of the numerical time integration.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The simulated trajectory is stored in sim as a matrix with 2 rows corresponding to the state variables u, v, and 10,000 columns corresponding to the time steps.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's plot the result. Did the trajectory transition to the other attractor?","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\nfig = Figure(size = (800, 600), fontsize=18)\nax = Axis(fig[1, 1], xlabel = \"u\", ylabel = \"v\")\nlimits!(-1.2,1.2,-0.6,0.6)\nlines!(ax, sim[1,:], sim[2,:])\nscatter!(ax, [fp1[1], fp2[1]], [fp1[2], fp2[2]], color=:red, markersize=20)\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Hopefully, this helped you to get started. For more info, check out the Manual section of these docs.","category":"page"}]
}

var documenterSearchIndex = {"docs":
[{"location":"man/simulation/#Simulating-the-system","page":"Simulating the system","title":"Simulating the system","text":"","category":"section"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"We provide two main functions to simulate a CoupledSDEs forward in time:","category":"page"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"relax for the system's deterministic evolution (in the absence of noise) based on the ODEProblem of DifferentialEquations.jl\nsimulate for stochastic dynamics based on the SDEProblem of DifferentialEquations.jl","category":"page"},{"location":"man/simulation/#Deterministic-dynamics","page":"Simulating the system","title":"Deterministic dynamics","text":"","category":"section"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"relax(sys::CoupledSDEs, T, init; kwargs...)","category":"page"},{"location":"man/simulation/#CriticalTransitions.relax-Tuple{CoupledSDEs, Any, Any}","page":"Simulating the system","title":"CriticalTransitions.relax","text":"relax(sys::CoupledSDEs, T; ...) -> Any\nrelax(sys::CoupledSDEs, T, init; alg, kwargs...) -> Any\n\n\nSimulates the deterministic dynamics of CoupledSDEs sys in time with an amount T, starting at initial condition init.\n\nThis function integrates sys.f forward in time, using the ODEProblem functionality of DifferentialEquations.jl. Thus, relax is identical to simulate when setting the noise strength sys.σ = 0.\n\nKeyword arguments\n\nsolver=Tsit5(): ODE solver. Defaults to Tsitouras 5/4 Runge-Kutta method.\nkwargs...: keyword arguments for solve(ODEProblem)\n\nFor more info, see ODEProblem. For stochastic integration, see simulate.\n\n\n\n\n\n","category":"method"},{"location":"man/simulation/#Stochastic-dynamics","page":"Simulating the system","title":"Stochastic dynamics","text":"","category":"section"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"simulate(sys::CoupledSDEs, T, init; kwargs...)","category":"page"},{"location":"man/simulation/#CriticalTransitions.simulate-Tuple{CoupledSDEs, Any, Any}","page":"Simulating the system","title":"CriticalTransitions.simulate","text":"simulate(sys::CoupledSDEs, T; ...) -> Any\nsimulate(sys::CoupledSDEs, T, init; alg, kwargs...) -> Any\n\n\nSimulates the CoupledSDEs sys forward in time with an amount T, starting at initial condition init.\n\nThis function uses the SDEProblem functionality of DifferentialEquations.jl.\n\nKeyword arguments\n\nalg=SOSRA(): SDE solver. Defaults to an  adaptive strong order 1.5 method.\nkwargs...: keyword arguments for solve(SDEProblem)\n\nFor more info, see SDEProblem.\n\n\n\n\n\n","category":"method"},{"location":"man/utils/#Convenience-functions-and-types","page":"Utilities","title":"Convenience functions and types","text":"","category":"section"},{"location":"man/utils/#Interface-to-DynamicalSystems.jl","page":"Utilities","title":"Interface to DynamicalSystems.jl","text":"","category":"section"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"tip: Using the functionality of DynamicalSystems.jl\nA CoupledSDEs can easily be turned into a  CoupledODEs instance of DynamicalSystems.jl using the function CoupledODEs. Vice vera, a CoupledODEs system can be converted into a CoupledSDEs via CoupledSDEs(ds::CoupledODEs, g) with g the noise function.","category":"page"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"This way, many of the methods in DynamicalSystems.jl can be used directly, even if we have not written an analogue method that takes CoupledSDEs as input. For example, the Lyapunov spectrum of a CoupledSDEs, here exemplified by the FitzHugh-Nagumo model, can be computed by typing:","category":"page"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"using CriticalTransitions\nusing DynamicalSystems: lyapunovspectrum\n\nfunction fitzhugh_nagumo(u, p, t)\n    x, y = u\n    ϵ, β, α, γ, κ, I = p\n\n    dx = (-α * x^3 + γ * x - κ * y + I) / ϵ\n    dy = -β * y + x\n\n    return SA[dx, dy]\nend\n\nsys = CoupledSDEs(fitzhugh_nagumo, id_func, zeros(2), σ, [1.,3.,1.,1.,1.,0.])\nls = lyapunovspectrum(CoupledODEs(sys), 10000)","category":"page"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"CoupledODEs(sys::CoupledSDEs; diffeq, t0=0.0)","category":"page"},{"location":"man/utils/#DynamicalSystemsBase.CoupledODEs-Tuple{CoupledSDEs}","page":"Utilities","title":"DynamicalSystemsBase.CoupledODEs","text":"CoupledODEs(sys::CoupledSDEs; diffeq, t0) -> CoupledODEs\n\n\nConverts a CoupledSDEs into CoupledODEs from DynamicalSystems.jl.\n\n\n\n\n\n","category":"method"},{"location":"man/utils/#CoupledSDEs-utility-functions","page":"Utilities","title":"CoupledSDEs utility functions","text":"","category":"section"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"noise_strength\ncovariance_matrix\nnoise_process\nCriticalTransitions.drift\nCriticalTransitions.div_drift","category":"page"},{"location":"man/utils/#CriticalTransitions.noise_strength","page":"Utilities","title":"CriticalTransitions.noise_strength","text":"noise_strength(sys::CoupledSDEs) -> Any\n\n\nGives the noise strength specified in sys.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#CriticalTransitions.covariance_matrix","page":"Utilities","title":"CriticalTransitions.covariance_matrix","text":"covariance_matrix(sys::CoupledSDEs) -> Any\n\n\nGives the covariance matrix specified in sys.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#CriticalTransitions.noise_process","page":"Utilities","title":"CriticalTransitions.noise_process","text":"noise_process(sys::CoupledSDEs) -> Any\n\n\nTranslates the stochastic process specified in sys into the language required by the SDEProblem of DynamicalSystems.jl.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#CriticalTransitions.drift","page":"Utilities","title":"CriticalTransitions.drift","text":"drift(sys::CoupledSDEs{IIP}, x) -> Any\n\n\nReturns the drift field b(x) of the CoupledSDEs sys at the state vector x.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#CriticalTransitions.div_drift","page":"Utilities","title":"CriticalTransitions.div_drift","text":"div_drift(sys::CoupledSDEs, x) -> Any\n\n\nComputes the divergence of the drift field sys.f at the given point x.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#Saving-data","page":"Utilities","title":"Saving data","text":"","category":"section"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"make_jld2(text::String, relpath::String=\"\")\nmake_h5(text::String, relpath::String=\"\")","category":"page"},{"location":"man/utils/#CriticalTransitions.make_jld2","page":"Utilities","title":"CriticalTransitions.make_jld2","text":"make_jld2(\n    text::String\n) -> Union{JLD2.JLDFile{IOStream}, JLD2.JLDFile{JLD2.MmapIO}}\nmake_jld2(\n    text::String,\n    relpath::String\n) -> Union{JLD2.JLDFile{IOStream}, JLD2.JLDFile{JLD2.MmapIO}}\n\n\nCreates/opens a .jld2 file with filename of the format \"ddmmyy_text.jld2\". Relative file path specified by relpath (must end with /).\n\nSee make_h5 for generating a .h5 file.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#CriticalTransitions.make_h5","page":"Utilities","title":"CriticalTransitions.make_h5","text":"make_h5(text::String) -> HDF5.File\nmake_h5(text::String, relpath::String) -> HDF5.File\n\n\nCreates/opens a .h5 file with filename of the format \"ddmmyy_text.h5\". Relative file path specified by relpath (must end with /).\n\nSee make_jld2 for generating a .jld2 file.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#length(sys.u)-dimensional-box","page":"Utilities","title":"length(sys.u)-dimensional box","text":"","category":"section"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"intervals_to_box(bmin::Vector, bmax::Vector)","category":"page"},{"location":"man/utils/#CriticalTransitions.intervals_to_box-Tuple{Vector, Vector}","page":"Utilities","title":"CriticalTransitions.intervals_to_box","text":"intervals_to_box(bmin::Vector, bmax::Vector) -> Any\n\n\nGenerates a box from specifying the interval limits in each dimension.\n\nbmin (Vector): lower limit of the box in each dimension\nbmax (Vector): upper limit\n\nExample\n\nintervals_to_box([-2,-1,0], [2,1,1]) returns a 3D box of dimensions [-2,2] × [-1,1] × [0,1].\n\n\n\n\n\n","category":"method"},{"location":"man/largedeviations/#Large-deviation-theory","page":"Large deviation theory","title":"Large deviation theory","text":"","category":"section"},{"location":"man/largedeviations/#Action-functionals","page":"Large deviation theory","title":"Action functionals","text":"","category":"section"},{"location":"man/largedeviations/#Freidlin-Wentzell-action","page":"Large deviation theory","title":"Freidlin-Wentzell action","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"fw_action","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.fw_action","page":"Large deviation theory","title":"CriticalTransitions.fw_action","text":"fw_action(sys::CoupledSDEs, path, time) -> Any\n\n\nCalculates the Freidlin-Wentzell action of a given path with time points time in a drift field specified by the deterministic dynamics of sys.\n\nThe path must be a (D x N) matrix, where D is the dimensionality of the system sys and N is the number of path points. The time array must have length N.\n\nReturns a single number, which is the value of the action functional\n\nS_Tphi_t = frac12 int_0^T  dot phi_t - b(phi_t) ^2_Q dt\n\nwhere phi_t denotes the path in state space, b the drift field, and T the total time of the path. The subscript Q refers to the generalized norm a_Q^2 = langle a Q^-1 b rangle (see anorm). HereQis the noise covariance matrixsys.Σ`.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Geometric-Freidlin-Wentzell-action","page":"Large deviation theory","title":"Geometric Freidlin-Wentzell action","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"geometric_action","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.geometric_action","page":"Large deviation theory","title":"CriticalTransitions.geometric_action","text":"geometric_action(sys::CoupledSDEs, path) -> Any\ngeometric_action(sys::CoupledSDEs, path, arclength) -> Any\n\n\nCalculates the geometric action of a given path with specified arclength for the drift field sys.f.\n\nFor a given path varphi, the geometric action bar S corresponds to the minimum of the Freidlin-Wentzell action S_T(phi) over all travel times T0, where phi denotes the path's parameterization in physical time (see fw_action). It is given by the integral\n\nbar Svarphi = int_0^L left( varphi_Q  b(varphi)_Q - langle varphi      b(varphi) rangle_Q right)  ds\n\nwhere s is the arclength coordinate, L the arclength, b the drift field, and the subscript Q refers to the generalized dot product langle a b rangle_Q = a^top cdot Q^-1 b (see anorm). HereQis the noise covariance matrixsys.Σ`.\n\nReturns the value of the geometric action bar S.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Onsager-Machlup-action","page":"Large deviation theory","title":"Onsager-Machlup action","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"om_action","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.om_action","page":"Large deviation theory","title":"CriticalTransitions.om_action","text":"om_action(sys::CoupledSDEs, path, time) -> Any\n\n\nCalculates the Onsager-Machlup action of a given path with time points time for the drift field sys.f at given sys.noise_strength.\n\nThe path must be a (D x N) matrix, where D is the dimensionality of the system sys and N is the number of path points. The time array must have length N.\n\nReturns a single number, which is the value of the action functional\n\nI^sigma_Tphi_t = frac12 int_0^T left(  dot phi_t - b(phi_t) ^2_Q + fracsigma^22 div(b) right)  dt\n\nwhere phi_t denotes the path in state space, b the drift field, T the total time of the path, and sigma the noise strength. The subscript Q refers to the generalized norm a_Q^2 = langle a Q^-1 b rangle (see anorm). HereQ` is the noise covariance matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"For convenience, a general action function is available where the type of functional is set as an argument:","category":"page"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"action","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.action","page":"Large deviation theory","title":"CriticalTransitions.action","text":"action(\n    sys::CoupledSDEs,\n    path::Matrix,\n    time,\n    functional;\n    kwargs...\n) -> Any\n\n\nComputes the action functional specified by functional for a given CoupledSDEs sys and path parameterized by time.\n\nfunctional = \"FW\": Returns the Freidlin-Wentzell action (fw_action)\nfunctional = \"OM\": Returns the Onsager-Machlup action (om_action)\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Minimum-action-paths","page":"Large deviation theory","title":"Minimum action paths","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"We provide the following two methods to calculate instantons, or minimum action paths, between two states of a CoupledSDEs.","category":"page"},{"location":"man/largedeviations/#Minimum-action-method-(MAM)","page":"Large deviation theory","title":"Minimum action method (MAM)","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"Minimization of the Freidlin-Wentzell action using the L-BFGS algorithm of Optim.jl.","category":"page"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"min_action_method","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.min_action_method","page":"Large deviation theory","title":"CriticalTransitions.min_action_method","text":"min_action_method(\n    sys::CoupledSDEs,\n    x_i,\n    x_f,\n    N::Int64,\n    T::Real;\n    functional,\n    maxiter,\n    blocks,\n    method,\n    save_info,\n    showprogress,\n    verbose,\n    kwargs...\n) -> Any\n\n\nRuns the Minimum Action Method (MAM) to find the minimum action path (instanton) between an initial state x_i and final state x_f.\n\nThis algorithm uses the minimizers of the Optim package to minimize the Freidlin-Wentzell action functional (see fw_action) for the given CoupledSDEs sys. The path is initialized as a straight line between x_i and x_f, parameterized in time via N equidistant points and total time T. Thus, the time step between discretized path points is Delta t = TN. To set an initial path different from a straight line, see the multiple dispatch method\n\nmin_action_method(sys::CoupledSDEs, init::Matrix, T::Real; kwargs...).\n\nThe minimization can be performed in blocks to save intermediate results.\n\nKeyword arguments\n\nfunctional = \"FW\": type of action functional to minimize. Defaults to fw_action, alternative: om_action.\nmaxiter = 100: maximum number of iterations before the algorithm stops.\nblocks = 1: number of iterative optimization blocks\nmethod = LBFGS(): minimization algorithm (see Optim)\nsave_info = true: whether to save Optim information\nverbose = true: whether to print Optim information during the run\nshowprogress = false: whether to print a progress bar\nkwargs...: any keyword arguments from Optim.Options (see docs)\n\nOutput\n\nIf save_info, returns Optim.OptimizationResults. Else, returns only the optimizer (path). If blocks > 1, a vector of results/optimizers is returned.\n\n\n\n\n\nmin_action_method(\n    sys::CoupledSDEs,\n    init::Matrix,\n    T::Real;\n    functional,\n    maxiter,\n    blocks,\n    method,\n    save_info,\n    showprogress,\n    verbose,\n    kwargs...\n) -> Any\n\n\nRuns the Minimum Action Method (MAM) to find the minimum action path (instanton) from an initial condition init, given a system sys and total path time T.\n\nThe initial path init must be a matrix of size (D, N), where D is the dimension of the system and N is the number of path points. The physical time of the path is specified by T, such that the time step between consecutive path points is Delta t = TN.\n\nFor more information see the main method, min_action_method(sys::CoupledSDEs, x_i, x_f, N::Int, T::Real; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Geometric-minimum-action-method-(gMAM)","page":"Large deviation theory","title":"Geometric minimum action method (gMAM)","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"Minimization of the geometric action following Heymann and Vanden-Eijnden, PRL (2008).","category":"page"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"geometric_min_action_method","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.geometric_min_action_method","page":"Large deviation theory","title":"CriticalTransitions.geometric_min_action_method","text":"geometric_min_action_method(\n    sys::CoupledSDEs,\n    x_i,\n    x_f;\n    ...\n) -> Tuple{Vector{T} where T<:(Matrix), Vector}\ngeometric_min_action_method(\n    sys::CoupledSDEs,\n    x_i,\n    x_f,\n    arclength;\n    N,\n    maxiter,\n    converge,\n    method,\n    tau,\n    verbose,\n    showprogress\n) -> Tuple{Vector{T} where T<:(Matrix), Vector}\n\n\nComputes the minimizer of the Freidlin-Wentzell action using the geometric minimum action method (gMAM). Beta version, to be further documented.\n\nTo set an initial path different from a straight line, see the multiple dispatch method\n\ngeometric_min_action_method(sys::CoupledSDEs, init::Matrix, arclength::Float64; kwargs...).\n\nKeyword arguments\n\nN = 100: number of discretized path points\nmaxiter = 100: maximum number of iterations before the algorithm stops\nconverge = 1e-5: convergence threshold for absolute change in action\nmethod = LBFGS(): choice of optimization algorithm (see below)\ntau = 0.1: step size (used only if method = \"HeymannVandenEijnden\")\n\nOptimization algorithms\n\nThe method keyword argument takes solver methods of the Optim.jl package; alternatively, the option solver = \"HeymannVandenEijnden\" uses the original gMAM algorithm[1].\n\n[1]: Heymann and Vanden-Eijnden, PRL (2008)\n\n\n\n\n\ngeometric_min_action_method(\n    sys::CoupledSDEs,\n    init::Matrix;\n    ...\n) -> Tuple{Vector{T} where T<:(Matrix), Vector{Float64}}\ngeometric_min_action_method(\n    sys::CoupledSDEs,\n    init::Matrix,\n    arclength;\n    maxiter,\n    converge,\n    method,\n    tau,\n    verbose,\n    showprogress\n) -> Tuple{Vector{T} where T<:(Matrix), Vector}\n\n\nRuns the geometric Minimum Action Method (gMAM) to find the minimum action path (instanton) from an initial condition init, given a system sys and total arc length arclength.\n\nThe initial path init must be a matrix of size (D, N), where D is the dimension of the system and N is the number of path points.\n\nFor more information see the main method, geometric_min_action_method(sys::CoupledSDEs, x_i, x_f, arclength::Float64; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#Analyzing-a-system's-stability-properties","page":"Stability analysis","title":"Analyzing a system's stability properties","text":"","category":"section"},{"location":"man/systemanalysis/","page":"Stability analysis","title":"Stability analysis","text":"To use the following functionalities, you need to load ChoasTools.jl and Attractors.jl.","category":"page"},{"location":"man/systemanalysis/#Fixed-points","page":"Stability analysis","title":"Fixed points","text":"","category":"section"},{"location":"man/systemanalysis/","page":"Stability analysis","title":"Stability analysis","text":"equilib(sys::CoupledSDEs, state; kwargs...)\nfixedpoints","category":"page"},{"location":"man/systemanalysis/#CriticalTransitions.equilib-Tuple{CoupledSDEs, Any}","page":"Stability analysis","title":"CriticalTransitions.equilib","text":"equilib(sys::CoupledSDEs, state; kwargs...)\n\nReturns the equilibrium solution of the system sys for given initial condition state.\n\nWarning: This algorithm simply evolves the deterministic system forward in time until a steady-state condition is satisfied. Thus, the algorithm may output a false solution if it gets stuck in a quasi-equilibrium, or slowly evolving state. For more robust results, use fixedpoints.\n\nKeyword arguments:\n\nabstol = 1e-5: steady-state condition. Simulation ends when the rate of change (Euclidean distance in state space) of the state falls below abstol.\ntmax = 1e5: maximum simulation time before the algorithm stops even if the steady-state condition is not reached.\ndt = 0.01: time step of the ODE solver.\nsolver = Euler(): ODE solver used for evolving the state.\n\n\n\n\n\n","category":"method"},{"location":"man/systemanalysis/#ChaosTools.fixedpoints","page":"Stability analysis","title":"ChaosTools.fixedpoints","text":"fixedpoints(\n    sys::CoupledSDEs,\n    bmin::Vector,\n    bmax::Vector\n) -> Tuple{StateSpaceSet, Vector{Vector{ComplexF64}}, Vector{Bool}}\n\n\nReturns fixed points, their eigenvalues and stability of the system sys within the state space volume defined by bmin and bmax.\n\nThis is a wrapper around the fixedpoints function of DynamicalSystems.jl.\n\nInput\n\nbmin (Vector): lower limits of the state space box to be considered, as a vector of coordinates\nbmax (Vector): upper limits\nalternatively box (IntervalBox) can replace bmin and bmax\n\nExample: fixedpoints(sys, [-2,-1,0], [2,1,1]) finds the fixed points of the 3D system sys in a cube defined by the intervals [-2,2] × [-1,1] × [0,1].\n\nOutput\n\n[fp, eigs, stable]\n\nfp: Dataset of fixed points\neigs: vector of Jacobian eigenvalues of each fixed point\nstable: vector of booleans indicating the stability of each fixed point (true=stable, false=unstable)\n\nAdditional methods\n\nfixedpoints(sys::CoupedSDEs, box)\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#Basins-of-attraction","page":"Stability analysis","title":"Basins of attraction","text":"","category":"section"},{"location":"man/systemanalysis/","page":"Stability analysis","title":"Stability analysis","text":"basins\nbasinboundary\nbasboundary","category":"page"},{"location":"man/systemanalysis/#CriticalTransitions.basins","page":"Stability analysis","title":"CriticalTransitions.basins","text":"basins(\n    sys::CoupledSDEs,\n    A,\n    B,\n    C,\n    H;\n    bstep,\n    pstep,\n    ϵ_mapper,\n    showprogress,\n    kwargs...\n) -> Any\n\n\nComputes the basins of attraction of CoupledSDEs sys on a plane spanned by the distinct points A, B, C and limited by the box H. Uses the AttractorsViaProximity function from DynamicalSystems.jl to compute the basins of attraction.\n\nA, B, C are elements of mathbbR^d (where d is the dimension of the  sys) and H is a hyperrectangle in mathbbR^d.\n\nThe plane is given by P_UV = A+u(B-A)+v(C-A)inmathbbR^d u in U vin V for some closed and bounded real intervals U and V which are selected such that both\n\nP_UV subseteq H, and\nUtimes VsubseteqmathbbR^2 has maximal area,\n\ni.e. P_UV is the \"largest\" possible plane contained within H. This plane is determined behind the scenes.\n\nThis function returns a four-dimensional vector. The first two entries are discretised versions of the interval U and V (as defined above, of lengths ell_Uell_V respectively); the third entry is a dictionary of the attractors (stable equilibria) of the system within H, and the final entry is an ell_Vtimesell_U matrix of integers that group the initial conditions (written in terms of A+u(B-A)+v(C-A) where uin U and vin V) by which attractor they will in time converge to.\n\nKeyword arguments\n\nbstep = [0.01, 0.01]: a vector of length two whose elements respectively specify the length of the incremental steps taken across each dimension in the discretisation of your plane\npstep = [0.1, 0.1]: a vector of length two whose elements give the increments of the mesh that the maximisation process of finding a plane from a box is taken over (for more information see the source code of the function plane in the src/systemanalysis/planeofbox.jl file)\nϵ_mapper = 0.01: ϵ parameter of AttractorsViaProximity\nkwargs...: keyword arguments passed to the AttractorsViaProximity function (namely, Ttr, Δt, horizon_limit, mx_chk_lost)\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#CriticalTransitions.basinboundary","page":"Stability analysis","title":"CriticalTransitions.basinboundary","text":"basinboundary(X, Y, h; coords, A, B, C) -> Any\n\n\nComputes the basin boundary for given output X, Y, h of the basins function.\n\nTo be further documented.\n\n\n\n\n\nbasinboundary(boa) -> Any\n\n\nComputes the basin boundary for given output boa of the basins function.\n\nTo be further documented.\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#CriticalTransitions.basboundary","page":"Stability analysis","title":"CriticalTransitions.basboundary","text":"basboundary(\n    sys::CoupledSDEs,\n    xrange::Vector,\n    yrange::Vector,\n    xspacing::Float64,\n    attractors::Vector;\n    eps1,\n    ϵ_mapper,\n    dt_mapper,\n    solver,\n    maxit\n) -> Tuple{Any, Any}\n\n\nThis function computes the basin boundary.\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#Edge-tracking","page":"Stability analysis","title":"Edge tracking","text":"","category":"section"},{"location":"man/systemanalysis/","page":"Stability analysis","title":"Stability analysis","text":"The edge tracking algorithm is a simple numerical method to find the edge state or (possibly chaotic) saddle on the boundary between two basins of attraction. It is first introduced by Battelino et al. (1988) and further described by Skufca et al. (2006).","category":"page"},{"location":"man/systemanalysis/","page":"Stability analysis","title":"Stability analysis","text":"edgetracking\nbisect_to_edge","category":"page"},{"location":"man/systemanalysis/#Attractors.edgetracking","page":"Stability analysis","title":"Attractors.edgetracking","text":"edgetracking(\n    sys::CoupledSDEs,\n    u1,\n    u2,\n    attractors::Vector;\n    eps1,\n    eps2,\n    converge,\n    dt,\n    tmax,\n    ϵ_mapper,\n    dt_mapper,\n    solver,\n    maxit,\n    verbose,\n    output_all,\n    kwargs...\n)\n\n\nRuns the edge tracking algorithm.\n\nInput\n\nsys: dynamical system of type CoupledSDEs\nu1, u2: initial states; must belong to different basins of attraction\nattractors: vector of state vectors corresponding to the stable fixed points of sys\n\nKeyword arguments\n\neps1 = 1e-9: tolerance for bisection distance\neps2 = 1e-8: tolerance for divergence of trajectories before re-bisecting\nconverge = 1e-5: convergence criterion for M state accuracy (Euclidean distance)\ndt = 0.01: integration time step\ntmax = Inf: maximum integration time of parallel trajectories until re-bisection\nϵ_mapper = 0.1: distance threshold for AttractorMapper\ndt_mapper = 0.01: time step for AttractorMapper (keyword argument Δt)\nsolver = Vern9(): ODE solver from DifferentialEquations.jl\nmaxit = 100: maximum number of iterations before algorithm stops\nverbose = true: print status updates during run\noutput_all = false: if false, returns M state, else returns all points of the track\nkwargs...: additional keyword arguments of AttractorsViaProximity may be passed\n\nReturns\n\nIf output_all, a single state vector corresponding to the found edge state is returned. Else, a triple edge, track1, track2 is returned, where track1 and track2 are the tracks along the edge within the basin of attraction of u1 and u2, respectively; edge is the track along the edge derived from (track1 + track2)/2.\n\nwarning: Warning\nMay behave erroneously when run with solver = SimpleATsit5(), which is the default solver for AttractorsViaProximity. The recommended solver is Vern9().\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#Attractors.bisect_to_edge","page":"Stability analysis","title":"Attractors.bisect_to_edge","text":"bisect_to_edge(\n    sys::CoupledSDEs,\n    u1,\n    u2,\n    attractors::Vector;\n    eps1,\n    ϵ_mapper,\n    dt_mapper,\n    solver,\n    maxit,\n    absto,\n    relto,\n    kwargs...\n)\n\n\nBisects to the basin boundary between two initial points u1 and u2. Returns the two final points, one on each side of the basin boundary, that are less than eps1 apart from each other.\n\nKeyword arguments\n\neps1=1e-9: tolerance for final distance between the two states\nϵ_mapper=0.1: ϵ parameter for AttractorMapper\ndt_mapper = 0.01: time step for AttractorMapper (keyword argument Δt)\nsolver=Vern9(): solver for AttractorMapper\nkwargs...: additional kwargs that can be passed to AttractorMapper\n\n\n\n\n\n","category":"function"},{"location":"man/sampling/#Sampling-transitions","page":"Sampling transitions","title":"Sampling transitions","text":"","category":"section"},{"location":"man/sampling/#...-by-direct-simulation","page":"Sampling transitions","title":"... by direct simulation","text":"","category":"section"},{"location":"man/sampling/","page":"Sampling transitions","title":"Sampling transitions","text":"These functions generate noise-induced transitions between an initial and final state.","category":"page"},{"location":"man/sampling/","page":"Sampling transitions","title":"Sampling transitions","text":"transition(sys::CoupledSDEs, x_i, x_f; kwargs...)\ntransitions(sys::CoupledSDEs, x_i, x_f, N=1; kwargs...)","category":"page"},{"location":"man/sampling/#CriticalTransitions.transition-Tuple{CoupledSDEs, Any, Any}","page":"Sampling transitions","title":"CriticalTransitions.transition","text":"transition(\n    sys::CoupledSDEs,\n    x_i,\n    x_f;\n    rad_i,\n    rad_f,\n    tmax,\n    cut_start,\n    rad_dims,\n    kwargs...\n) -> Tuple{Any, Any, Any}\n\n\nGenerates a sample transition from point x_i to point x_f.\n\nThis function simulates sys in time, starting from initial condition x_i, until entering a length(sys.u)-dimensional ball of radius rad_f around x_f.\n\nKeyword arguments\n\nrad_i=0.1: radius of ball around x_i\nrad_f=0.1: radius of ball around x_f\ncut_start=true: if false, returns the whole trajectory up to the transition\ndt=0.01: time step of integration\ntmax=1e3: maximum time when the simulation stops even x_f has not been reached\nrad_dims=1:length(sys.u): the directions in phase space to consider when calculating the radii rad_i and rad_f. Defaults to all directions. To consider only a subspace of state space, insert a vector of indices of the dimensions to be included.\nsolver=EM(): numerical solver. Defaults to Euler-Mayurama.\nprogress: shows a progress bar with respect to tmax\n\nOutput\n\n[path, times, success]\n\npath (Matrix): transition path (size [dim × N], where N is the number of time points)\ntimes (Vector): time values (since start of simulation) of the path points (size N)\nsuccess (bool): if true, a transition occured (i.e. the ball around x_f has been reached), else false\nkwargs...: keyword arguments passed to simulate\n\nSee also transitions, simulate.\n\n\n\n\n\n","category":"method"},{"location":"man/sampling/#CriticalTransitions.transitions","page":"Sampling transitions","title":"CriticalTransitions.transitions","text":"transitions(\n    sys::CoupledSDEs,\n    x_i,\n    x_f;\n    ...\n) -> CriticalTransitions.TransitionPathEnsemble\ntransitions(\n    sys::CoupledSDEs,\n    x_i,\n    x_f,\n    N;\n    rad_i,\n    rad_f,\n    tmax,\n    Nmax,\n    cut_start,\n    rad_dims,\n    savefile,\n    showprogress,\n    kwargs...\n) -> CriticalTransitions.TransitionPathEnsemble\n\n\nGenerates an ensemble of N transition samples of sys from point x_i to point x_f.\n\nThis function repeatedly calls the transition function to efficiently generate an ensemble of transitions, which are saved to a file or returned as an array of paths. Multi-threading is enabled.\n\nKeyword arguments\n\nrad_i=0.1: radius of ball around x_i\nrad_f=0.1: radius of ball around x_f\ncut_start=true: if false, returns the whole trajectory up to the transition\nNmax: number of attempts before the algorithm stops even if less than N transitions occurred.\ndt=0.01: time step of integration\ntmax=1e3: maximum time when the simulation stops even x_f has not been reached\nrad_dims=1:length(sys.u): the directions in phase space to consider when calculating the radii rad_i and rad_f. Defaults to all directions. To consider only a subspace of state space, insert a vector of indices of the dimensions to be included.\nprogress: shows a progress bar with respect to Nmax\nsavefile: if nothing, no data is saved to a file. To save to a file, see below.\n\nSee also transition.\n\nSaving data to file\n\nThe savefile keyword argument allows saving the data to a .jld2 or .h5 file. To do so:\n\nCreate and open a file by typing file = jld2open(\"filename.jld2\", \"a+\") or file = h5open(\"filename.h5\", \"cw\"). This requires JLD2.jl/HDF5.jl; the convenience functions make_jld2, make_h5 provide this out of the box.\nPass the label file to the savefile argument of transitions.\nDon't forget to close(file) at the end.\n\nOutput\n\n[samples, times, idx, N_fail]\n\nsamples (Array of Matrices): sample paths. Each path i has size (dim × Ni), where Ni is the number of path points\ntimes (Array of Vectors): time values (since simulation start) of path points for each path\nidx (Array): list of sample indices i that produced a transition\nN_fail (Int): number of samples that failed to produce a transition\n\nAn example script using transitions is available here.\n\n\n\n\n\n","category":"function"},{"location":"man/sampling/#...-in-pathspace","page":"Sampling transitions","title":"... in pathspace","text":"","category":"section"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#Installation","page":"Quickstart","title":"Installation","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"As this module is not published yet, there are two ways to access it:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Option 1 (recommended): Install from GitHub\nEnter the Julia package manager by typing ] in the REPL: julia> ]\ntype add https://github.com/juliadynamics/CriticalTransitions.jl.git\nOption 2: Load module locally\nClone the repo: git clone https://github.com/juliadynamics/CriticalTransitions.jl.git\nIn Julia, include the module file: include(\"PATH/src/CriticalTransitions.jl\"), where PATH is the relative path to the repo you just cloned\nLoad the module: using .CriticalTransitions","category":"page"},{"location":"quickstart/#Basic-usage","page":"Quickstart","title":"Basic usage","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The general workflow of CriticalTransitions essentially follows two steps:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Define your system (see Define a CoupledSDE)\nInvestigate the system by calling methods (see Methods)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"info: Extension to RateSystem and TippingSystem\nWe are currently working on extending the types of dynamical systems that can be studied with CriticalTransitions.jl. Particularly, we are planning to introduce the overarching structure TippingSystem, which has two subtypes: CoupledSDEs (as it already exists) and RateSystem, a new dynamical system type in which the system parameters may evolve in time.","category":"page"},{"location":"quickstart/#Methods","page":"Quickstart","title":"Methods","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Currently the following functions are implemented to analyze a CoupledSDEs and  corresponding sample transition paths.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Pages = [\"man/systemanalysis.md\", \"man/simulation.md\", \"man/sampling.md\", \"man/largedeviations.md\"]","category":"page"},{"location":"#CriticalTransitions.jl","page":"Home","title":"CriticalTransitions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for the numerical investigation of noise- and rate-induced transitions in dynamical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Building on DynamicalSystems.jl and DifferentialEquations.jl, this package aims to provide a toolbox for dynamical systems under time-dependent forcing, with a focus on tipping phenomena and metastability.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: CT.jl infographic)","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Current features\nStability analysis: Fixed points, linear stability, basins of attraction, edge tracking\nStochastic simulation: Gaussian noise, uncorrelated and correlated, additive and multiplicative\nTransition path sampling: Ensemble sampling by direct simulation and Pathspace Langevin MCMC\nLarge deviation theory: Action functionals and minimization algorithms (MAM, gMAM)","category":"page"},{"location":"","page":"Home","title":"Home","text":"ukw: Planned features\nRare event simulation: importance sampling, AMS\nQuasipotentials: Ordered line integral method (OLIM)\nRate-induced tipping tools\n...?","category":"page"},{"location":"","page":"Home","title":"Home","text":"Developers: Reyk Börner, Ryan Deeley, Raphael Römer and Orjan Ameye","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thanks to Jeroen Wouters, Calvin Nesbitt, Tobias Grafke, George Datseris and Oliver Mehling","category":"page"},{"location":"","page":"Home","title":"Home","text":"This work is part of the CriticalEarth project.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To give you an idea of how our package works, this tutorial provides some example code with explanations.","category":"page"},{"location":"tutorial/#Example:-FitzHugh-Nagumo-model","page":"Tutorial","title":"Example: FitzHugh-Nagumo model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Consider the FitzHugh-Nagumo model,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginaligned\nfracdudt = frac1epsilon left( -alpha u^3 + gamma u - kappa v + I right) \nfracdvdt = -beta v + u  \nendaligned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where epsilon is the parameter of time scale separation between the state variables u and v. The parameters alpha 0, beta 1, gamma0, and kappa0 are real constants, and I denotes a driving term.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's investigate this system under stochastic forcing.","category":"page"},{"location":"tutorial/#System-definition","page":"Tutorial","title":"System definition","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, we need to translate the system equations above into Julia code.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This works by defining a function f(u,p,t) which takes as input a vector u of state variables (u,v), a vector p of parameters, and time t. The function must return an array of flow increments (textdu, textdv). For performance reasons, it is advisable to return a StaticArray SA[du, dv] rather than just a Vector [du, dv]. This is why we need the StaticArrays package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CriticalTransitions\nimport Random # hide\nRandom.seed!(1) # hide\n\nfunction fitzhugh_nagumo(u,p,t)\n    u, v = u\n    ϵ, β, α, γ, κ, I = p\n\n    du = (-α*u^3 + γ*u - κ*v + I)/ϵ\n    dv = -β*v + u\n\n    SA[du, dv]\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the system parameters ϵ, β, α, γ, κ, I = p[1] are unpacked as the first component of p. This is necessary because in CriticalTransitions.jl one can also define a separate set of parameters for the stochastic component of the system, which would then make up the second component p[2] ( see Define a CoupledSDE).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tip: In-place vs. out-of-place\nThe function fitzhugh_nagumo(u,p,t) is defined out-of-place. It is also possible to define the system in-place as fitzhugh_nagumo!(du,u,p,t). For more info, see here.","category":"page"},{"location":"tutorial/#CoupledSDE","page":"Tutorial","title":"CoupledSDE","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we turn the fitzhugh_nagumo system into a stochastic dynamical system. Suppose we would like to force both state variables u and v with additive, uncorrelated Gaussian noise of intensity sigma. This is the default case. We simply write","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p = [1., 3., 1., 1., 1., 0.] # Parameters (ϵ, β, α, γ, κ, I)\nσ = 0.2 # noise strength\n\n# CoupledSDE\nsys = CoupledSDEs(fitzhugh_nagumo, idfunc, zeros(2), p, σ)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we have chosen zeros(2) as the initial state of the system. The length of this vector must correspond to the system's dimensionality, but for now the state is just a placeholder that aligns our syntax with that of DifferentialEquations.jl and DynamicalSystems.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Multiplicative and/or correlated noise\nOf course, it is also possible to define more complicated noise processes than simple additive white noise. This is done by specifying a custom noise function and covariance matrix in the CoupledSDEs definition. For more info, see Define a CoupledSDE.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"That's it! Now we can throw the toolbox of CriticalTransitions at our stochastic FitzHugh-Nagumo system sys.","category":"page"},{"location":"tutorial/#Find-stable-equilibria","page":"Tutorial","title":"Find stable equilibria","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the parameters chosen above, the FitzHugh-Nagumo system is bistable. Let's compute the fixed points using the fixedpoints function from ChaosTools.jl. As this function is from the DynamicalSystems ecosystem, it takes a system of type CoupledODEs as input. We can simply convert the CoupledSDEs sys via the CoupledODEs function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using ChaosTools\n# Calculate fixed points\nbox = intervals_to_box([-2,-2], [2,2])\neqs, eigs, stab = fixedpoints(sys, box)\n\n# Store the two stable fixed points\nfp1, fp2 = eqs[stab]","category":"page"},{"location":"tutorial/#Stochastic-simulation","page":"Tutorial","title":"Stochastic simulation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Using the simulate function, we now run a simulation of our system starting out from the fixed point fp1:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sim = simulate(sys, 1e3, fp1, saveat=0.1)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the keyword arguments, we have specified the time step dt and total duration tmax of the numerical time integration.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The simulated trajectory is stored in sim as a matrix with 2 rows corresponding to the state variables u, v, and 10,000 columns corresponding to the time steps.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's plot the result. Did the trajectory transition to the other attractor?","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplt = plot(sim[1, :], sim[2, :], xlabel=\"u\", ylabel=\"v\", legend=false)\nscatter!([fp1[1], fp2[1]], [fp1[2], fp2[2]], color=:red, markersize=4)\nxlims!(-1.2, 1.2)\nylims!(-0.6, 0.6)\nplt","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Hopefully, this helped you to get started. For more info, check out the Manual section of these docs.","category":"page"},{"location":"man/CoupledSDEs/#Define-a-CoupledSDE","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"A CoupledSDEs defines a stochastic dynamical system of the form","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"textdvec x = f(vec x(t)  p)  textdt + g(vec x(t)   p) textdmathcalW  ","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"where textdmathcalW=Gamma cdot textdmathcalN, vec x in mathbbR^textdim and mathcal N denotes a stochastic process. The (positive definite) noise covariance matrix is Sigma = Gamma Gamma^top in mathbb R^Ntimes N.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"The function f is the deterministic part of the system and is assumed to be of similar form as is accepted in DynamicalSystems.jl, i.e., f(u, p, t) for out-of-place (oop) and f(du, u, p, t) for in-place (iip).","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"The function g represent the stochastics dynamics of the system and should be the of the same type (iip or oop) as f.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"The keyword noise defines the system noise process. In combination with g one can define different type of stochastic systems. Examples of different type of stochastics systems can be found on the StochasticDiffEq.jl tutorial page. A quick overview of the different types of stochastic systems can be found here.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"info: Info\nNote that nonlinear mixings of the Noise Process mathcalW are not Stochasitic Differential Equations but are a different class of differential equations of random ordinary differential equations (RODEs) which have a separate set of solvers. See this example of DifferentialEquations.jl.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"CoupledSDEs","category":"page"},{"location":"man/CoupledSDEs/#CriticalTransitions.CoupledSDEs","page":"Define a CoupledSDE","title":"CriticalTransitions.CoupledSDEs","text":"CoupledSDEs <: ContinuousTimeDynamicalSystem\nCoupledSDEs(f, g, u0 [, p, σ]; kwargs...)\n\nA stochastic continuous time dynamical system defined by a set of coupled ordinary differential equations as follows:\n\ndvecu = vecf(vecu p t) dt + vecg(vecu p t) dW_t\n\nOptionally provide the overall noise strength σ, the parameter container p and initial time as keyword t0. If σ is provided, the diffusion function g is multiplied by σ.\n\nFor construction instructions regarding f, u0 see the DynamicalSystems.jl tutorial.\n\nThe stochastic part of the differential equation is defined by the function g and the keyword arguments noise_rate_prototype and noise. noise indicates the noise process applied during generation and defaults to Gaussian white noise. For details on defining various noise processes, refer to the noise process documentation page. noise_rate_prototype indicates the prototype type instance for the noise rates, i.e., the output of g. It can be any type which overloads A_mul_B! with itself being the middle argument. Commonly, this is a matrix or sparse matrix. If this is not given, it defaults to nothing, which means the problem should be interpreted as having diagonal noise.\n\nDifferentialEquations.jl interfacing\n\nThe ODEs are evolved via the solvers of DifferentialEquations.jl. When initializing a CoupledODEs, you can specify the solver that will integrate f in time, along with any other integration options, using the diffeq keyword. For example you could use diffeq = (abstol = 1e-9, reltol = 1e-9). If you want to specify a solver, do so by using the keyword alg, e.g.: diffeq = (alg = Tsit5(), reltol = 1e-6). This requires you to have been first using OrdinaryDiffEq to access the solvers. The default diffeq is:\n\n(alg = SOSRA(), abstol = 1.0e-6, reltol = 1.0e-6)\n\ndiffeq keywords can also include callback for event handling .\n\nDev note: CoupledSDEs is a light wrapper of  StochasticDiffEq.SDEIntegrator from DifferentialEquations.jl. The integrator is available as the field integ, and the SDEProblem is integ.sol.prob. The convenience syntax SDEProblem(ds::CoupledSDEs, tspan = (t0, Inf)) is available to extract the problem.\n\n\n\n\n\n","category":"type"},{"location":"man/CoupledSDEs/#Type-of-stochastic-system","page":"Define a CoupledSDE","title":"Type of stochastic system","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"Let us make some examples of the different types of stochastic systems that can be defined.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"using CriticalTransitions, Plots\nimport Random # hide\nRandom.seed!(10) # hide\nf!(du, u, p, t) = du .= 1.01u\nσ = 0.25","category":"page"},{"location":"man/CoupledSDEs/#Additive-noise","page":"Define a CoupledSDE","title":"Additive noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"When g is independent of the state variables u, the noise is called additive.","category":"page"},{"location":"man/CoupledSDEs/#Diagonal-noise","page":"Define a CoupledSDE","title":"Diagonal noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"A system of diagional noise is the most common type of noise. It is defined by a vector of random numbers dW whose size matches the output of g where the noise is applied element-wise, i.e. g.*dW.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"t0 = 0.0; W0 = zeros(2);\nW = WienerProcess(t0, W0, 0.0)\nsde = CoupledSDEs(f!, idfunc!, zeros(2), nothing, σ; noise=W)","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"or equivalently","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"sde = CoupledSDEs(f!, idfunc!, zeros(2), nothing, σ)","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"where we used the helper function","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"idfunc!\nidfunc","category":"page"},{"location":"man/CoupledSDEs/#CriticalTransitions.idfunc!","page":"Define a CoupledSDE","title":"CriticalTransitions.idfunc!","text":"idfunc!(du, u, p, t)\n\n\nIdentity function for a diffusion function g of CoupledSDEs (in-place). Equivalent to idfunc!(du, u, p, t) = (du .= ones(length(u)); return nothing)\n\n\n\n\n\n","category":"function"},{"location":"man/CoupledSDEs/#CriticalTransitions.idfunc","page":"Define a CoupledSDE","title":"CriticalTransitions.idfunc","text":"idfunc(u, p, t) -> Any\n\n\nIdentity function for a diffusion function g of CoupledSDEs (out-of-place). Equivalent to (u, p, t) -> ones(length(u)),\n\n\n\n\n\n","category":"function"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"The vector dW is by default zero mean white gaussian noise mathcalN(0 textdt) where the variance is the timestep textdt unit variance (Wiener Process).","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"sol = simulate(sde, 1.0, dt=0.01, alg=SOSRA())\nplot(sol)","category":"page"},{"location":"man/CoupledSDEs/#Scalar-noise","page":"Define a CoupledSDE","title":"Scalar noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"Scalar noise is where a single random variable is applied to all dependent variables. To do this, one has to give the noise process to the noise keyword of the CoupledSDEs constructor. A common example is the Wiener process starting at W0=0.0 at time t0=0.0.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"t0 = 0.0; W0 = 0.0;\nnoise = WienerProcess(t0, W0, 0.0)\nsde = CoupledSDEs(f!, idfunc!, rand(2)./10, nothing, σ; noise=noise)\nsol = simulate(sde, 1.0, dt=0.01, alg=SOSRA())\nplot(sol)","category":"page"},{"location":"man/CoupledSDEs/#Multiplicative-noise","page":"Define a CoupledSDE","title":"Multiplicative noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"Multiplicative Noise is when g_i(t u)=a_i u","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"function g(du, u, p, t)\n    du[1] = σ*u[1]\n    du[2] = σ*u[2]\n    return nothing\nend\nsde = CoupledSDEs(f!, g, rand(2)./10)\nsol = simulate(sde, 1.0, dt=0.01, alg=SOSRI())\nplot(sol)","category":"page"},{"location":"man/CoupledSDEs/#Non-diagonal-noise","page":"Define a CoupledSDE","title":"Non-diagonal noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"Non-diagonal noise allows for the terms to linearly mixed via g being a matrix. Suppose we have two Wiener processes and two dependent random variables such that the output of g is a 2x2 matrix. Therefore, we have","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"du_1 = f_1(upt)dt + g_11(upt)dW_1 + g_12(upt)dW_2 \ndu_2 = f_2(upt)dt + g_21(upt)dW_1 + g_22(upt)dW_2","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"To indicate the structure that g should have, we can use the noise_rate_prototype keyword. Let us define a special type of non-diagonal noise called commutative noise. For this we can utilize the RKMilCommute algorithm which is designed to utilise the structure of commutative noise.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"function g(du, u, p, t)\n  du[1,1] = σ*u[1]\n  du[2,1] = σ*u[2]\n  du[1,2] = σ*u[1]\n  du[2,2] = σ*u[2]\n    return nothing\nend\nsde = CoupledSDEs(f!, g, rand(2)./10, noise_rate_prototype = zeros(2, 2))\nsol = simulate(sde, 1.0, dt=0.01, alg=RKMilCommute())\nplot(sol)","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"warning: Warning\nNon-diagonal problem need specific type of solvers. See the SciML recommendations.","category":"page"},{"location":"man/CoupledSDEs/#Corelated-noise","page":"Define a CoupledSDE","title":"Corelated noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"ρ = 0.3\nΣ = [1 ρ; ρ 1]\nt0 = 0.0; W0 = zeros(2); Z0 = zeros(2);\nW = CorrelatedWienerProcess(Σ, t0, W0, Z0)\nsde = CoupledSDEs(f!, idfunc!, zeros(2), nothing, σ; noise=W)\nsol = simulate(sde, 1.0, dt=0.01, alg=SOSRA())\nplot(sol)","category":"page"},{"location":"man/CoupledSDEs/#Noise-process","page":"Define a CoupledSDE","title":"Noise process","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"We provide the noise processes textdmathcalW that can be used in the stochastic simulations through the DiffEqNoiseProcess.jl package. A complete list of the available processes can be found here. We list some of the most common ones below:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDE","title":"Define a CoupledSDE","text":"WienerProcess\nSimpleWienerProcess\nOrnsteinUhlenbeckProcess\nCorrelatedWienerProcess","category":"page"},{"location":"man/CoupledSDEs/#DiffEqNoiseProcess.WienerProcess","page":"Define a CoupledSDE","title":"DiffEqNoiseProcess.WienerProcess","text":"The WienerProcess, also known as Brownian motion, or the noise in the Langevin equation, is the stationary process with white noise increments and a distribution N(0,dt). The constructor is:\n\nWienerProcess(t0,W0,Z0=nothing;kwargs...)\nWienerProcess!(t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"man/CoupledSDEs/#DiffEqNoiseProcess.SimpleWienerProcess","page":"Define a CoupledSDE","title":"DiffEqNoiseProcess.SimpleWienerProcess","text":"The SimpleWienerProcess, also known as Brownian motion, or the noise in the Langevin equation, is the stationary process with white noise increments and a distribution N(0,dt). The constructor is:\n\nSimpleWienerProcess(t0,W0,Z0=nothing;kwargs...)\nSimpleWienerProcess(t0,W0,Z0=nothing;kwargs...)\n\nUnlike WienerProcess, this uses the SimpleNoiseProcess and thus does not support adaptivity, but is slightly more lightweight.\n\n\n\n\n\n","category":"function"},{"location":"man/CoupledSDEs/#DiffEqNoiseProcess.OrnsteinUhlenbeckProcess","page":"Define a CoupledSDE","title":"DiffEqNoiseProcess.OrnsteinUhlenbeckProcess","text":"a Ornstein-Uhlenbeck process, which is a Wiener process defined by the stochastic differential equation\n\ndX_t = theta (mu - X_t) dt + sigma dW_t\n\nThe OrnsteinUhlenbeckProcess is distribution exact (meaning, not a numerical solution of the stochastic differential equation, but instead follows the exact distribution properties). The constructor is:\n\nOrnsteinUhlenbeckProcess(Θ,μ,σ,t0,W0,Z0=nothing;kwargs...)\nOrnsteinUhlenbeckProcess!(Θ,μ,σ,t0,W0,Z0=nothing;kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"man/CoupledSDEs/#DiffEqNoiseProcess.CorrelatedWienerProcess","page":"Define a CoupledSDE","title":"DiffEqNoiseProcess.CorrelatedWienerProcess","text":"One can define a CorrelatedWienerProcess which is a Wiener process with correlations between the Wiener processes. The constructor is:\n\nCorrelatedWienerProcess(Γ,t0,W0,Z0=nothing;kwargs...)\nCorrelatedWienerProcess!(Γ,t0,W0,Z0=nothing;kwargs...)\n\nwhere Γ is the constant covariance matrix.\n\n\n\n\n\n","category":"function"}]
}

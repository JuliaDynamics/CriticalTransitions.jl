var documenterSearchIndex = {"docs":
[{"location":"man/simulation/#Simulating-the-system","page":"Simulating the system","title":"Simulating the system","text":"","category":"section"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"We provide two main functions to simulate a CoupledSDEs forward in time:","category":"page"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"trajectory, which integrates the stochastic CoupledSDEs system forward in time\ndeterministic_orbit, which integrates only the deterministic part of the CoupledSDEs system ","category":"page"},{"location":"man/simulation/#Stochastic-dynamics","page":"Simulating the system","title":"Stochastic dynamics","text":"","category":"section"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"trajectory","category":"page"},{"location":"man/simulation/#DynamicalSystemsBase.trajectory","page":"Simulating the system","title":"DynamicalSystemsBase.trajectory","text":"trajectory(ds::DynamicalSystem, T [, u0]; kwargs...) → X, t\n\nEvolve ds for a total time of T and return its trajectory X, sampled at equal time intervals, and corresponding time vector. X is a StateSpaceSet. Optionally provide a starting state u0 which is current_state(ds) by default.\n\nThe returned time vector is t = (t0+Ttr):Δt:(t0+Ttr+T).\n\nIf time evolution diverged, or in general failed, before T, the remaining of the trajectory is set to the last valid point.\n\ntrajectory is a very simple function provided for convenience. For continuous time systems, it doesn't play well with callbacks, use DifferentialEquations.solve if you want a trajectory/timeseries that works with callbacks, or in general you want more flexibility in the generated trajectory (but remember to convert the output of solve to a StateSpaceSet).\n\nKeyword arguments\n\nΔt:  Time step of value output. For discrete time systems it must be an integer. Defaults to 0.1 for continuous and 1 for discrete time systems. If you don't have access to unicode, the keyword Dt can be used instead.\nTtr = 0: Transient time to evolve the initial state before starting saving states.\nt0 = initial_time(ds): Starting time.\ncontainer = SVector: Type of vector that will represent the state space points that will be included in the StateSpaceSet output. See StateSpaceSet for valid options.\nsave_idxs::AbstractVector: Which variables to output in X. It can be any type of index that can be given to observe_state. Defaults to 1:dimension(ds) (all dynamic variables). Note: if you mix integer and symbolic indexing be sure to initialize the array as Any so that integers 1, 2, ... are not converted to symbolic expressions.\n\n\n\n\n\n","category":"function"},{"location":"man/simulation/#Deterministic-dynamics","page":"Simulating the system","title":"Deterministic dynamics","text":"","category":"section"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"deterministic_orbit","category":"page"},{"location":"man/simulation/#CriticalTransitions.deterministic_orbit","page":"Simulating the system","title":"CriticalTransitions.deterministic_orbit","text":"deterministic_orbit(\n    sys::CoupledSDEs,\n    T;\n    ...\n) -> Tuple{Any, Any}\ndeterministic_orbit(\n    sys::CoupledSDEs,\n    T,\n    init;\n    diffeq,\n    kwargs...\n) -> Tuple{Any, Any}\n\n\nSimulates the deterministic (noise-free) dynamics of CoupledSDEs sys in time for a duration T, starting at initial condition init.\n\nThis function is equivalent to calling trajectory on the deterministic part of the CoupledSDEs (with noise_strength=0). It works with the ODE solvers used for CoupledODEs.\n\nKeyword arguments\n\ndiffeq=(alg=Tsit5(), abstol = 1e-6, reltol = 1e-6): ODE solver settings (see CoupledODEs)\nkwargs...: keyword arguments passed to trajectory\n\nFor more info, see ODEProblem. For stochastic integration, see trajectory.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#Utility-functions","page":"Utilities","title":"Utility functions","text":"","category":"section"},{"location":"man/utils/#CoupledSDEs-utility-functions","page":"Utilities","title":"CoupledSDEs utility functions","text":"","category":"section"},{"location":"man/utils/","page":"Utilities","title":"Utilities","text":"covariance_matrix\ndiffusion_matrix\ndynamic_rule\nnoise_process\ncurrent_state\nset_state!\ndrift\ndiv_drift","category":"page"},{"location":"man/utils/#CriticalTransitions.covariance_matrix","page":"Utilities","title":"CriticalTransitions.covariance_matrix","text":"covariance_matrix(ds::CoupledSDEs)\n\nReturns the covariance matrix of the stochastic term of the CoupledSDEs ds, provided that the diffusion function g can be expressed as a constant invertible matrix. If this is not the case, returns nothing.\n\nSee also diffusion_matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#CriticalTransitions.diffusion_matrix","page":"Utilities","title":"CriticalTransitions.diffusion_matrix","text":"diffusion_matrix(ds::CoupledSDEs)\n\nReturns the diffusion matrix of the stochastic term of the CoupledSDEs ds, provided that the diffusion function g can be expressed as a constant invertible matrix. If this is not the case, returns nothing.\n\nNote: The diffusion matrix Σ is the square root of the noise covariance matrix Q (see covariance_matrix), defined via the Cholesky decomposition Q = Σ Σ^top.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#DynamicalSystemsBase.dynamic_rule","page":"Utilities","title":"DynamicalSystemsBase.dynamic_rule","text":"dynamic_rule(ds::DynamicalSystem) → f\n\nReturn the dynamic rule of ds. This is never mutated and is set when initializing ds.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#CriticalTransitions.noise_process","page":"Utilities","title":"CriticalTransitions.noise_process","text":"noise_process(sys::CoupledSDEs) -> Any\n\n\nFetches the stochastic process mathcalN specified in the intergrator of sys. Returns the type DiffEqNoiseProcess.NoiseProcess.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#DynamicalSystemsBase.current_state","page":"Utilities","title":"DynamicalSystemsBase.current_state","text":"current_state(ds::DynamicalSystem) → u::AbstractArray\n\nReturn the current state of ds. This state is mutated when ds is mutated. See also initial_state, observe_state.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#DynamicalSystemsBase.set_state!","page":"Utilities","title":"DynamicalSystemsBase.set_state!","text":"set_state!(ds::DynamicalSystem, u::AbstractArray{<:Real})\n\nSet the state of ds to u, which must match dimensionality with that of ds. Also ensure that the change is notified to whatever integration protocol is used.\n\n\n\n\n\nset_state!(ds::DynamicalSystem, value::Real, i) → u\n\nSet the ith variable of ds to value. The index i can be an integer or a symbolic-like index for systems that reference a ModelingToolkit.jl model. For example:\n\ni = :x # or `1` or `only(@variables(x))`\nset_state!(ds, 0.5, i)\n\nWarning: this function should not be used with derivative dynamical systems such as Poincare/stroboscopic/projected dynamical systems. Use the method below to manipulate an array and give that to set_state!.\n\nset_state!(u::AbstractArray, value, index, ds::DynamicalSystem)\n\nModify the given state u and leave ds untouched.\n\n\n\n\n\nset_state!(ds::DynamicalSystem, mapping::AbstractDict)\n\nConvenience version of set_state! that iteratively calls set_state!(ds, val, i) for all index-value pairs (i, val) in mapping. This is useful primarily in two cases:\n\nto partially set only some state variables,\nto set variables by name (if the system is created via ModelingToolkit.jl)\n\nso that you don't have to keep track of the order of the dynamic variables.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#CriticalTransitions.drift","page":"Utilities","title":"CriticalTransitions.drift","text":"drift(sys::CoupledSDEs{IIP}, x; t) -> Any\n\n\nReturns the deterministic drift f(x) of the CoupledSDEs sys at state x. For time-dependent systems, the time can be specified as a keyword argument t (by default t=0).\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#CriticalTransitions.div_drift","page":"Utilities","title":"CriticalTransitions.div_drift","text":"div_drift(sys::CoupledSDEs, x; t) -> Any\n\n\nComputes the divergence of the drift field f(x) at state x. For time- dependent systems, the time can be specified as a keyword argument t (by default t=0).\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Large-deviation-theory","page":"Large deviation theory","title":"Large deviation theory","text":"","category":"section"},{"location":"man/largedeviations/#Action-functionals","page":"Large deviation theory","title":"Action functionals","text":"","category":"section"},{"location":"man/largedeviations/#Freidlin-Wentzell-action","page":"Large deviation theory","title":"Freidlin-Wentzell action","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"fw_action","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.fw_action","page":"Large deviation theory","title":"CriticalTransitions.fw_action","text":"fw_action(sys::CoupledSDEs, path, time) -> Any\n\n\nCalculates the Freidlin-Wentzell action of a given path with time points time in a drift field specified by the deterministic dynamics f = dynamic_rule(sys) and (normalized) noise covariance matrix covariance_matrix(sys).\n\nThe path must be a (D x N) matrix, where D is the dimensionality of the system sys and N is the number of path points. The time array must have length N.\n\nReturns a single number, which is the value of the action functional\n\nS_Tphi_t = frac12 int_0^T  dot phi_t - f(phi_t) ^2_Q textdt\n\nwhere phi_t denotes the path in state space, b the drift field, and T the total time of the path. The subscript Q refers to the generalized norm a_Q^2 = langle a Q^-1 b rangle (see anorm). Here Q is the noise covariance matrix normalized by DL_1(Q), with L_1 being the L1 matrix norm.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Geometric-Freidlin-Wentzell-action","page":"Large deviation theory","title":"Geometric Freidlin-Wentzell action","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"geometric_action","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.geometric_action","page":"Large deviation theory","title":"CriticalTransitions.geometric_action","text":"geometric_action(sys::CoupledSDEs, path) -> Any\ngeometric_action(sys::CoupledSDEs, path, arclength) -> Any\n\n\nCalculates the geometric action of a given path with specified arclength for the drift field specified by the deterministic dynamics f = dynamic_rule(sys) and (normalized) noise covariance matrix covariance_matrix(sys).\n\nFor a given path varphi, the geometric action bar S corresponds to the minimum of the Freidlin-Wentzell action S_T(varphi) over all travel times T0, where varphi denotes the path's parameterization in physical time (see fw_action). It is given by the integral\n\nbar Svarphi = int_0^L left( varphi_Q  f(varphi)_Q - langle varphi      f(varphi) rangle_Q right)  textds\n\nwhere s is the arclength coordinate, L the arclength, f the drift field, and the subscript Q refers to the generalized dot product langle a b rangle_Q = a^top cdot Q^-1 b (see anorm). Here Q is the noise covariance matrix normalized by DL_1(Q), with L_1 being the L1 matrix norm.\n\nReturns the value of the geometric action bar S.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Onsager-Machlup-action","page":"Large deviation theory","title":"Onsager-Machlup action","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"om_action","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.om_action","page":"Large deviation theory","title":"CriticalTransitions.om_action","text":"om_action(sys::CoupledSDEs, path, time, noise_strength)\n\nCalculates the Onsager-Machlup action of a given path with time points time for the drift field f = dynamic_rule(sys) at given noise_strength.\n\nThe path must be a (D x N) matrix, where D is the dimensionality of the system sys and N is the number of path points. The time array must have length N.\n\nReturns a single number, which is the value of the action functional\n\nS^sigma_Tphi_t = frac12 int_0^T left(  dot phi_t - f(phi_t) ^2_Q + sigma^2 nabla cdot f right)  textd t\n\nwhere phi_t denotes the path in state space, b the drift field, T the total time of the path, and sigma the noise strength. The subscript Q refers to the generalized norm a_Q^2 = langle a Q^-1 b rangle (see anorm). Here Q is the noise covariance matrix normalized by DL_1(Q), with L_1 being the L1 matrix norm.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"For convenience, a general action function is available where the type of functional is set as an argument:","category":"page"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"action","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.action","page":"Large deviation theory","title":"CriticalTransitions.action","text":"action(\n    sys::CoupledSDEs,\n    path::Matrix,\n    time,\n    functional;\n    noise_strength\n) -> Any\n\n\nComputes the action functional specified by functional for a given CoupledSDEs sys and path parameterized by time.\n\nfunctional = \"FW\": Returns the Freidlin-Wentzell action (fw_action)\nfunctional = \"OM\": Returns the Onsager-Machlup action (om_action)\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Minimum-action-paths","page":"Large deviation theory","title":"Minimum action paths","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"We provide the following two methods to calculate instantons, or minimum action paths, between two states of a CoupledSDEs system.","category":"page"},{"location":"man/largedeviations/#Minimum-action-method-(MAM)","page":"Large deviation theory","title":"Minimum action method (MAM)","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"Minimization of the Freidlin-Wentzell action using the L-BFGS algorithm of Optim.jl.","category":"page"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"min_action_method","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.min_action_method","page":"Large deviation theory","title":"CriticalTransitions.min_action_method","text":"min_action_method(\n    sys::CoupledSDEs,\n    x_i,\n    x_f,\n    N::Int64,\n    T::Real;\n    functional,\n    maxiter,\n    blocks,\n    method,\n    save_iterations,\n    show_progress,\n    verbose\n) -> Any\n\n\nRuns the Minimum Action Method (MAM) to find the minimum action path (instanton) between an initial state x_i and final state x_f.\n\nThis algorithm uses the minimizers of the Optim package to minimize the Freidlin-Wentzell action functional (see fw_action) for the given CoupledSDEs sys. The path is initialized as a straight line between x_i and x_f, parameterized in time via N equidistant points and total time T. Thus, the time step between discretized path points is Delta t = TN. To set an initial path different from a straight line, see the multiple dispatch method\n\nmin_action_method(sys::CoupledSDEs, init::Matrix, T::Real; kwargs...).\n\nThe minimization can be performed in blocks to save intermediate results.\n\nKeyword arguments\n\nfunctional = \"FW\": type of action functional to minimize. Defaults to fw_action, alternative: om_action.\nmaxiter = 100: maximum number of iterations before the algorithm stops.\naction_tol=1e-5: relative tolerance of action value to determine convergence\nabstol=1e-8: absolute tolerance of action gradient to determine convergence\nreltol=1e-8: relative tolerance of action gradient to determine convergence\nblocks = 1: number of iterative optimization blocks\nmethod = LBFGS(): minimization algorithm (see Optim)\nsave_iterations = true: whether to save Optim information\nverbose = true: whether to print Optim information during the run\nshow_progress = false: whether to print a progress bar\n\nOutput\n\nIf save_iterations, returns Optim.OptimizationResults. Else, returns only the optimizer (path). If blocks > 1, a vector of results/optimizers is returned.\n\n\n\n\n\nmin_action_method(\n    sys::CoupledSDEs,\n    init::Matrix,\n    T::Real;\n    functional,\n    maxiter,\n    blocks,\n    method,\n    action_tol,\n    abstol,\n    reltol,\n    save_iterations,\n    verbose,\n    show_progress\n) -> Any\n\n\nRuns the Minimum Action Method (MAM) to find the minimum action path (instanton) from an initial condition init, given a system sys and total path time T.\n\nThe initial path init must be a matrix of size (D, N), where D is the dimension of the system and N is the number of path points. The physical time of the path is specified by T, such that the time step between consecutive path points is Delta t = TN.\n\nFor more information see the main method, min_action_method(sys::CoupledSDEs, x_i, x_f, N::Int, T::Real; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Geometric-minimum-action-method-(gMAM)","page":"Large deviation theory","title":"Geometric minimum action method (gMAM)","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"Minimization of the geometric action following Heymann and Vanden-Eijnden, PRL (2008). The gMAM reformulates MAM to avoid numerical stiffness by reparametrizing the path in terms of arc length. This ensures an even distribution of points along the path, enhancing numerical stability and accuracy. By solving the reparametrized integral, gMAM accurately captures the geometry of the action functional and is well-suited for systems with complex energy landscapes or intricate dynamics.","category":"page"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"geometric_min_action_method","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.geometric_min_action_method","page":"Large deviation theory","title":"CriticalTransitions.geometric_min_action_method","text":"geometric_min_action_method(\n    sys::CoupledSDEs,\n    x_i,\n    x_f;\n    N,\n    kwargs...\n) -> Tuple{Vector{Matrix}, Vector{Float64}}\n\n\nComputes the minimizer of the geometric Freidlin-Wentzell action based on the geometric minimum action method (gMAM), using optimizers of Optim.jl or the original formulation by Heymann and Vanden-Eijnden[1].\n\nTo set an initial path different from a straight line, see the multiple dispatch method\n\ngeometric_min_action_method(sys::CoupledSDEs, init::Matrix, arclength::Float64; kwargs...).\n\nKeyword arguments\n\nmaxiter::Int=100: maximum number of optimization iterations before the alogrithm stops\naction_tol=1e-5: relative tolerance of action value to determine convergence\nabstol=1e-8: absolute tolerance of action gradient to determine convergence\nreltol=1e-8: relative tolerance of action gradient to determine convergence\nmethod=LBFGS(): optimizer method (see Optim.jl)\niter_per_batch=1: number of iterations per optimization batch\ntau=0.1: parameter in HeymannVandenEijnden method\nverbose=false: if true, print additional output\nshow_progress=true: if true, display a progress bar\n\nOptimization algorithms\n\nThe method keyword argument takes solver methods of the Optim.jl package; alternatively, the option solver = \"HeymannVandenEijnden\" uses the original gMAM algorithm[1].\n\n[1]: Heymann and Vanden-Eijnden, PRL (2008)\n\n\n\n\n\ngeometric_min_action_method(\n    sys::CoupledSDEs,\n    init::Matrix;\n    maxiter,\n    abstol,\n    reltol,\n    action_tol,\n    method,\n    tau,\n    iter_per_batch,\n    verbose,\n    show_progress\n) -> Tuple{Vector{Matrix}, Vector{Float64}}\n\n\nRuns the geometric Minimum Action Method (gMAM) to find the minimum action path (instanton) from an initial condition init, given a system sys and total arc length arclength.\n\nThe initial path init must be a matrix of size (D, N), where D is the dimension of the system and N is the number of path points.\n\nFor more information see the main method, geometric_min_action_method(sys::CoupledSDEs, x_i, x_f, arclength::Float64; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Simple-Geometric-minimum-action-method-(sgMAM)","page":"Large deviation theory","title":"Simple Geometric minimum action method (sgMAM)","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"Simplified minimization of the geometric action following Heymann and Vanden-Eijnden, PRL (2008). The sgMAM is a streamlined version of the gMAM that simplifies the computation by avoiding explicit reparametrization of the path. Instead, it introduces an implicit reparametrization by rewriting the problem as a constrained optimization.","category":"page"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"The implementation below perform a constrained gradient descent where it assumes an autonomous system with additive Gaussian noise.","category":"page"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"SgmamSystem\nsgmam","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.Sgmam.SgmamSystem","page":"Large deviation theory","title":"CriticalTransitions.Sgmam.SgmamSystem","text":"A structure representing a system with Hamiltonian functions Hx and Hp.\n\nThis system operates in an extended phase space where the Hamiltonian is assumed to be quadratic in the extended momentum. The phase space coordinates x are doubled to form a 2n-dimensional extended phase space.\n\n\n\n\n\n","category":"type"},{"location":"man/largedeviations/#CriticalTransitions.Sgmam.sgmam","page":"Large deviation theory","title":"CriticalTransitions.Sgmam.sgmam","text":"sgmam(\n    sys::SgmamSystem,\n    x_initial;\n    ϵ,\n    iterations,\n    show_progress,\n    reltol\n) -> Tuple{Any, Float64, Any, Any, Any}\n\n\nPerforms the simplified geometric Minimal Action Method (sgMAM) on the given system sys.\n\nThis method computes the optimal path in the phase space of a Hamiltonian system that minimizes the action. The Hamiltonian functions H_x and H_p define the system's dynamics in a doubled phase. The initial state x_initial is evolved iteratively using constrained gradient descent with step size parameter ϵ over a specified number of iterations. The method can display a progress meter and will stop early if the relative tolerance reltol is achieved.\n\nThe function returns a tuple containing the final state, the action value, the Lagrange multipliers, the momentum, and the state derivatives.\n\n\n\n\n\n","category":"function"},{"location":"man/sampling/#Sampling-transitions","page":"Sampling transitions","title":"Sampling transitions","text":"","category":"section"},{"location":"man/sampling/#...-by-direct-simulation","page":"Sampling transitions","title":"... by direct simulation","text":"","category":"section"},{"location":"man/sampling/","page":"Sampling transitions","title":"Sampling transitions","text":"These functions generate noise-induced transitions between an initial and final state.","category":"page"},{"location":"man/sampling/","page":"Sampling transitions","title":"Sampling transitions","text":"transition(sys::CoupledSDEs, x_i, x_f; kwargs...)\ntransitions(sys::CoupledSDEs, x_i, x_f, N=1; kwargs...)","category":"page"},{"location":"man/sampling/#CriticalTransitions.transition-Tuple{CoupledSDEs, Any, Any}","page":"Sampling transitions","title":"CriticalTransitions.transition","text":"transition(\n    sys::CoupledSDEs,\n    x_i,\n    x_f;\n    rad_i,\n    rad_f,\n    tmax,\n    rad_dims,\n    cut_start,\n    kwargs...\n) -> Tuple{Any, Any, Any}\n\n\nGenerates a sample transition from point x_i to point x_f.\n\nThis function simulates sys in time, starting from initial condition x_i, until entering a length(sys.u)-dimensional ball of radius rad_f around x_f.\n\nKeyword arguments\n\nrad_i=0.1: radius of ball around x_i\nrad_f=0.1: radius of ball around x_f\ntmax=1e3: maximum time when the simulation stops even x_f has not been reached\nrad_dims=1:length(sys.u): the directions in phase space to consider when calculating the radii rad_i and rad_f. Defaults to all directions. To consider only a subspace of state space, insert a vector of indices of the dimensions to be included.\ncut_start=true: if false, returns the whole trajectory up to the transition\nkwargs...: keyword arguments passed to CommonSolve.solve\n\nOutput\n\n[path, times, success]\n\npath (Matrix): transition path (size [dim × N], where N is the number of time points)\ntimes (Vector): time values (since start of simulation) of the path points (size N)\nsuccess (bool): if true, a transition occured (i.e. the ball around x_f has been reached), else false\n\nSee also transitions, trajectory.\n\n\n\n\n\n","category":"method"},{"location":"man/sampling/#CriticalTransitions.transitions","page":"Sampling transitions","title":"CriticalTransitions.transitions","text":"function transitions(sys::CoupledSDEs, x_i, x_f, N=1; kwargs...)\n\nGenerates an ensemble of N transition samples of sys from point x_i to point x_f.\n\nThis function repeatedly calls the transition function to efficiently generate an ensemble of transitions. Multi-threading is enabled.\n\nKeyword arguments\n\nrad_i=0.1: radius of ball around x_i\nrad_f=0.1: radius of ball around x_f\nNmax: number of attempts before the algorithm stops even if less than N transitions occurred.\ntmax=1e3: maximum time when the simulation stops even x_f has not been reached\nrad_dims=1:length(sys.u): the directions in phase space to consider when calculating the radii rad_i and rad_f. Defaults to all directions. To consider only a subspace of state space, insert a vector of indices of the dimensions to be included.\ncut_start=true: if false, returns the whole trajectory up to the transition\nshow_progress: shows a progress bar with respect to Nmax\nkwargs...: keyword arguments passed to CommonSolve.solve\n\nSee also transition.\n\nOutput\n\n[samples, times, idx, N_fail]\n\nsamples (Array of Matrices): sample paths. Each path i has size (dim × Ni), where Ni is the number of path points\ntimes (Array of Vectors): time values (since simulation start) of path points for each path\nidx (Array): list of sample indices i that produced a transition\nN_fail (Int): number of samples that failed to produce a transition\n\nAn example script using transitions is available here.\n\n\n\n\n\n","category":"function"},{"location":"man/sampling/#...-in-pathspace","page":"Sampling transitions","title":"... in pathspace","text":"","category":"section"},{"location":"man/sampling/","page":"Sampling transitions","title":"Sampling transitions","text":"Coming soon...","category":"page"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#Installation","page":"Quickstart","title":"Installation","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"As this module is not published yet, there are two ways to access it:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Option 1 (recommended): Install from GitHub\nEnter the Julia package manager by typing ] in the REPL: julia> ]\ntype add https://github.com/juliadynamics/CriticalTransitions.jl.git\nOption 2: Load module locally\nClone the repo: git clone https://github.com/juliadynamics/CriticalTransitions.jl.git\nIn Julia, include the module file: include(\"PATH/src/CriticalTransitions.jl\"), where PATH is the relative path to the repo you just cloned\nLoad the module: using .CriticalTransitions","category":"page"},{"location":"quickstart/#Basic-usage","page":"Quickstart","title":"Basic usage","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The general workflow of CriticalTransitions essentially follows two steps:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Define your system (see Define a CoupledSDEs system)\nInvestigate the system by calling methods (see Methods)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"info: New system type: RateSystem\nWe are planning to introduce the the struct RateSystem along CoupledSDEs. In a RateSystem, the time dependence of parameters can conveniently be specified, laying the foundation for a toolbox to study rate-induced tipping, or R-tipping.","category":"page"},{"location":"quickstart/#Methods","page":"Quickstart","title":"Methods","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Currently the following functions are implemented to analyze a CoupledSDEs and  corresponding sample transition paths.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Pages = [\"man/simulation.md\", \"man/sampling.md\", \"man/largedeviations.md\"]","category":"page"},{"location":"#CriticalTransitions.jl","page":"Home","title":"CriticalTransitions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for the numerical investigation of noise- and rate-induced transitions in dynamical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Building on DynamicalSystems.jl and DifferentialEquations.jl, this package aims to provide a toolbox for dynamical systems under time-dependent forcing, with a focus on tipping phenomena and metastability.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: CT.jl infographic)","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Current features\nStochastic simulation made easy: Gaussian noise, uncorrelated and correlated, additive and multiplicative\nTransition path sampling: Parallelized ensemble rejection sampling\nLarge deviation theory tools: Action functionals and minimization algorithms (MAM, gMAM)","category":"page"},{"location":"","page":"Home","title":"Home","text":"ukw: Planned features\nRare event simulation: importance sampling, AMS\nQuasipotentials: Ordered line integral method (OLIM)\nRate-induced tipping tools\nSymbolic differentiation of action functionals\n...?","category":"page"},{"location":"","page":"Home","title":"Home","text":"Developers: Reyk Börner, Ryan Deeley, Raphael Römer and Orjan Ameye","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thanks to Jeroen Wouters, Calvin Nesbitt, Tobias Grafke, George Datseris and Oliver Mehling","category":"page"},{"location":"","page":"Home","title":"Home","text":"This work is part of the CriticalEarth project.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To give you an idea of how our package works, this tutorial provides some example code with explanations.","category":"page"},{"location":"tutorial/#Example:-FitzHugh-Nagumo-model","page":"Tutorial","title":"Example: FitzHugh-Nagumo model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's consider a simple 2-dimensional dynamical system - the FitzHugh-Nagumo model:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginaligned\nfracdudt = frac1epsilon left( -alpha u^3 + gamma u - kappa v + I right) \nfracdvdt = -beta v + u  \nendaligned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where epsilon is the parameter of time scale separation between the state variables u and v. The parameters alpha 0, beta 1, gamma0, and kappa0 are real constants, and I denotes a driving term.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's investigate this system under stochastic forcing.","category":"page"},{"location":"tutorial/#System-definition","page":"Tutorial","title":"System definition","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, we need to translate the system equations above into Julia code.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This works exactly as in DynamicalSystems.jl by defining a function f(u,p,t) which takes as input a vector u of state variables (u,v), a vector p of parameters, and time t. The function must return an array of flow increments (textdu, textdv). For performance reasons, it is advisable to return a StaticArray SA[du, dv] rather than just a Vector [du, dv].","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CriticalTransitions\nimport Random # hide\nRandom.seed!(1) # hide\n\nfunction fitzhugh_nagumo(u,p,t)\n    u, v = u\n    ϵ, β, α, γ, κ, I = p\n\n    du = (-α*u^3 + γ*u - κ*v + I)/ϵ\n    dv = -β*v + u\n\n    SA[du, dv]\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tip: In-place vs. out-of-place\nThe function fitzhugh_nagumo(u,p,t) is defined out-of-place. It is also possible to define the system in-place as fitzhugh_nagumo!(du,u,p,t). For more info, see here.","category":"page"},{"location":"tutorial/#CoupledSDE","page":"Tutorial","title":"CoupledSDE","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we construct a stochastic system with the fitzhugh_nagumo equation as the deterministic part. Suppose we would like to force both state variables u and v with additive, uncorrelated Gaussian noise of intensity sigma. This is the default case. We simply write","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p = [1., 3., 1., 1., 1., 0.] # Parameters (ϵ, β, α, γ, κ, I)\nσ = 0.2 # noise strength\n\n# CoupledSDE\nsys = CoupledSDEs(fitzhugh_nagumo, zeros(2), p; noise_strength=σ)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here the first field fitzhugh_nagumo specifies the deterministic dynamics f (see Define a CoupledSDEs system). We have chosen zeros(2) as the initial state of the system, which is the second field. The length of this vector must match the system's dimensionality. In the (optional) third field, we specify the parameter vector p, which includes the parameters of f followed by the parameters of g (in this case, there are no parameters for g). Lastly, noise_strength sets the noise strength. Since we have not specified a noise process, the default case of an uncorrelated Wiener process is used.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Multiplicative and/or correlated noise\nOf course, it is also possible to define more complicated noise processes than simple additive white noise. This is done by specifying a custom noise function and covariance matrix in the CoupledSDEs definition. For more info, see Define a CoupledSDEs system.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"That's it! Now we can apply the toolbox of CriticalTransitions to our stochastic FitzHugh-Nagumo system sys.","category":"page"},{"location":"tutorial/#Find-stable-equilibria","page":"Tutorial","title":"Find stable equilibria","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the parameters chosen above, the FitzHugh-Nagumo system is bistable. Let's compute the fixed points using the fixedpoints function. This function is borrowed from ChaosTools.jl and is loaded as an extension when we write using ChaosTools.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using ChaosTools\n# Calculate fixed points and store the stable ones\neqs, eigs, stab = fixedpoints(sys, [-2,-2], [2,2])\nfp1, fp2 = eqs[stab]","category":"page"},{"location":"tutorial/#Stochastic-simulation","page":"Tutorial","title":"Stochastic simulation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Using the trajectory function, we now run a simulation of our system for 100 time units starting out from the fixed point fp1:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sim = trajectory(sys, 100, fp1)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the keyword arguments, we have specified at which interval the solution is saved. Further keyword arguments can be used to change the solver (the default is SOSRA() for stochastic integration) and other settings.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The simulated trajectory is stored in sim in the usual output format of the solve method of DifferentialEquations.jl, including the solution sim.u and the vector of time points sim.t. The solution can also be accessed as a matrix sim[i, t], where i is the i-th component of u and t the time index.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's plot the result. Did the trajectory transition to the other attractor?","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplt = plot(sim[1][:,1], sim[1][:,2]; xlabel=\"u\", ylabel=\"v\", legend=false)\nscatter!([fp1[1], fp2[1]], [fp1[2], fp2[2]], color=:red, markersize=4)\nxlims!(-1.2, 1.2)\nylims!(-0.6, 0.6)\nplt","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Hopefully, this helped you to get started. For more info, check out the Manual section of these docs.","category":"page"},{"location":"man/CoupledSDEs/#Define-a-CoupledSDEs-system","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"CoupledSDEs","category":"page"},{"location":"man/CoupledSDEs/#DynamicalSystemsBase.CoupledSDEs","page":"Define a CoupledSDEs system","title":"DynamicalSystemsBase.CoupledSDEs","text":"CoupledSDEs <: ContinuousTimeDynamicalSystem\nCoupledSDEs(f, u0 [, p]; kwargs...)\n\nA stochastic continuous time dynamical system defined by a set of coupled stochastic differential equations (SDEs) as follows:\n\ntextdmathbfu = mathbff(mathbfu p t) textdt + mathbfg(mathbfu p t) textdmathcalN_t\n\nwhere mathbfu(t) is the state vector at time t, mathbff describes the deterministic dynamics, and the noise term mathbfg(mathbfu p t) textdmathcalN_t describes the stochastic forcing in terms of a noise function (or diffusion function)  mathbfg and a noise process mathcalN_t. The parameters of the functions mathcalf and mathcalg are contained in the vector p.\n\nThere are multiple ways to construct a CoupledSDEs depending on the type of stochastic forcing.\n\nThe only required positional arguments are the deterministic dynamic rule f(u, p, t), the initial state u0, and optinally the parameter container p (by default p = nothing). For construction instructions regarding f, u0 see the DynamicalSystems.jl tutorial .\n\nBy default, the noise term is standard Brownian motion, i.e. additive Gaussian white noise with identity covariance matrix. To construct different noise structures, see below.\n\nNoise term\n\nThe noise term can be specified via several keyword arguments. Based on these keyword arguments, the noise function g is constructed behind the scenes unless explicitly given.\n\nThe noise strength (i.e. the magnitude of the stochastic forcing) can be scaled with noise_strength (defaults to 1.0). This factor is multiplied with the whole noise term.\nFor non-diagonal and correlated noise, a covariance matrix can be provided via covariance (defaults to identity matrix of size length(u0).)\nFor more complicated noise structures, including state- and time-dependent noise, the noise function g can be provided explicitly as a keyword argument (defaults to nothing). For construction instructions, continue reading.\n\nThe function g interfaces to the diffusion function specified in an SDEProblem of DynamicalSystems.jl. g must follow the same syntax as f, i.e., g(u, p, t) for out-of-place (oop) and g!(du, u, p, t) for in-place (iip).\n\nUnless g is of vector form and describes diagonal noise, a prototype type instance for the output of g must be specified via the keyword argument noise_prototype. It can be of any type A that has the method LinearAlgebra.mul!(Y, A, B) -> Y defined. Commonly, this is a matrix or sparse matrix. If this is not given, it defaults to nothing, which means the g should be interpreted as being diagonal.\n\nThe noise process can be specified via noise_process. It defaults to a standard Wiener process (Gaussian white noise).  For details on defining noise processes, see the docs of DiffEqNoiseProcess.jl . A complete list of the pre-defined processes can be found here. Note that DiffEqNoiseProcess.jl also has an interface for defining custom noise processes.\n\nBy combining g and noise_process, you can define different types of stochastic systems. Examples of different types of stochastic systems are listed on the StochasticDiffEq.jl tutorial page. A quick overview of common types of stochastic systems can also be found in the online docs for CoupledSDEs.\n\nKeyword arguments\n\ng: noise function (default nothing)\nnoise_strength: scaling factor for noise strength (default 1.0)\ncovariance: noise covariance matrix (default nothing)\nnoise_prototype: prototype instance for the output of g (default nothing)\nnoise_process: stochastic process as provided by DiffEqNoiseProcess.jl (default nothing, i.e. standard Wiener process)\nt0: initial time (default 0.0)\ndiffeq: DiffEq solver settings (see below)\nseed: random number seed (default UInt64(0))\n\nDifferentialEquations.jl interfacing\n\nThe CoupledSDEs is evolved using the solvers of DifferentialEquations.jl. To specify a solver via the diffeq keyword argument, use the flag alg, which can be accessed after loading StochasticDiffEq.jl (using StochasticDiffEq). The default diffeq is:\n\n(alg = SOSRA(), abstol = 1.0e-2, reltol = 1.0e-2)\n\ndiffeq keywords can also include a callback for event handling .\n\nDev note: CoupledSDEs is a light wrapper of  SDEIntegrator from StochasticDiffEq.jl. The integrator is available as the field integ, and the SDEProblem is integ.sol.prob. The convenience syntax SDEProblem(ds::CoupledSDEs, tspan = (t0, Inf)) is available to extract the problem.\n\nConverting between CoupledSDEs and CoupledODEs\n\nYou can convert a CoupledSDEs system to CoupledODEs to analyze its deterministic part using the function CoupledODEs(ds::CoupledSDEs; diffeq, t0). Similarly, use CoupledSDEs(ds::CoupledODEs, p; kwargs...) to convert a CoupledODEs into a CoupledSDEs.\n\n\n\n\n\n","category":"type"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"info: Info\nNote that nonlinear mixings of the Noise Process mathcalW fall into the class of random ordinary differential equations (RODEs) which have a separate set of solvers. See this example of DifferentialEquations.jl.","category":"page"},{"location":"man/CoupledSDEs/#defining-stochastic-dynamics","page":"Define a CoupledSDEs system","title":"Examples: Defining stochastic dynamics","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"Let's look at some examples of the different types of stochastic systems that can be defined.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"For simplicity, we choose a slow exponential growth in 2 dimensions as the deterministic dynamics f:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"using DynamicalSystemsBase, StochasticDiffEq, DiffEqNoiseProcess\nusing CairoMakie\nimport Random # hide\nRandom.seed!(10) # hide\nf!(du, u, p, t) = du .= 1.01u # deterministic part\n\nfunction plot_trajectory(Y, t)\n    fig = Figure()\n    ax = Axis(fig[1,1]; xlabel = \"time\", ylabel = \"variable\")\n    for var in columns(Y)\n        lines!(ax, t, var)\n    end\n    fig\nend;","category":"page"},{"location":"man/CoupledSDEs/#Additive-noise","page":"Define a CoupledSDEs system","title":"Additive noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"When g(u p t) is independent of the state u, the noise is called additive; otherwise, it is multiplicative. We can define a simple additive noise system as follows:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"sde = CoupledSDEs(f!, zeros(2));","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"which is equivalent to","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"t0 = 0.0; W0 = zeros(2);\nW = WienerProcess(t0, W0, 0.0)\nsde = CoupledSDEs(f!, zeros(2);\n    noise_process=W, covariance=[1 0; 0 1], noise_strength=1.0\n    );","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"We defined a Wiener process W, whose increments are vectors of normally distributed random numbers of length matching the output of g. The noise is applied element-wise, i.e., g.*dW. Since the noise processes are uncorrelated, meaning the covariance matrix is diagonal, this type of noise is referred to as diagonal.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"We can sample a trajectory from this system using the trajectory function also used for the deterministic systems:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"tr = trajectory(sde, 1.0)\nplot_trajectory(tr...)","category":"page"},{"location":"man/CoupledSDEs/#Correlated-noise","page":"Define a CoupledSDEs system","title":"Correlated noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"In the case of correlated noise, the random numbers in a vector increment dW are correlated. This can be achieved by specifying the covariance matrix Sigma via the covariance keyword:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"ρ = 0.3\nΣ = [1 ρ; ρ 1]\ndiffeq = (alg = LambaEM(), dt=0.1)\nsde = CoupledSDEs(f!, zeros(2); covariance=Σ, diffeq=diffeq)","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"Alternatively, we can parametrise the covariance matrix by defining the diffusion function g ourselves:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"g!(du, u, p, t) = (du .= [1 p[1]; p[1] 1]; return nothing) \nsde = CoupledSDEs(f!, zeros(2), (ρ); g=g!, noise_prototype=zeros(2, 2))","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"Here, we had to provide noise_prototype to indicate that the diffusion function g will output a 2x2 matrix.","category":"page"},{"location":"man/CoupledSDEs/#Scalar-noise","page":"Define a CoupledSDEs system","title":"Scalar noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"If all state variables are forced by the same single random variable, we have scalar noise. To define scalar noise, one has to give an one-dimensional noise process to the noise_process keyword of the CoupledSDEs constructor. ","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"t0 = 0.0; W0 = 0.0;\nnoise = WienerProcess(t0, W0, 0.0)\nsde = CoupledSDEs(f!, rand(2)/10; noise_process=noise)\n\ntr = trajectory(sde, 1.0)\nplot_trajectory(tr...)","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"We can see that noise applied to each variable is the same.","category":"page"},{"location":"man/CoupledSDEs/#Multiplicative-and-time-dependent-noise","page":"Define a CoupledSDEs system","title":"Multiplicative and time-dependent noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"In the SciML ecosystem, multiplicative noise is defined through the condition g_i(t u)=a_i u. However, in the literature the name is more broadly used for any situation where the noise is non-additive and depends on the state u, possibly also in a non-linear way. When defining a CoupledSDEs, we can make the noise term time- and state-dependent by specifying an explicit time- or state-dependence in the noise function g, just like we would define f. For example, we can define a system with temporally decreasing multiplicative noise as follows:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"function g!(du, u, p, t)\n    du .= u ./ (1+t)\n    return nothing\nend\nsde = CoupledSDEs(f!, rand(2)./10; g=g!)","category":"page"},{"location":"man/CoupledSDEs/#Non-diagonal-noise","page":"Define a CoupledSDEs system","title":"Non-diagonal noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"Non-diagonal noise allows for the terms to be linearly mixed (correlated) via g being a matrix. Suppose we have two Wiener processes and two state variables such that the output of g is a 2x2 matrix. Therefore, we have","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"du_1 = f_1(upt)dt + g_11(upt)dW_1 + g_12(upt)dW_2 \ndu_2 = f_2(upt)dt + g_21(upt)dW_1 + g_22(upt)dW_2","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"To indicate the structure that g should have, we must use the noise_prototype keyword. Let us define a special type of non-diagonal noise called commutative noise. For this we can utilize the RKMilCommute algorithm which is designed to utilize the structure of commutative noise.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"σ = 0.25 # noise strength\nfunction g!(du, u, p, t)\n  du[1,1] = σ*u[1]\n  du[2,1] = σ*u[2]\n  du[1,2] = σ*u[1]\n  du[2,2] = σ*u[2]\n    return nothing\nend\ndiffeq = (alg = RKMilCommute(), reltol = 1e-3, abstol = 1e-3, dt=0.1)\nsde = CoupledSDEs(f!, rand(2)./10; g=g!, noise_prototype = zeros(2, 2), diffeq = diffeq)","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"warning: Warning\nNon-diagonal problems need specific solvers. See the SciML recommendations.","category":"page"},{"location":"man/CoupledSDEs/#Interface-to-DynamicalSystems.jl","page":"Define a CoupledSDEs system","title":"Interface to DynamicalSystems.jl","text":"","category":"section"},{"location":"man/CoupledSDEs/#Converting-between-CoupledSDEs-and-CoupledODEs","page":"Define a CoupledSDEs system","title":"Converting between CoupledSDEs and CoupledODEs","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"tip: Analyzing deterministic dynamics with DynamicalSystems.jl\nThe deterministic part of a CoupledSDEs system can easily be extracted as a  CoupledODEs, a common subtype of a ContinuousTimeDynamicalSystem in DynamicalSystems.jl.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"CoupledODEs(sde::CoupledSDEs) extracts the deterministic part of sde as a CoupledODEs.\nCoupledSDEs(ode::CoupledODEs; kwargs) turns ode into a CoupledSDEs.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"CoupledODEs","category":"page"},{"location":"man/CoupledSDEs/#DynamicalSystemsBase.CoupledODEs","page":"Define a CoupledSDEs system","title":"DynamicalSystemsBase.CoupledODEs","text":"CoupledODEs <: ContinuousTimeDynamicalSystem\nCoupledODEs(f, u0 [, p]; diffeq, t0 = 0.0)\n\nA deterministic continuous time dynamical system defined by a set of coupled ordinary differential equations as follows:\n\nfracdvecudt = vecf(vecu p t)\n\nAn alias for CoupledODE is ContinuousDynamicalSystem.\n\nOptionally provide the parameter container p and initial time as keyword t0.\n\nFor construction instructions regarding f, u0 see the DynamicalSystems.jl tutorial.\n\nDifferentialEquations.jl interfacing\n\nThe ODEs are evolved via the solvers of DifferentialEquations.jl. When initializing a CoupledODEs, you can specify the solver that will integrate f in time, along with any other integration options, using the diffeq keyword. For example you could use diffeq = (abstol = 1e-9, reltol = 1e-9). If you want to specify a solver, do so by using the keyword alg, e.g.: diffeq = (alg = Tsit5(), reltol = 1e-6). This requires you to have been first using OrdinaryDiffEq (or smaller library package such as OrdinaryDiffEqVerner) to access the solvers. The default diffeq is:\n\n(alg = OrdinaryDiffEqTsit5.Tsit5{typeof(OrdinaryDiffEqCore.triviallimiter!), typeof(OrdinaryDiffEqCore.triviallimiter!), Static.False}(OrdinaryDiffEqCore.triviallimiter!, OrdinaryDiffEqCore.triviallimiter!, static(false)), abstol = 1.0e-6, reltol = 1.0e-6)\n\ndiffeq keywords can also include callback for event handling .\n\nThe convenience constructors CoupledODEs(prob::ODEProblem [, diffeq]) and CoupledODEs(ds::CoupledODEs [, diffeq]) are also available. Use ODEProblem(ds::CoupledODEs, tspan = (t0, Inf)) to obtain the problem.\n\nTo integrate with ModelingToolkit.jl, the dynamical system must be created via the ODEProblem (which itself is created via ModelingToolkit.jl), see the Tutorial for an example.\n\nDev note: CoupledODEs is a light wrapper of ODEIntegrator from DifferentialEquations.jl.\n\n\n\n\n\n","category":"type"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"For example, the Lyapunov spectrum of a CoupledSDEs in the absence of noise, here exemplified by the FitzHugh-Nagumo model, can be computed by typing:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"using CriticalTransitions\nusing DynamicalSystems: lyapunovspectrum\n\nfunction fitzhugh_nagumo(u, p, t)\n    x, y = u\n    ϵ, β, α, γ, κ, I = p\n\n    dx = (-α * x^3 + γ * x - κ * y + I) / ϵ\n    dy = -β * y + x\n\n    return SA[dx, dy]\nend\n\np = [1.,3.,1.,1.,1.,0.]\n\nsys = CoupledSDEs(fitzhugh_nagumo, zeros(2), p; noise_strength=0.1)\nls = lyapunovspectrum(CoupledODEs(sys), 10000)","category":"page"}]
}

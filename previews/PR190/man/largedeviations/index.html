<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Large deviation theory · CriticalTransitions.jl</title><meta name="title" content="Large deviation theory · CriticalTransitions.jl"/><meta property="og:title" content="Large deviation theory · CriticalTransitions.jl"/><meta property="twitter:title" content="Large deviation theory · CriticalTransitions.jl"/><meta name="description" content="Documentation for CriticalTransitions.jl."/><meta property="og:description" content="Documentation for CriticalTransitions.jl."/><meta property="twitter:description" content="Documentation for CriticalTransitions.jl."/><meta property="og:url" content="https://juliadynamics.github.io/CriticalTransitions.jl/man/largedeviations/"/><meta property="twitter:url" content="https://juliadynamics.github.io/CriticalTransitions.jl/man/largedeviations/"/><link rel="canonical" href="https://juliadynamics.github.io/CriticalTransitions.jl/man/largedeviations/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CriticalTransitions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../../examples/tutorial/">Tutorial</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/gMAM_Maierstein/">Anlyses of the Maier-Stein system</a></li><li><a class="tocitem" href="../../examples/sgMAM_KPO/">sgMAM for the Kerr Parametric Oscillator</a></li><li><a class="tocitem" href="../../examples/transition_path_theory_double_well/">Transition Path Theory using finite element method</a></li><li><a class="tocitem" href="../../examples/OC_mam/">Minimal action method as an Optimal Control problem</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../CoupledSDEs/">Define a CoupledSDEs system</a></li><li><a class="tocitem" href="../systemanalysis/">Stability analysis</a></li><li><a class="tocitem" href="../simulation/">Simulating the system</a></li><li><a class="tocitem" href="../sampling/">Sampling transitions</a></li><li class="is-active"><a class="tocitem" href>Large deviation theory</a><ul class="internal"><li><a class="tocitem" href="#Mimumum-action-path"><span>Mimumum action path</span></a></li><li><a class="tocitem" href="#String-method"><span>String method</span></a></li><li><a class="tocitem" href="#Minimum-action-methods"><span>Minimum action methods</span></a></li><li><a class="tocitem" href="#Action-functionals"><span>Action functionals</span></a></li></ul></li><li><a class="tocitem" href="../transition_path_theory/">Transition path theory</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../bibliography/">Bibliography</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Large deviation theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Large deviation theory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/CriticalTransitions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/main/docs/src/man/largedeviations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Large-deviation-theory"><a class="docs-heading-anchor" href="#Large-deviation-theory">Large deviation theory</a><a id="Large-deviation-theory-1"></a><a class="docs-heading-anchor-permalink" href="#Large-deviation-theory" title="Permalink"></a></h1><h2 id="Mimumum-action-path"><a class="docs-heading-anchor" href="#Mimumum-action-path">Mimumum action path</a><a id="Mimumum-action-path-1"></a><a class="docs-heading-anchor-permalink" href="#Mimumum-action-path" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.MinimumActionPath" href="#CriticalTransitions.MinimumActionPath"><code>CriticalTransitions.MinimumActionPath</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MinimumActionPath{D, T&lt;:Real, V, Phis, Ahis, Lambda, PV, GPV}</code></pre><p>The minimum action path between two points in a D-dimensional phase space.</p><p><strong>Fields</strong></p><ul><li><p><code>path::StateSpaceSet{D, T, V} where {D, T&lt;:Real, V}</code>: The path matrix.</p></li><li><p><code>action::Real</code>: The action value associated to the path.</p></li><li><p><code>path_history::Any</code>: The history of action of the paths in the optimisation algorithm (optional).</p></li><li><p><code>action_history::Any</code>: The history of action of the paths in the optimisation algorithm (optional).</p></li><li><p><code>λ::Any</code>: The Lagrange multiplier parameter for the minimum action path (optional).</p></li><li><p><code>generalized_momentum::Any</code>: The generalized momentum of the phase space variables (optional).</p></li><li><p><code>path_velocity::Any</code>: The path velocity (optional).</p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">MinimumActionPath(
    path,
    action;
    path_history,
    action_history,
    λ,
    generalized_momentum,
    path_velocity
)</code></pre><p>defined at <a href="https://github.com/JuliaDynamics/CriticalTransitions.jl/tree/c7de491d1d732d2282b1d4fdcf2a057e036433af//src/largedeviations/MinimumActionPath.jl#L29"><code>/home/runner/work/CriticalTransitions.jl/CriticalTransitions.jl/src/largedeviations/MinimumActionPath.jl:29</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/c7de491d1d732d2282b1d4fdcf2a057e036433af/src/largedeviations/MinimumActionPath.jl#L1">source</a></section></article><h2 id="String-method"><a class="docs-heading-anchor" href="#String-method">String method</a><a id="String-method-1"></a><a class="docs-heading-anchor-permalink" href="#String-method" title="Permalink"></a></h2><p>The string method is a technique for finding transition paths between two states in a dynamical system. The method represents the path as a &quot;string&quot; of points that connects the states and evolves it to minimize the drift along the path. The resulating  tangent path is parallel to the drift of the system, i.e., the string method computes the heteroclinic orbit. For non-gradient systems (detailed -balance is broken), the heteroclinic orbit differs from the transition path, it does correctly predict, it correctly captures the deterministic dynamics from the saddle point onward (&quot;downhill&quot; portion of the path).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.string_method" href="#CriticalTransitions.string_method"><code>CriticalTransitions.string_method</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">string_method(
    sys::Union{Function, SgmamSystem},
    x_initial::Matrix;
    ϵ,
    iterations,
    show_progress
) -&gt; Any
</code></pre><p>Compute the string method for a given system using <a href="https://doi.org/10.1063/1.2720838">E et al. (2007)</a>.</p><p>The string method is an iterative algorithm used to find minimum energy path (MEP) between two points in phase space. It works by evolving a discretized path (string) according to the system&#39;s drift while maintaining equal arc-length parametrization between points.</p><p>This implementation allows for computation between arbitrary points, not just stable fixed points.</p><p><strong>Arguments</strong></p><ul><li><code>sys::SgmamSystem</code>: The doubled phase space system for which the string method is computed</li><li><code>x_initial</code>: Initial path discretized as a matrix where each column represents a point on the path</li><li><code>ϵ::Real</code>: Step size for the evolution step</li><li><code>iterations::Int64</code>: Maximum number of iterations for path convergence</li><li><code>show_progress::Bool</code>: Whether to display a progress meter during computation</li></ul><p><strong>Returns</strong></p><ul><li><code>x</code>: The final converged path representing the MEP</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/c7de491d1d732d2282b1d4fdcf2a057e036433af/src/largedeviations/string_method.jl#L1-L19">source</a></section><section><div><pre><code class="language-julia hljs">string_method(
    sys::ContinuousTimeDynamicalSystem,
    init;
    kwargs...
) -&gt; Any
</code></pre><p>Compute the string method for a given system using <a href="https://doi.org/10.1063/1.2720838">E et al. (2007)</a>.</p><p>The string method is an iterative algorithm used to find minimum energy path (MEP) between two points in phase space. It works by evolving a discretized path (string) according to the system&#39;s drift while maintaining equal arc-length parametrization between points.</p><p>This implementation allows for computation between arbitrary points, not just stable fixed points.</p><p><strong>Arguments</strong></p><ul><li><code>sys::CoupledSDEs</code>: The system for which the string method is computed</li><li><code>x_initial</code>: Initial path discretized as a matrix where each column represents a point on the path</li><li><code>ϵ::Real</code>: Step size for the evolution step</li><li><code>iterations::Int64</code>: Maximum number of iterations for path convergence</li><li><code>show_progress::Bool</code>: Whether to display a progress meter during computation</li></ul><p><strong>Returns</strong></p><ul><li><code>x</code>: The final converged path representing the MEP</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/c7de491d1d732d2282b1d4fdcf2a057e036433af/src/largedeviations/string_method.jl#L46-L64">source</a></section></article><h2 id="Minimum-action-methods"><a class="docs-heading-anchor" href="#Minimum-action-methods">Minimum action methods</a><a id="Minimum-action-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Minimum-action-methods" title="Permalink"></a></h2><p>The minimum action method (MAM) is a technique for calculating the most probable transition path between two (meta)stable states in a stochastic dynamical system. In the limit of small noise, this path corresponds to the minimizer of an action functional. The action functional typically takes into account both the deterministic drift and the noise intensity of the system. By discretizing this path and using optimization techniques, MAM finds the trajectory that requires the least &quot;effort&quot; to transition between states in phase space.</p><h3 id="Minimum-action-method-(MAM)"><a class="docs-heading-anchor" href="#Minimum-action-method-(MAM)">Minimum action method (MAM)</a><a id="Minimum-action-method-(MAM)-1"></a><a class="docs-heading-anchor-permalink" href="#Minimum-action-method-(MAM)" title="Permalink"></a></h3><p>Minimization of the action functioal using the optimization algorithm of <code>Optimization.jl</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.min_action_method" href="#CriticalTransitions.min_action_method"><code>CriticalTransitions.min_action_method</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">min_action_method(sys::ContinuousTimeDynamicalSystem, x_i, x_f, T::Real; kwargs...)</code></pre><p>Minimizes an action functional to obtain a minimum action path (instanton) between an initial state <code>x_i</code> and final state <code>x_f</code> in phase space.</p><p>This algorithm uses the <a href="https://github.com/SciML/Optimization.jl"><code>Optimization.jl</code></a> package to minimize the specified action functional (either <a href="#CriticalTransitions.fw_action"><code>fw_action</code></a> or <a href="#CriticalTransitions.om_action"><code>om_action</code></a>) for the system <code>sys</code> over paths connecting <code>x_i</code> to <code>x_f</code> in time <code>T</code>.</p><p>The path is initialized as a straight line between <code>x_i</code> and <code>x_f</code>, parameterized in time via <code>N</code> equidistant points and total time <code>T</code>. Thus, the time step between discretized path points is <span>$\Delta t = T/N$</span>. To set an initial path different from a straight line, see the multiple dispatch method</p><blockquote><p><code>min_action_method(sys::ContinuousTimeDynamicalSystem, init::Matrix, T::Real; kwargs...)</code>.</p></blockquote><p>Returns a <a href="#CriticalTransitions.MinimumActionPath"><code>MinimumActionPath</code></a> object containing the optimized path and the action value.</p><p><strong>Keyword arguments</strong></p><ul><li><code>functional = &quot;FW&quot;</code>: type of action functional to minimize. Defaults to <a href="#CriticalTransitions.fw_action"><code>fw_action</code></a>, alternative: &quot;OM&quot; for <a href="#CriticalTransitions.om_action"><code>om_action</code></a>.</li><li><code>N = 100</code>: number of path points to use for the discretization of the path.</li><li><code>noise_strength = nothing</code>: noise strength for the action functional. Specify only if <code>functional = &quot;OM&quot;</code>.</li><li><code>method = Optimisers.Adam()</code>: minimization algorithm (see <a href="https://docs.sciml.ai/Optimization/stable/optimization_packages/optimisers/"><code>Optimization.jl</code></a>)</li><li><code>ad_type = Optimization.AutoFiniteDiff()</code>: type of automatic differentiation to use (see <a href="https://docs.sciml.ai/Optimization/stable/optimization_packages/optimisers/"><code>Optimization.jl</code></a>)</li><li><code>maxiter = 100</code>: maximum number of iterations before the algorithm stops.</li><li><code>abstol=1e-8</code>: absolute tolerance of action gradient to determine convergence</li><li><code>reltol=1e-8</code>: relative tolerance of action gradient to determine convergence</li><li><code>verbose = true</code>: whether to print Optimization information during the run</li><li><code>show_progress = false</code>: whether to print a progress bar</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/c7de491d1d732d2282b1d4fdcf2a057e036433af/src/largedeviations/min_action_method.jl#L1-L36">source</a></section><section><div><pre><code class="language-julia hljs">min_action_method(sys::ContinuousTimeDynamicalSystem, init::Matrix, T::Real; kwargs...)</code></pre><p>Minimizes the specified action functional to obtain a minimum action path (instanton) between fixed end points given a system <code>sys</code> and total path time <code>T</code>.</p><p>The initial path <code>init</code> must be a matrix of size <code>(D, N)</code>, where <code>D</code> is the dimension of the system and <code>N</code> is the number of path points. The physical time of the path is specified by <code>T</code>, such that the time step between consecutive path points is <span>$\Delta t = T/N$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/c7de491d1d732d2282b1d4fdcf2a057e036433af/src/largedeviations/min_action_method.jl#L44-L54">source</a></section></article><h3 id="Geometric-minimum-action-method-(gMAM)"><a class="docs-heading-anchor" href="#Geometric-minimum-action-method-(gMAM)">Geometric minimum action method (gMAM)</a><a id="Geometric-minimum-action-method-(gMAM)-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-minimum-action-method-(gMAM)" title="Permalink"></a></h3><p>Minimization of the geometric action following <a href="https://link.aps.org/doi/10.1103/PhysRevLett.100.140601">Heymann and Vanden-Eijnden, PRL (2008)</a>. The gMAM reformulates MAM to avoid double optimisation of both the action and the transition time. It achieves this by using a geometric action functional that is independent of the time parametrization of the path. This reparameterization invariance makes the method more robust and computationally efficient, particularly for systems with metastable states separated by large barriers.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.geometric_min_action_method" href="#CriticalTransitions.geometric_min_action_method"><code>CriticalTransitions.geometric_min_action_method</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geometric_min_action_method(
    sys::ContinuousTimeDynamicalSystem,
    x_i,
    x_f;
    N,
    kwargs...
) -&gt; MinimumActionPath{_A, _B, _C, Nothing, Nothing, Nothing, Nothing, Nothing} where {_A, _B&lt;:Real, _C}
</code></pre><p>Computes the minimizer of the geometric Freidlin-Wentzell action based on the geometric minimum action method (gMAM), using optimizers of OPtimization.jl or the original formulation by Heymann and Vanden-Eijnden<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. Only Freidlin-Wentzell action has a geometric formulation.</p><p>To set an initial path different from a straight line, see the multiple dispatch method</p><ul><li><code>geometric_min_action_method(sys::CoupledSDEs, init::Matrix, arclength::Real; kwargs...)</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>maxiter::Int=100</code>: maximum number of optimization iterations before the algorithm stops</li><li><code>abstol=1e-8</code>: absolute tolerance of action gradient to determine convergence</li><li><code>reltol=1e-8</code>: relative tolerance of action gradient to determine convergence</li><li><code>method = Adam()</code>: minimization algorithm (see <a href="https://docs.sciml.ai/Optimization/stable/optimization_packages/optimisers/"><code>Optimization.jl</code></a>)</li><li><code>=0.1</code>: step size parameter in gradient descent HeymannVandenEijnden implementation.</li><li><code>verbose=false</code>: if true, print additional output</li><li><code>show_progress=true</code>: if true, display a progress bar</li></ul><p><strong>Optimization algorithms</strong></p><p>The <code>method</code> keyword argument takes solver methods of the <a href="https://docs.sciml.ai/Optimization/"><code>Optimization.jl</code></a> package; alternatively, the option <code>solver = &quot;HeymannVandenEijnden&quot;</code> uses the original gMAM algorithm<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/c7de491d1d732d2282b1d4fdcf2a057e036433af/src/largedeviations/geometric_min_action_method.jl#L1">source</a></section><section><div><pre><code class="language-julia hljs">geometric_min_action_method(
    sys::ContinuousTimeDynamicalSystem,
    init::Matrix;
    maxiter,
    abstol,
    reltol,
    method,
    AD,
    ϵ,
    verbose,
    show_progress
) -&gt; MinimumActionPath{_A, _B, _C, Nothing, Nothing, Nothing, Nothing, Nothing} where {_A, _B&lt;:Real, _C}
</code></pre><p>Runs the geometric Minimum Action Method (gMAM) to find the minimum action path (instanton) from an initial condition <code>init</code>, given a system <code>sys</code> and total arc length <code>arclength</code>.</p><p>The initial path <code>init</code> must be a matrix of size <code>(D, N)</code>, where <code>D</code> is the dimension of the system and <code>N</code> is the number of path points.</p><p>For more information see the main method, <a href="#CriticalTransitions.geometric_min_action_method"><code>geometric_min_action_method(sys::CoupledSDEs, x_i, x_f, arclength::Real; kwargs...)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/c7de491d1d732d2282b1d4fdcf2a057e036433af/src/largedeviations/geometric_min_action_method.jl#L38">source</a></section></article><h3 id="Simple-Geometric-minimum-action-method-(sgMAM)"><a class="docs-heading-anchor" href="#Simple-Geometric-minimum-action-method-(sgMAM)">Simple Geometric minimum action method (sgMAM)</a><a id="Simple-Geometric-minimum-action-method-(sgMAM)-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Geometric-minimum-action-method-(sgMAM)" title="Permalink"></a></h3><p>Simplified minimization of the geometric action following <a href="https://doi.org/10.1007/978-1-4939-6969-2_2">Grafke et al. (2017)</a>. The simple gMAM reduces the complexity of the original gMAM by requiring only first-order derivatives of the underlying Hamiltonian optimisation formulation. This simplifies the numerical treatment and the computational complexity.</p><p>The implementation below perform a constrained gradient descent where it assumes an autonomous system with additive Gaussian noise.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.sgmam" href="#CriticalTransitions.sgmam"><code>CriticalTransitions.sgmam</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sgmam(
    sys::SgmamSystem,
    x_initial::Array{T, 2};
    ϵ,
    iterations,
    show_progress,
    reltol
) -&gt; MinimumActionPath{_A, _B, _C, Nothing, Nothing, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}} where {_A, _B&lt;:Real, _C}
</code></pre><p>Performs the simplified geometric Minimal Action Method (sgMAM) on the given system <code>sys</code>. Our implementation is only valid for additive noise.</p><p>This method computes the optimal path in the phase space of a Hamiltonian system that minimizes the Freidlin–Wentzell action. The Hamiltonian functions <code>H_x</code> and <code>H_p</code> define the system&#39;s dynamics in a doubled phase. The initial state <code>x_initial</code> is evolved iteratively using constrained gradient descent with step size parameter <code>ϵ</code> over a specified number of iterations. The method can display a progress meter and will stop early if the relative tolerance <code>reltol</code> is achieved.</p><p>The function returns a tuple containing the final state, the action value, the Lagrange multipliers, the momentum, and the state derivatives. The implementation is based on the work of <a href="https://homepages.warwick.ac.uk/staff/T.Grafke/simplified-geometric-minimum-action-method-for-the-computation-of-instantons.html. ">Grafke et al. (2019)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/c7de491d1d732d2282b1d4fdcf2a057e036433af/src/largedeviations/sgMAM.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.SgmamSystem" href="#CriticalTransitions.SgmamSystem"><code>CriticalTransitions.SgmamSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A structure representing a system with Hamiltonian functions H<em>x and H</em>p.</p><p>This system operates in an extended phase space where the Hamiltonian is assumed to be quadratic in the extended momentum. The phase space coordinates <code>x</code> are doubled to form a 2n-dimensional extended phase space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/c7de491d1d732d2282b1d4fdcf2a057e036433af/src/largedeviations/sgMAM.jl#L1-L7">source</a></section></article><h2 id="Action-functionals"><a class="docs-heading-anchor" href="#Action-functionals">Action functionals</a><a id="Action-functionals-1"></a><a class="docs-heading-anchor-permalink" href="#Action-functionals" title="Permalink"></a></h2><h3 id="Freidlin-Wentzell-action"><a class="docs-heading-anchor" href="#Freidlin-Wentzell-action">Freidlin-Wentzell action</a><a id="Freidlin-Wentzell-action-1"></a><a class="docs-heading-anchor-permalink" href="#Freidlin-Wentzell-action" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.fw_action" href="#CriticalTransitions.fw_action"><code>CriticalTransitions.fw_action</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fw_action(sys::CoupledSDEs, path, time) -&gt; Any
</code></pre><p>Calculates the Freidlin-Wentzell action of a given <code>path</code> with time points <code>time</code> in a drift field specified by the deterministic dynamics <code>f = dynamic_rule(sys)</code> and (normalized) noise covariance matrix <code>covariance_matrix(sys)</code>.</p><p>The path must be a <code>(D x N)</code> matrix, where <code>D</code> is the dimensionality of the system <code>sys</code> and <code>N</code> is the number of path points. The <code>time</code> array must have length <code>N</code>.</p><p>Returns a single number, which is the value of the action functional</p><p><span>$S_T[\phi_t] = \frac{1}{2} \int_0^T || \dot \phi_t - f(\phi_t) ||^2_Q \text{d}t$</span></p><p>where <span>$\phi_t$</span> denotes the path in state space, <span>$b$</span> the drift field, and <span>$T$</span> the total time of the path. The subscript <span>$Q$</span> refers to the generalized norm <span>$||a||_Q^2 := \langle a, Q^{-1} b \rangle$</span> (see <code>anorm</code>). Here <span>$Q$</span> is the noise covariance matrix normalized by <span>$D/L_1(Q)$</span>, with <span>$L_1$</span> being the L1 matrix norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/c7de491d1d732d2282b1d4fdcf2a057e036433af/src/largedeviations/action.jl#L1">source</a></section></article><h3 id="Geometric-Freidlin-Wentzell-action"><a class="docs-heading-anchor" href="#Geometric-Freidlin-Wentzell-action">Geometric Freidlin-Wentzell action</a><a id="Geometric-Freidlin-Wentzell-action-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-Freidlin-Wentzell-action" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.geometric_action" href="#CriticalTransitions.geometric_action"><code>CriticalTransitions.geometric_action</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geometric_action(sys::CoupledSDEs, path) -&gt; Any
geometric_action(sys::CoupledSDEs, path, arclength) -&gt; Any
</code></pre><p>Calculates the geometric action of a given <code>path</code> with specified <code>arclength</code> for the drift field specified by the deterministic dynamics <code>f = dynamic_rule(sys)</code> and (normalized) noise covariance matrix <code>covariance_matrix(sys)</code>.</p><p>For a given path <span>$\varphi$</span>, the geometric action <span>$\bar S$</span> corresponds to the minimum of the Freidlin-Wentzell action <span>$S_T(\varphi)$</span> over all travel times <span>$T&gt;0$</span>, where <span>$\varphi$</span> denotes the path&#39;s parameterization in physical time (see <a href="#CriticalTransitions.fw_action"><code>fw_action</code></a>). It is given by the integral</p><p><span>$\bar S[\varphi] = \int_0^L \left( ||\varphi&#39;||_Q \, ||f(\varphi)||_Q - \langle \varphi&#39;, \,     f(\varphi) \rangle_Q \right) \, \text{d}s$</span></p><p>where <span>$s$</span> is the arclength coordinate, <span>$L$</span> the arclength, <span>$f$</span> the drift field, and the subscript <span>$Q$</span> refers to the generalized dot product <span>$\langle a, b \rangle_Q := a^{\top} \cdot Q^{-1} b$</span> (see <code>anorm</code>). Here <span>$Q$</span> is the noise covariance matrix normalized by <span>$D/L_1(Q)$</span>, with <span>$L_1$</span> being the L1 matrix norm.</p><p>Returns the value of the geometric action <span>$\bar S$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/c7de491d1d732d2282b1d4fdcf2a057e036433af/src/largedeviations/action.jl#L89">source</a></section></article><h3 id="Onsager-Machlup-action"><a class="docs-heading-anchor" href="#Onsager-Machlup-action">Onsager-Machlup action</a><a id="Onsager-Machlup-action-1"></a><a class="docs-heading-anchor-permalink" href="#Onsager-Machlup-action" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.om_action" href="#CriticalTransitions.om_action"><code>CriticalTransitions.om_action</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">om_action(sys::CoupledSDEs, path, time, noise_strength)</code></pre><p>Calculates the Onsager-Machlup action of a given <code>path</code> with time points <code>time</code> for the drift field <code>f = dynamic_rule(sys)</code> at given <code>noise_strength</code>.</p><p>The path must be a <code>(D x N)</code> matrix, where <code>D</code> is the dimensionality of the system <code>sys</code> and <code>N</code> is the number of path points. The <code>time</code> array must have length <code>N</code>.</p><p>Returns a single number, which is the value of the action functional</p><p><span>$S^{\sigma}_T[\phi_t] = \frac{1}{2} \int_0^T \left( || \dot \phi_t - f(\phi_t) ||^2_Q + \sigma^2 \nabla \cdot f \right) \, \text{d} t$</span></p><p>where <span>$\phi_t$</span> denotes the path in state space, <span>$b$</span> the drift field, <span>$T$</span> the total time of the path, and <span>$\sigma$</span> the noise strength. The subscript <span>$Q$</span> refers to the generalized norm <span>$||a||_Q^2 := \langle a, Q^{-1} b \rangle$</span> (see <code>anorm</code>). Here <span>$Q$</span> is the noise covariance matrix normalized by <span>$D/L_1(Q)$</span>, with <span>$L_1$</span> being the L1 matrix norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/c7de491d1d732d2282b1d4fdcf2a057e036433af/src/largedeviations/action.jl#L36-L54">source</a></section></article><p>For convenience, a general <a href="#CriticalTransitions.action"><code>action</code></a> function is available where the type of functional is set as an argument:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CriticalTransitions.action" href="#CriticalTransitions.action"><code>CriticalTransitions.action</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">action(
    sys::CoupledSDEs,
    path::Matrix,
    time,
    functional;
    noise_strength
) -&gt; Any
</code></pre><p>Computes the action functional specified by <code>functional</code> for a given CoupledSDEs <code>sys</code> and <code>path</code> parameterized by <code>time</code>.</p><ul><li><code>functional = &quot;FW&quot;</code>: Returns the Freidlin-Wentzell action (<a href="#CriticalTransitions.fw_action"><code>fw_action</code></a>)</li><li><code>functional = &quot;OM&quot;</code>: Returns the Onsager-Machlup action (<a href="#CriticalTransitions.om_action"><code>om_action</code></a>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/c7de491d1d732d2282b1d4fdcf2a057e036433af/src/largedeviations/action.jl#L71">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://link.aps.org/doi/10.1103/PhysRevLett.100.140601">Heymann and Vanden-Eijnden, PRL (2008)</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sampling/">« Sampling transitions</a><a class="docs-footer-nextpage" href="../transition_path_theory/">Transition path theory »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 6 August 2025 10:12">Wednesday 6 August 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

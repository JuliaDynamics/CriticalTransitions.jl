var documenterSearchIndex = {"docs":
[{"location":"examples/duffing_TPT/#Transition-Path-Theory-for-the-double-well","page":"Transition Path Theory using finite element method","title":"Transition Path Theory for the double well","text":"","category":"section"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"In this example, we explore the application of Transition Path Theory to a double well system. We will compute various quantities of interest in Transition Path Theory (TPT), such as the Hamiltonian, committor functions, reactive currents, and reaction rates. These computations will be performed on a triangular mesh in the phase space, providing insights into the system's dynamics and transition paths between different states.","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"using CriticalTransitions\n\nusing CairoMakie\nusing OrdinaryDiffEq, DelaunayTriangulation, Contour","category":"page"},{"location":"examples/duffing_TPT/#System","page":"Transition Path Theory using finite element method","title":"System","text":"","category":"section"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"The double well is a simple model for particle with a double-well potential. The equation of motion under additive Gaussian noise is given by:","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"dotx = p \ndotp = -gamma p - nabla U + sqrtfrac2gammabeta dotW","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"with the potential energy U(x) = frac14x^4 - frac12x^2 and the kinetic energy K(p) = p^22. The parameters gamma and beta=1k_b T control the strength of the dissipation and noise, respectively. W is a Wiener process, and the noise term is scaled by sqrt2gammabeta to ensure the correct temperature scaling for a Langevin type system defined by the Hamiltonian H.","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"beta = 20.0\ngamma = 0.5\n\nfunction Hamiltonian(x, y)\n    return 0.5 .* y .^ 2 .+ 0.25 .* x .^ 4 .- 0.5 .* x .^ 2\nend\n\nfunction KE(x)\n    return 0.5 .* (x[:, 2] .^ 2)\nend\n\nfunction divfree(x, y)\n    f1 = y\n    f2 = .-x .^ 3 .+ x\n    return f1, f2\nend\n\nfunction double_well(x, y)\n    f1 = y\n    f2 = .-gamma .* y .- x .^ 3 .+ x\n    return f1, f2\nend\n\nlangevin_sys = Langevin(Hamiltonian, divfree, KE, gamma, beta)","category":"page"},{"location":"examples/duffing_TPT/#Phase-space-mesh","page":"Transition Path Theory using finite element method","title":"Phase space mesh","text":"","category":"section"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"We can easily evaluate and visualize the Hamiltonian and equally spaced grid in phase space.","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"nx, ny = 41, 41\nnxy = nx * ny\nxmin, xmax = -2.0, 2.0\nymin, ymax = -2.0, 2.0\n\nx1 = range(xmin, xmax; length=nx)\ny1 = range(ymin, ymax; length=ny)\n\nx_grid = [xx for yy in y1, xx in x1]\ny_grid = [yy for yy in y1, xx in x1]\n\ndrift1, drift2 = double_well(x_grid, y_grid)\ndnorm = sqrt.(drift1 .^ 2 .+ drift2 .^ 2 .+ 1e-12)\nHgrid = Hamiltonian(x_grid, y_grid)\n\nfig = CairoMakie.contour(x1, y1, Hgrid'; colormap=:viridis, levels=-1:0.4:2, linewidth=2)\nv(x::Point2) = Point2f(double_well(x[1], x[2])...)\nstreamplot!(\n    v,\n    -2 .. 2,\n    -2 .. 2;\n    linewidth=0.5,\n    colormap=[:black, :black],\n    gridsize=(40, 40),\n    arrow_size=8,\n)\nfig","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"The double well, is autonomous and respect detailed balance. As such the maximum likelihood path is the path that is parallel to drift and can be computed with the string method. If one know the saddle point, one can easily compute the MLP by solving for the (reverse) flow/drift from the saddle point to the minima. As such, the maximum likelihood transition path from (-1,0) to (1,0) gives:","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"using OrdinaryDiffEq\n\nfunction reverse_drift!(du, u, p, t)\n    du[1] = -u[2]\n    return du[2] = -u[2] + u[1] * (u[1]^2 - 1)\nend\n\nfunction drift!(du, u, p, t)\n    du[1] = u[2]\n    return du[2] = -u[2] - u[1] * (u[1]^2 - 1)\nend\n\nprob0 = ODEProblem(reverse_drift!, [-0.001, 0.0], (0.0, 100.0))\nsol0 = solve(prob0, Tsit5(); abstol=1e-12, reltol=1e-12)\n\nprob1 = ODEProblem(drift!, [0.001, 0.0], (0.0, 100.0))\nsol1 = solve(prob1, Tsit5(); abstol=1e-12, reltol=1e-12)\n\nfig = streamplot(\n    v,\n    -2 .. 2,\n    -2 .. 2;\n    linewidth=0.5,\n    colormap=[:gray, :gray],\n    gridsize=(40, 40),\n    arrow_size=8,\n)\ny = sol0\nlines!(y[1, :], y[2, :]; linewidth=2, color=:black)\ny = sol1\nlines!(y[1, :], y[2, :]; linewidth=2, color=:black)\nfig","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"We have two minima in the potential landscape, such that the system under the drift will dissipate to these corresponding attractors close to (-10 00) and (10 00). Transition path theory investigates the \"reaction\" between two sets in phase space A and B, as such we define the two sets to be an ellipse around these minima:","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"point_a = (-1.0, 0.0)\npoint_b = (1.0, 0.0)\nradii = (0.3, 0.4)\ndensity = 0.04\n\nNa = round(Int, π * sum(radii) / density) # the number of points on the A-circle\nNb = Na\n\nptsA = get_ellipse(point_a, radii, Na)\nptsB = get_ellipse(point_b, radii, Na);\nnothing #hide","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"We also compute an outer boundary of the phase space defined by the maximum value of the Hamiltonian: Hbdry=0.5. For this, we use the contour package to compute the contour at the level Hbdry. Just as the ellipse around the attractors, we also reparameterize the boundary to have a uniform grid spacing.","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"import Contour as CTR\nHbdry = 0.5\ncont = CTR.contour(x1, y1, Hgrid, Hbdry)\nyc, xc = coordinates(CTR.lines(cont)[1])\np_outer = [xc yc]\n\npts_outer = reparameterization(p_outer, density);\nNouter = size(pts_outer, 1)\nNfix = Na + Nb + Nouter\n\nfig = scatter(ptsA[:, 1], ptsA[:, 2]; label=\"A points\")\nscatter!(ptsB[:, 1], ptsB[:, 2]; label=\"B points\")\nscatter!(pts_outer[:, 1], pts_outer[:, 2]; label=\"Outer points\")\nfig","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"We would like to compute the committor, the reactive current, and the reaction rate for the double well with additive Gaussian noise. We compute these quantities on a triangular mesh between the before computed boundaries.","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"box = [xmin, xmax, ymin, ymax]\npfix = zeros(Nfix, 2)\npfix[1:Na, :] .= ptsA\npfix[(Na + 1):(Na + Nb), :] .= ptsB\npfix[(Na + Nb + 1):Nfix, :] .= pts_outer\n\nfunction dfunc(p)\n    d0 = Hamiltonian(p[:, 1], p[:, 2])\n    dA = dellipse(p, point_a, radii)\n    dB = dellipse(p, point_b, radii)\n    d = ddiff(d0 .- Hbdry, dunion(dA, dB))\n    return d\nend\n\nmesh = distmesh2D(dfunc, huniform, density, box, pfix)\n\npts, tri = mesh.pts, mesh.tri\nfig = Figure()\nax = Axis(fig[1, 1])\nfor i in 1:size(tri, 1)\n    lines!(\n        ax,\n        [pts[tri[i, j], 1] for j in [1, 2, 3, 1]],\n        [pts[tri[i, j], 2] for j in [1, 2, 3, 1]];\n        color=:black,\n        linewidth=0.1,\n    )\nend\nfig\n\n# Committor functions","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"A committor measures the probability that a system, starting at a given point in phase space, will reach one designated region before another. Formally, for two disjoint sets A and B, the forward committor q_+(x p) from A to B gives the likelihood that a trajectory initiated at x will reach B before A under the system’s dynamics. The committor boundary-value problem for a Langevin system is given by:","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":" p fracmathrmdqmathrmdx - U(x) fracmathrmdqmathrmdp + gamma -p fracmathrmdqmathrmdp + beta^-1 fracmathrmd^2 qmathrmdp^2 = 0","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"for (xp) in (Acup B)^c, with boundary conditions q(partial A) = 0, q(partial B) = 1, and nabla nabla q = 0 on the outer boundary (xp)  H(xp) = mathrmHbdry. The homogeneous Neumann boundary condition nabla nabla q = 0 means that the trajectory reflects from the outer boundary whenever it reaches it. We can compute the committor function for the system using the committor function.","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"_, Aind = find_boundary(mesh.pts, point_a, radii, density)\n_, Bind = find_boundary(mesh.pts, point_b, radii, density)\n\nq = committor(langevin_sys, mesh, Aind, Bind)\n\n@show extrema(q)\n\ntricontourf(Triangulation(mesh.pts', mesh.tri'), q)","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"We can also compute the backward committor q_-(x p) from A to B, which is the probability that a trajectory initiated at x will reach A before B under the system’s dynamics. Hence, we must reverse the drift function in the Langevin system and swap the boundaries A and B in the committor function","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"function divfree1(x, y)\n    f1, f2 = divfree(x, y)\n    return -f1, -f2\nend\n\nlangevin_sys_reverse = CriticalTransitions.Langevin(Hamiltonian, divfree1, KE, gamma, beta)\n\nqminus = committor(langevin_sys_reverse, mesh, Bind, Aind)\n\n@show extrema(qminus)\n\ntricontourf(Triangulation(mesh.pts', mesh.tri'), qminus)","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"For non-equilibrium processes, such as the transitions in the double-well, we have that the q_-neq 1-q_+. In particular, for Langevin systems of the form in the system above time reversal involves a momentum flip such that q_-(x p)= 1-q_+(x -p).","category":"page"},{"location":"examples/duffing_TPT/#Probability-Density-of-Reactive-Trajectories","page":"Transition Path Theory using finite element method","title":"Probability Density of Reactive Trajectories","text":"","category":"section"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"In general, we are interested in reactive trajectories that start in A and ends in B without going back to A. The probability density of finding a reactive trajectory at a point in phase space is given by:","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"rho_R(x p) = rho(x p) q(x p) q(x p)","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"where rho(x p) is the probability density of finding a trajectory at (xp), rho(x p) is also called the invariant probability density of the system. For an overdamped Langevin system the invariant probability density:","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"rho(x p) approx exp(-beta H(xp))Z","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"with Z=int exp(-beta H(xp)) mathrmdx mathrmdp the normalization. We can compute the integrated invariant probability density Z for the mesh using the invariant_pdf function.","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"function dfuncA(p)\n    return dellipse(p, point_a, radii)\nend\n\nfunction dfuncB(p)\n    return dellipse(p, point_b, radii)\nend\n\nxa, ya = point_a\nxb, yb = point_b\nrx, ry = radii\nbboxA = [xa - rx, xa + rx, ya - ry, ya + ry]\nAmesh = distmesh2D(dfuncA, huniform, density, bboxA, ptsA)\nbboxB = [xb - rx, xb + rx, yb - ry, yb + ry]\nBmesh = distmesh2D(dfuncB, huniform, density, bboxB, ptsB)\n\nZ = invariant_pdf(langevin_sys, mesh, Amesh, Bmesh)\n\n@show Z","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"Hence, the probability density of a reactive trajectory is given by:","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"mu = exp.(-beta * Hamiltonian(pts[:, 1], pts[:, 2])) / Z\nmuAB = mu .* q .* qminus\n\ntricontourf(Triangulation(mesh.pts', mesh.tri'), muAB)","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"The current of reactive trajectories is given by:","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"J_R = frace^-beta H q_+ q_-Zbinomp-nabla U+k_B T gamma Z^-1 e^-beta Hbinom0q_- fracpartial q_+partial p-q_+ fracpartial q_-partial p","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"and the transition rate:","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"v_R=k_B T gamma Z_H^-1 int sum_i=1^d m_ileft(fracpartial q_+partial p_iright)^2 e^-beta H(x p) d x d p","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"These can be computed using the reactive_current function:","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"Rcurrent, Rrate = reactive_current(langevin_sys, mesh, q, qminus, Z)\n@show Rrate","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"Plotting the current norm reveals that the current is the strongest around the saddle point.","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"ARcurrent = vec(sqrt.(sum(Rcurrent .^ 2; dims=2)))\nARCmax = maximum(ARcurrent)\n\ntricontourf(Triangulation(mesh.pts', mesh.tri'), ARcurrent)","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"The transition current has a direction from A to B.","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"c = ARcurrent ./ ARCmax\narrows2d(\n    pts[:, 1],\n    pts[:, 2],\n    Rcurrent[:, 1] ./ ARCmax,\n    Rcurrent[:, 2] ./ ARCmax;\n    color=c,\n    lengthscale=0.1,\n)","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"prob_reactive = probability_reactive(langevin_sys, mesh, q, qminus, Z)\nprint(\n    \"Probability that a trajectory is reactive at a randomly picked time: \", prob_reactive\n)","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"prob_lastA = probability_last_A(langevin_sys, mesh, Amesh, qminus, Z)\nprint(\"Probability that a trajectory last visited A: \", prob_lastA)","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"","category":"page"},{"location":"examples/duffing_TPT/","page":"Transition Path Theory using finite element method","title":"Transition Path Theory using finite element method","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"To give you an idea of how our package works, this tutorial provides some example code with explanations.","category":"page"},{"location":"examples/tutorial/#Example:-FitzHugh-Nagumo-model","page":"Tutorial","title":"Example: FitzHugh-Nagumo model","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's consider a simple 2-dimensional dynamical system - the FitzHugh-Nagumo model:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"beginaligned\nfracdudt = frac1epsilon left( -alpha u^3 + gamma u - kappa v + I right) \nfracdvdt = -beta v + u  \nendaligned","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"where epsilon is the parameter of time scale separation between the state variables u and v. The parameters alpha 0, beta 1, gamma0, and kappa0 are real constants, and I denotes a driving term.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's investigate this system under stochastic forcing.","category":"page"},{"location":"examples/tutorial/#System-definition","page":"Tutorial","title":"System definition","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"First, we need to translate the system equations above into Julia code.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"This works exactly as in DynamicalSystems.jl by defining a function f(u,p,t) which takes as input a vector u of state variables (u,v), a vector p of parameters, and time t. The function must return an array of flow increments (textdu, textdv). For performance reasons, it is advisable to return a StaticArray SA[du, dv] rather than just a Vector [du, dv].","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"using CriticalTransitions\nimport Random # hide\nRandom.seed!(1) # hide\n\nfunction fitzhugh_nagumo(u,p,t)\n    u, v = u\n    ϵ, β, α, γ, κ, I = p\n\n    du = (-α*u^3 + γ*u - κ*v + I)/ϵ\n    dv = -β*v + u\n\n    SA[du, dv]\nend","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"tip: In-place vs. out-of-place\nThe function fitzhugh_nagumo(u,p,t) is defined out-of-place. It is also possible to define the system in-place as fitzhugh_nagumo!(du,u,p,t). For more info, see here.","category":"page"},{"location":"examples/tutorial/#CoupledSDE","page":"Tutorial","title":"CoupledSDE","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we construct a stochastic system with the fitzhugh_nagumo equation as the deterministic part. Suppose we would like to force both state variables u and v with additive, uncorrelated Gaussian noise of intensity sigma. This is the default case. We simply write","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"p = [1., 3., 1., 1., 1., 0.] # Parameters (ϵ, β, α, γ, κ, I)\nσ = 0.2 # noise strength\n\n# CoupledSDE\nsys = CoupledSDEs(fitzhugh_nagumo, zeros(2), p; noise_strength=σ)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here the first field fitzhugh_nagumo specifies the deterministic dynamics f (see Define a CoupledSDEs system). We have chosen zeros(2) as the initial state of the system, which is the second field. The length of this vector must match the system's dimensionality. In the (optional) third field, we specify the parameter vector p, which includes the parameters of f followed by the parameters of g (in this case, there are no parameters for g). Lastly, noise_strength sets the noise strength. Since we have not specified a noise process, the default case of an uncorrelated Wiener process is used.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Multiplicative and/or correlated noise\nOf course, it is also possible to define more complicated noise processes than simple additive white noise. This is done by specifying a custom noise function and covariance matrix in the CoupledSDEs definition. For more info, see Define a CoupledSDEs system.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"That's it! Now we can apply the toolbox of CriticalTransitions to our stochastic FitzHugh-Nagumo system sys.","category":"page"},{"location":"examples/tutorial/#Find-stable-equilibria","page":"Tutorial","title":"Find stable equilibria","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"For the parameters chosen above, the FitzHugh-Nagumo system is bistable. Let's compute the fixed points using the fixedpoints function. This function is borrowed from ChaosTools.jl and is loaded as an extension when we write using ChaosTools.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"using ChaosTools\n# Calculate fixed points and store the stable ones\neqs, eigs, stab = fixedpoints(sys, [-2,-2], [2,2])\nfp1, fp2 = eqs[stab]","category":"page"},{"location":"examples/tutorial/#Stochastic-simulation","page":"Tutorial","title":"Stochastic simulation","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Using the trajectory function, we now run a simulation of our system for 100 time units starting out from the fixed point fp1:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"sim = trajectory(sys, 100, fp1)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"In the keyword arguments, we have specified at which interval the solution is saved. Further keyword arguments can be used to change the solver (the default is SOSRA() for stochastic integration) and other settings.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"The simulated trajectory is stored in sim in the usual output format of the solve method of DifferentialEquations.jl, including the solution sim.u and the vector of time points sim.t. The solution can also be accessed as a matrix sim[i, t], where i is the i-th component of u and t the time index.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's plot the result. Did the trajectory transition to the other attractor?","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplt = plot(sim[1][:,1], sim[1][:,2]; xlabel=\"u\", ylabel=\"v\", legend=false)\nscatter!([fp1[1], fp2[1]], [fp1[2], fp2[2]], color=:red, markersize=4)\nxlims!(-1.2, 1.2)\nylims!(-0.6, 0.6)\nplt","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Hopefully, this helped you to get started. For more info, check out the Manual section of these docs.","category":"page"},{"location":"man/simulation/#Simulating-the-system","page":"Simulating the system","title":"Simulating the system","text":"","category":"section"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"We provide two main functions to simulate a CoupledSDEs forward in time:","category":"page"},{"location":"man/simulation/","page":"Simulating the system","title":"Simulating the system","text":"DynamicalSystemsBase.trajectory, which integrates the stochastic CoupledSDEs system forward in time\ndeterministic_orbit, which integrates only the deterministic part of the CoupledSDEs system ","category":"page"},{"location":"man/simulation/#CriticalTransitions.deterministic_orbit","page":"Simulating the system","title":"CriticalTransitions.deterministic_orbit","text":"deterministic_orbit(\n    sys::CoupledSDEs,\n    T;\n    ...\n) -> Tuple{Any, Any}\ndeterministic_orbit(\n    sys::CoupledSDEs,\n    T,\n    init;\n    diffeq,\n    kwargs...\n) -> Tuple{Any, Any}\n\n\nSimulates the deterministic (noise-free) dynamics of CoupledSDEs sys in time for a duration T, starting at initial condition init.\n\nThis function is equivalent to calling trajectory on the deterministic part of the CoupledSDEs (with noise_strength=0). It works with the ODE solvers used for CoupledODEs.\n\nKeyword arguments\n\ndiffeq=(alg=Tsit5(), abstol = 1e-6, reltol = 1e-6): ODE solver settings (see CoupledODEs)\nkwargs...: keyword arguments passed to trajectory\n\nFor more info, see ODEProblem. For stochastic integration, see trajectory.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#Utility-functions","page":"Utilities","title":"Utility functions","text":"","category":"section"},{"location":"man/utils/#CoupledSDEs-utility-functions","page":"Utilities","title":"CoupledSDEs utility functions","text":"","category":"section"},{"location":"man/utils/#CriticalTransitions.solver","page":"Utilities","title":"CriticalTransitions.solver","text":"solver(ds::ContinuousTimeDynamicalSystem) -> Any\n\n\nReturns the SDE solver specified in the diffeq settings of the CoupledSDEs.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#CriticalTransitions.drift","page":"Utilities","title":"CriticalTransitions.drift","text":"drift(\n    sys::Union{CoupledODEs{IIP}, CoupledSDEs{IIP}},\n    x;\n    t\n) -> Any\n\n\nReturns the deterministic drift f(x) of the CoupledSDEs sys at state x. For time-dependent systems, the time can be specified as a keyword argument t (by default t=0).\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#CriticalTransitions.div_drift","page":"Utilities","title":"CriticalTransitions.div_drift","text":"div_drift(sys::ContinuousTimeDynamicalSystem, x) -> Any\ndiv_drift(sys::ContinuousTimeDynamicalSystem, x, t) -> Any\n\n\nComputes the divergence of the drift field f(x) at state x. For time- dependent systems, the time can be specified as a keyword argument t (by default t=0).\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#StochasticSystemsBase.covariance_matrix","page":"Utilities","title":"StochasticSystemsBase.covariance_matrix","text":"covariance_matrix(ds::CoupledSDEs)\n\nReturns the covariance matrix of the stochastic term of the CoupledSDEs ds, provided that the diffusion function g can be expressed as a constant invertible matrix. If this is not the case, returns nothing.\n\nSee also diffusion_matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#StochasticSystemsBase.diffusion_matrix","page":"Utilities","title":"StochasticSystemsBase.diffusion_matrix","text":"diffusion_matrix(ds::CoupledSDEs)\n\nReturns the diffusion matrix of the stochastic term of the CoupledSDEs ds, provided that the diffusion function g can be expressed as a constant invertible matrix. If this is not the case, returns nothing.\n\nNote: The diffusion matrix Σ is the square root of the noise covariance matrix Q (see covariance_matrix), defined via the Cholesky decomposition Q = Σ Σ^top.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#CriticalTransitions.noise_process","page":"Utilities","title":"CriticalTransitions.noise_process","text":"noise_process(sys::CoupledSDEs) -> Any\n\n\nFetches the stochastic process mathcalN specified in the intergrator of sys. Returns the type DiffEqNoiseProcess.NoiseProcess.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#More","page":"Utilities","title":"More","text":"","category":"section"},{"location":"man/utils/#CriticalTransitions.intervals_to_box","page":"Utilities","title":"CriticalTransitions.intervals_to_box","text":"intervals_to_box(bmin::Vector, bmax::Vector) -> Any\n\n\nGenerates a box from specifying the interval limits in each dimension.\n\nbmin (Vector): lower limit of the box in each dimension\nbmax (Vector): upper limit\n\nExample\n\nintervals_to_box([-2,-1,0], [2,1,1]) returns a 3D box of dimensions [-2,2] × [-1,1] × [0,1].\n\n\n\n\n\n","category":"function"},{"location":"man/tpt/#Transition-Path-Theory","page":"Transition path theory","title":"Transition Path Theory","text":"","category":"section"},{"location":"man/tpt/","page":"Transition path theory","title":"Transition path theory","text":"Transition Path Theory (TPT) provides a framework for analyzing rare transition events between metastable states in complex systems. This module implements TPT calculations for Langevin dynamics systems.","category":"page"},{"location":"man/tpt/#Theory-Overview","page":"Transition path theory","title":"Theory Overview","text":"","category":"section"},{"location":"man/tpt/","page":"Transition path theory","title":"Transition path theory","text":"TPT characterizes transition pathways between two metastable states A and B by computing:","category":"page"},{"location":"man/tpt/","page":"Transition path theory","title":"Transition path theory","text":"Forward and backward committor functions\nReactive probability density\nReactive current\nTransition rates","category":"page"},{"location":"man/tpt/","page":"Transition path theory","title":"Transition path theory","text":"The calculations are performed on a triangulated mesh representing the system's state space.","category":"page"},{"location":"man/tpt/#CriticalTransitions.Langevin","page":"Transition path theory","title":"CriticalTransitions.Langevin","text":"struct Langevin{H, D, KE, T}\n\nA struct representing a Langevin dynamical system with damping rate gammaand temperaturebeta``.\n\nFields\n\nHamiltonian::Any: Function that computes the total energy (kinetic + potential) of the system.\ndriftfree::Any: Function representing the divergence-free part of the drift.\nkinetic::Any: Function computing the kinetic energy of the system.\ngamma::Any: Damping coefficient that determines the strength of friction.\nbeta::Any: Inverse temperature parameter (β = 1/kT) that sets the noise intensity.\n\nConstructors\n\nLangevin(Hamiltonian, driftfree, kinetic, gamma, beta)\n\ndefined at /home/runner/work/CriticalTransitions.jl/CriticalTransitions.jl/src/transition_path_theory/langevin.jl:14.\n\n\n\n\n\n","category":"type"},{"location":"man/tpt/#Committor-Functions","page":"Transition path theory","title":"Committor Functions","text":"","category":"section"},{"location":"man/tpt/#CriticalTransitions.committor","page":"Transition path theory","title":"CriticalTransitions.committor","text":"committor(\n    sys::Langevin,\n    mesh::CriticalTransitions.Mesh,\n    Aind,\n    Bind\n) -> Vector{Float64}\n\n\nSolve the committor equation for a two-dimensional Langevin system using finite elements.\n\nArguments\n\nsys::Langevin: The Langevin system containing kinetic energy, drift-free function, beta, and gamma.\nmesh::Mesh: The mesh containing points and triangles.\nAind::Vector{Int}: Indices of mesh points corresponding to set A (Dirichlet boundary condition = 0).\nBind::Vector{Int}: Indices of mesh points corresponding to set B (Dirichlet boundary condition = 1).\n\nReturns\n\nA vector of committor values of length N, where each entry corresponds to a mesh node.\n\nImplementation Details\n\nThis function assembles a global matrix A and right-hand-side vector b for the finite element discretization of the committor equation in Langevin dynamics. The code imposes Dirichlet boundary conditions on specified nodes (Aind set to 0, Bind set to 1). It computes elementwise contributions with stima_Langevin and stimavbdv, applying exponential factors involving beta and gamma to incorporate potential and damping effects. Finally, it solves the resulting linear system for the committor values on the free (non-boundary) nodes.\n\n\n\n\n\n","category":"function"},{"location":"man/tpt/#Invariant-Probability-Density","page":"Transition path theory","title":"Invariant Probability Density","text":"","category":"section"},{"location":"man/tpt/#CriticalTransitions.invariant_pdf","page":"Transition path theory","title":"CriticalTransitions.invariant_pdf","text":"invariant_pdf(\n    sys::Langevin,\n    mesh::CriticalTransitions.Mesh,\n    Amesh::CriticalTransitions.Mesh,\n    Bmesh::CriticalTransitions.Mesh\n) -> Any\n\n\nCompute the invariant probability density function (PDF) for a Langevin system over a given mesh.\n\nArguments\n\nsys::Langevin: The Langevin system containing the Hamiltonian and beta parameters.\nmesh::Mesh: The main mesh containing points and triangles.\nAmesh::Mesh: The mesh corresponding to region A.\nBmesh::Mesh: The mesh corresponding to region B.\n\nReturns\n\nA scalar value representing the normalization constant Z of the invariant PDF.\n\nImplementation Details\n\nThis function calculates the invariant PDF by integrating the exponential of the negative Hamiltonian over the areas of the triangles in the provided meshes. The normalization constant Z is computed by summing the contributions from the main mesh, region A mesh, and region B mesh.\n\n\n\n\n\n","category":"function"},{"location":"man/tpt/#Reactive-Current","page":"Transition path theory","title":"Reactive Current","text":"","category":"section"},{"location":"man/tpt/","page":"Transition path theory","title":"Transition path theory","text":"reactive_current","category":"page"},{"location":"man/tpt/#Probability-Calculations","page":"Transition path theory","title":"Probability Calculations","text":"","category":"section"},{"location":"man/tpt/#CriticalTransitions.probability_reactive","page":"Transition path theory","title":"CriticalTransitions.probability_reactive","text":"probability_reactive(\n    sys::Langevin,\n    mesh::CriticalTransitions.Mesh,\n    q,\n    qminus,\n    Z\n) -> Any\n\n\nCalculate the probability that a trajectory is reactive (transitions from A to B).\n\nArguments\n\nsys::Langevin: System with Hamiltonian and inverse temperature (beta)\nmesh::Mesh: Mesh structure containing points and triangulation\nq: Forward committor function values\nqminus: Backward committor function values\nZ: Partition function value\n\nReturns\n\nProbability (float) of reactive trajectories normalized by partition function\n\n\n\n\n\n","category":"function"},{"location":"man/tpt/#CriticalTransitions.probability_last_A","page":"Transition path theory","title":"CriticalTransitions.probability_last_A","text":"probability_last_A(\n    sys::Langevin,\n    mesh::CriticalTransitions.Mesh,\n    Ames::CriticalTransitions.Mesh,\n    qminus,\n    Z\n) -> Any\n\n\nCalculate the probability that the last visited metastable state was A.\n\nArguments\n\nsys::Langevin: System with Hamiltonian and inverse temperature (beta)\nmesh::Mesh: Main mesh structure containing points and triangulation\nAmes::Mesh: Mesh structure for region A\nqminus: Backward committor function values\nZ: Partition function value\n\nReturns\n\nProbability (float) that the system was last in state A, normalized by partition function\n\n\n\n\n\n","category":"function"},{"location":"man/tpt/#References","page":"Transition path theory","title":"References","text":"","category":"section"},{"location":"man/tpt/","page":"Transition path theory","title":"Transition path theory","text":"W. E and E. Vanden-Eijnden, \"Towards a Theory of Transition Paths\", Journal of Statistical Physics, 2006","category":"page"},{"location":"examples/gMAM_Maierstein/#The-Maier-Stein-model.","page":"Anlyses of the Maier-Stein system","title":"The Maier-Stein model.","text":"","category":"section"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"using CriticalTransitions\n\nusing CairoMakie\nusing CairoMakie.Makie.MathTeXEngine: get_font\nfont = (;\n    regular=get_font(:regular),\n    bold=get_font(:bold),\n    italic=get_font(:italic),\n    bold_italic=get_font(:bolditalic),\n);\nnothing #hide","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"Let us explore the features of CriticalTransitions.jl with Maier-Stein model.","category":"page"},{"location":"examples/gMAM_Maierstein/#Maier-stein-model","page":"Anlyses of the Maier-Stein system","title":"Maier-stein model","text":"","category":"section"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"The Maier-Stein model (J. Stat. Phys 83, 3–4 (1996)) is commonly used in the field of nonlinear dynamics for benchmarking Large Deviation Theory (LDT) techniques, e.g., stoachastic transitions between different stable states. It is a simple model that describes the dynamics of a system with two degrees of freedom u and v, and is given by the following set of ordinary differential equations:","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"beginaligned\n    dotu = u-u^3 - beta*u*v^2\n    dotv = -alpha (1+u^2)*v\nendaligned","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"The parameter alpha0 controls the strength of the drift field and beta0 represents the softening of that drift field.","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"function meier_stein!(du, u, p, t) # in-place\n    x, y = u\n    du[1] = x - x^3 - 10 * x * y^2\n    return du[2] = -(1 + x^2) * y\nend\nfunction meier_stein(u, p, t) # out-of-place\n    x, y = u\n    dx = x - x^3 - 10 * x * y^2\n    dy = -(1 + x^2) * y\n    return SA[dx, dy]\nend\nσ = 0.25\nsys = CoupledSDEs(meier_stein, zeros(2), (); noise_strength=σ)","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"A good reference to read about the large deviations methods is this or this blog post by Tobias Grafke.","category":"page"},{"location":"examples/gMAM_Maierstein/#Attractors","page":"Anlyses of the Maier-Stein system","title":"Attractors","text":"","category":"section"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"We start by investigating the deterministic dynamics of the Maier-Stein model.","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"The function fixed points return the attractors, their eigenvalues and stability within the state space volume defined by bmin and bmax.","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"using ChaosTools\n\nu_min = -1.1;\nu_max = 1.1;\nv_min = -0.4;\nv_max = 0.4;\nbmin = [u_min, v_min];\nbmax = [u_max, v_max];\nfp, eig, stab = fixedpoints(sys, bmin, bmax)\nstable_fp = fp[stab]","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"using LinearAlgebra: norm\nres = 100\nu_range = range(u_min, u_max; length=res)\nv_range = range(v_min, v_max; length=res)\n\ndu(u, v) = u - u^3 - 10 * u * v^2\ndv(u, v) = -(1 + u^2) * v\nodeSol(u, v) = Point2f(du(u, v), dv(u, v))\n\nz = [norm([du(x, y), dv(x, y)]) for x in u_range, y in v_range]\nzmin, zmax = minimum(z), maximum(z)\n\nfig = Figure(; size=(600, 400), fontsize=13)\nax = Axis(\n    fig[1, 1];\n    xlabel=\"u\",\n    ylabel=\"v\",\n    aspect=1.4,\n    xgridcolor=:transparent,\n    ygridcolor=:transparent,\n    ylabelrotation=0,\n)\n\nhm = heatmap!(ax, u_range, v_range, z; colormap=:Blues, colorrange=(zmin, zmax))\nColorbar(fig[1, 2], hm; label=\"\", width=15, ticksize=15, tickalign=1)\nstreamplot!(\n    ax,\n    odeSol,\n    (u_min, u_max),\n    (v_min, v_max);\n    gridsize=(20, 20),\n    arrow_size=10,\n    stepsize=0.01,\n    colormap=[:black, :black],\n)\ncolgap!(fig.layout, 7)\nlimits!(u_min, u_max, v_min, v_max)\nfig\n\n[\n    scatter!(ax, Point(fp[i]); color=stab[i] > 0 ? :red : :dodgerblue, markersize=10) for\n    i in eachindex(fp)\n]\nfig","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"We can simulate a stochastic trajectory using the function trajectory.","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"tr, ts = trajectory(sys, 1000)\n\nfig = Figure(; size=(1000, 400), fontsize=13)\nax1 = Axis(\n    fig[1, 1];\n    xlabel=\"t\",\n    ylabel=\"u\",\n    aspect=1.2,\n    xgridcolor=:transparent,\n    ygridcolor=:transparent,\n    ylabelrotation=0,\n)\nax2 = Axis(\n    fig[1, 2];\n    xlabel=\"u\",\n    ylabel=\"v\",\n    aspect=1.2,\n    xgridcolor=:transparent,\n    ygridcolor=:transparent,\n    ylabelrotation=0,\n)\n\nlines!(ax1, ts, first.(tr); linewidth=2, color=:black)\n\nhm = heatmap!(ax2, u_range, v_range, z; colormap=:Blues, colorrange=(zmin, zmax))\nColorbar(fig[1, 3], hm; label=\"\", width=15, ticksize=15, tickalign=1)\nstreamplot!(\n    ax2,\n    odeSol,\n    (u_min, u_max),\n    (v_min, v_max);\n    gridsize=(20, 20),\n    arrow_size=10,\n    stepsize=0.01,\n    colormap=[:white, :white],\n)\ncolgap!(fig.layout, 7)\nlimits!(u_min, u_max, v_min, v_max)\nfig\n\n[\n    scatter!(ax2, Point(fp[i]); color=stab[i] > 0 ? :red : :dodgerblue, markersize=10) for\n    i in eachindex(fp)\n]\n\nlines!(ax2, reduce(hcat, tr); linewidth=1, color=(:black, 0.2))\nfig","category":"page"},{"location":"examples/gMAM_Maierstein/#Transitions","page":"Anlyses of the Maier-Stein system","title":"Transitions","text":"","category":"section"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"We can quickly find a path which computes a transition from one attractor to another using the function `transition.","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"paths_ends = (fp[stab][1], fp[stab][2])\npath, time, success = transition(sys, paths_ends...);\nnothing #hide","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"fig = Figure(; size=(600, 400), fontsize=13)\nax = Axis(\n    fig[1, 1];\n    xlabel=\"u\",\n    ylabel=\"v\",\n    aspect=1.4,\n    xgridcolor=:transparent,\n    ygridcolor=:transparent,\n    ylabelrotation=0,\n)\n\nhm = heatmap!(ax, u_range, v_range, z; colormap=:Blues, colorrange=(zmin, zmax))\nColorbar(fig[1, 2], hm; label=\"\", width=15, ticksize=15, tickalign=1)\nstreamplot!(\n    ax,\n    odeSol,\n    (u_min, u_max),\n    (v_min, v_max);\n    gridsize=(20, 20),\n    arrow_size=10,\n    stepsize=0.01,\n    colormap=[:white, :white],\n)\ncolgap!(fig.layout, 7)\nlimits!(u_min, u_max, v_min, v_max)\nfig\n\n[\n    scatter!(ax, Point(fp[i]); color=stab[i] > 0 ? :red : :dodgerblue, markersize=10) for\n    i in eachindex(fp)\n]\nfig\n\nlines!(ax, path; color=:black)\nfig","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"If we want to compute many: transitions is the function to use.","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"tt = transitions(sys, paths_ends..., 3; tmax=1e3);\nnothing #hide","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"fig = Figure(; size=(600, 400), fontsize=13)\nax = Axis(\n    fig[1, 1];\n    xlabel=\"u\",\n    ylabel=\"v\",\n    aspect=1.4,\n    xgridcolor=:transparent,\n    ygridcolor=:transparent,\n    ylabelrotation=0,\n)\n\nhm = heatmap!(ax, u_range, v_range, z; colormap=:Blues, colorrange=(zmin, zmax))\nColorbar(fig[1, 2], hm; label=\"\", width=15, ticksize=15, tickalign=1)\nstreamplot!(\n    ax,\n    odeSol,\n    (u_min, u_max),\n    (v_min, v_max);\n    gridsize=(20, 20),\n    arrow_size=10,\n    stepsize=0.01,\n    colormap=[:black, :black],\n)\ncolgap!(fig.layout, 7)\nlimits!(u_min, u_max, v_min, v_max)\nfig\n\n[\n    scatter!(ax, Point(fp[i]); color=stab[i] > 0 ? :red : :dodgerblue, markersize=10) for\n    i in eachindex(fp)\n]\n\nfor i in 1:length(tt.paths)\n    lines!(ax, tt.paths[i])\nend\nfig","category":"page"},{"location":"examples/gMAM_Maierstein/#Large-deviation-theory","page":"Anlyses of the Maier-Stein system","title":"Large deviation theory","text":"","category":"section"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"In the context of nonlinear dynamics, Large Deviation Theory provides tools to quantify the probability of rare events that deviate significantly from the system's typical behavior. These rare events might be extreme values of a system's output, sudden transitions between different states, or other phenomena that occur with very low probability but can have significant implications for the system's overall behavior.","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"Large deviation theory applies principles from probability theory and statistical mechanics to develop a rigorous mathematical description of these rare events. It uses the concept of a rate function, which measures the exponential decay rate of the probability of large deviations from the mean or typical behavior. This rate function plays a crucial role in quantifying the likelihood of rare events and understanding their impact on the system.","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"For example, in a system exhibiting chaotic behavior, LDT can help quantify the probability of sudden large shifts in the system's trajectory. Similarly, in a system with multiple stable states, it can provide insight into the likelihood and pathways of transitions between these states under fluctuations. In the context of the Minimum Action Method (MAM) and the Geometric Minimum Action Method (gMAM), Large Deviation Theory is used to handle the large deviations action functional on the space of curves. This is a key part of how these methods analyze dynamical systems.","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"The Maier-Stein model is a typical benchmark to test such LDT techniques. Let us try to reproduce the following figure from Tobias Grafke's blog post:","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"(Image: maier_stein)","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"Let us first make an initial path:","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"xx = range(-1.0, 1.0; length=100)\nyy = 0.3 .* (-xx .^ 2 .+ 1)\ninit = Matrix([xx yy]')","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"geometric_min_action_method computes the minimizer of the Freidlin-Wentzell action using the geometric minimum action method (gMAM), to find the minimum action path (instanton) between an initial state xi and final state xf. The Minimum Action Method (MAM) is a more traditional approach, while the Geometric Minimum Action Method (gMAM) is a blend of the original MAM and the string method.","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"gm = geometric_min_action_method(sys, init; maxiter=500, show_progress=false)\nMLP = gm.path","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"fig = Figure(; size=(600, 400), fontsize=13)\nax = Axis(\n    fig[1, 1];\n    xlabel=\"u\",\n    ylabel=\"v\",\n    aspect=1.4,\n    xgridcolor=:transparent,\n    ygridcolor=:transparent,\n    ylabelrotation=0,\n)\n\nhm = heatmap!(ax, u_range, v_range, z; colormap=:Blues, colorrange=(zmin, zmax))\nColorbar(fig[1, 2], hm; label=\"\", width=15, ticksize=15, tickalign=1)\nstreamplot!(\n    ax,\n    odeSol,\n    (u_min, u_max),\n    (v_min, v_max);\n    gridsize=(20, 20),\n    arrow_size=10,\n    stepsize=0.01,\n    colormap=[:black, :black],\n)\ncolgap!(fig.layout, 7)\nlimits!(u_min, u_max, v_min, v_max)\nfig\n\n[\n    scatter!(ax, Point(fp[i]); color=stab[i] > 0 ? :red : :dodgerblue, markersize=10) for\n    i in eachindex(fp)\n]\n\nlines!(ax, init; linewidth=3, color=:black, linestyle=:dash)\nlines!(ax, MLP; linewidth=3, color=:orange)\nfig","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"","category":"page"},{"location":"examples/gMAM_Maierstein/","page":"Anlyses of the Maier-Stein system","title":"Anlyses of the Maier-Stein system","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/largedeviations/#Large-deviation-theory","page":"Large deviation theory","title":"Large deviation theory","text":"","category":"section"},{"location":"man/largedeviations/#Mimumum-action-path","page":"Large deviation theory","title":"Mimumum action path","text":"","category":"section"},{"location":"man/largedeviations/#CriticalTransitions.MinimumActionPath","page":"Large deviation theory","title":"CriticalTransitions.MinimumActionPath","text":"struct MinimumActionPath{D, T<:Real, V, Phis, Ahis, Lambda, PV, GPV}\n\nThe minimum action path between two points in a D-dimensional phase space.\n\nFields\n\npath::StateSpaceSet{D, T, V} where {D, T<:Real, V}: The path matrix.\naction::Real: The action value associated to the path.\npath_history::Any: The history of action of the paths in the optimisation algorithm (optional).\naction_history::Any: The history of action of the paths in the optimisation algorithm (optional).\nλ::Any: The Lagrange multiplier parameter for the minimum action path (optional).\ngeneralized_momentum::Any: The generalized momentum of the phase space variables (optional).\npath_velocity::Any: The path velocity (optional).\n\nConstructors\n\nMinimumActionPath(\n    path,\n    action;\n    path_history,\n    action_history,\n    λ,\n    generalized_momentum,\n    path_velocity\n)\n\ndefined at /home/runner/work/CriticalTransitions.jl/CriticalTransitions.jl/src/largedeviations/MinimumActionPath.jl:29.\n\n\n\n\n\n","category":"type"},{"location":"man/largedeviations/#String-method","page":"Large deviation theory","title":"String method","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"The string method is a technique for finding transition paths between two states in a dynamical system. The method represents the path as a \"string\" of points that connects the states and evolves it to minimize the drift along the path. The resulating  tangent path is parallel to the drift of the system, i.e., the string method computes the heteroclinic orbit. For non-gradient systems (detailed -balance is broken), the heteroclinic orbit differs from the transition path, it does correctly predict, it correctly captures the deterministic dynamics from the saddle point onward (\"downhill\" portion of the path).","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.string_method","page":"Large deviation theory","title":"CriticalTransitions.string_method","text":"string_method(\n    sys::Union{Function, ExtendedHamiltonianSystem},\n    x_initial::Matrix;\n    ϵ,\n    iterations,\n    show_progress\n) -> Any\n\n\nCompute the string method for a given system using E et al. (2007).\n\nThe string method is an iterative algorithm used to find minimum energy path (MEP) between two points in phase space. It works by evolving a discretized path (string) according to the system's drift while maintaining equal arc-length parametrization between points.\n\nThis implementation allows for computation between arbitrary points, not just stable fixed points.\n\nArguments\n\nsys::ExtendedHamiltonianSystem: The doubled phase space system for which the string method is computed\nx_initial: Initial path discretized as a matrix where each column represents a point on the path\nϵ::Real: Step size for the evolution step\niterations::Int64: Maximum number of iterations for path convergence\nshow_progress::Bool: Whether to display a progress meter during computation\n\nReturns\n\nx: The final converged path representing the MEP\n\n\n\n\n\nstring_method(\n    sys::ContinuousTimeDynamicalSystem,\n    init;\n    kwargs...\n) -> Any\n\n\nCompute the string method for a given system using E et al. (2007).\n\nThe string method is an iterative algorithm used to find minimum energy path (MEP) between two points in phase space. It works by evolving a discretized path (string) according to the system's drift while maintaining equal arc-length parametrization between points.\n\nThis implementation allows for computation between arbitrary points, not just stable fixed points.\n\nArguments\n\nsys::CoupledSDEs: The system for which the string method is computed\nx_initial: Initial path discretized as a matrix where each column represents a point on the path\nϵ::Real: Step size for the evolution step\niterations::Int64: Maximum number of iterations for path convergence\nshow_progress::Bool: Whether to display a progress meter during computation\n\nReturns\n\nx: The final converged path representing the MEP\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Minimum-action-methods","page":"Large deviation theory","title":"Minimum action methods","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"The minimum action method (MAM) is a technique for calculating the most probable transition path between two (meta)stable states in a stochastic dynamical system. In the limit of small noise, this path corresponds to the minimizer of an action functional. The action functional typically takes into account both the deterministic drift and the noise intensity of the system. By discretizing this path and using optimization techniques, MAM finds the trajectory that requires the least \"effort\" to transition between states in phase space.","category":"page"},{"location":"man/largedeviations/#Minimum-action-method-(MAM)","page":"Large deviation theory","title":"Minimum action method (MAM)","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"Minimization of the action functioal using the optimization algorithm of Optimization.jl.","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.min_action_method","page":"Large deviation theory","title":"CriticalTransitions.min_action_method","text":"min_action_method(sys::ContinuousTimeDynamicalSystem, x_i, x_f, T::Real; kwargs...)\n\nMinimizes an action functional to obtain a minimum action path (instanton) between an initial state x_i and final state x_f in phase space.\n\nThis algorithm uses the Optimization.jl package to minimize the specified action functional (either fw_action or om_action) for the system sys over paths connecting x_i to x_f in time T.\n\nThe path is initialized as a straight line between x_i and x_f, parameterized in time via N equidistant points and total time T. Thus, the time step between discretized path points is Delta t = TN. To set an initial path different from a straight line, see the multiple dispatch method\n\nmin_action_method(sys::ContinuousTimeDynamicalSystem, init::Matrix, T::Real; kwargs...).\n\nReturns a MinimumActionPath object containing the optimized path and the action value.\n\nKeyword arguments\n\nfunctional = \"FW\": type of action functional to minimize. Defaults to fw_action, alternative: \"OM\" for om_action.\nN = 100: number of path points to use for the discretization of the path.\nnoise_strength = nothing: noise strength for the action functional. Specify only if functional = \"OM\".\nmethod = Optimisers.Adam(): minimization algorithm (see Optimization.jl)\nad_type = Optimization.AutoFiniteDiff(): type of automatic differentiation to use (see Optimization.jl)\nmaxiter = 100: maximum number of iterations before the algorithm stops.\nabstol=1e-8: absolute tolerance of action gradient to determine convergence\nreltol=1e-8: relative tolerance of action gradient to determine convergence\nverbose = true: whether to print Optimization information during the run\nshow_progress = false: whether to print a progress bar\n\n\n\n\n\nmin_action_method(sys::ContinuousTimeDynamicalSystem, init::Matrix, T::Real; kwargs...)\n\nMinimizes the specified action functional to obtain a minimum action path (instanton) between fixed end points given a system sys and total path time T.\n\nThe initial path init must be a matrix of size (D, N), where D is the dimension of the system and N is the number of path points. The physical time of the path is specified by T, such that the time step between consecutive path points is Delta t = TN.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Geometric-minimum-action-method-(gMAM)","page":"Large deviation theory","title":"Geometric minimum action method (gMAM)","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"Minimization of the geometric action following Heymann and Vanden-Eijnden, PRL (2008). The gMAM reformulates MAM to avoid double optimisation of both the action and the transition time. It achieves this by using a geometric action functional that is independent of the time parametrization of the path. This reparameterization invariance makes the method more robust and computationally efficient, particularly for systems with metastable states separated by large barriers.","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.geometric_min_action_method","page":"Large deviation theory","title":"CriticalTransitions.geometric_min_action_method","text":"geometric_min_action_method(\n    sys::ContinuousTimeDynamicalSystem,\n    x_i,\n    x_f;\n    N,\n    kwargs...\n) -> MinimumActionPath{_A, _B, _C, Nothing, Nothing, Nothing, Nothing, Nothing} where {_A, _B<:Real, _C}\n\n\nComputes the minimizer of the geometric Freidlin-Wentzell action based on the geometric minimum action method (gMAM), using optimizers of OPtimization.jl or the original formulation by Heymann and Vanden-Eijnden[1]. Only Freidlin-Wentzell action has a geometric formulation.\n\nTo set an initial path different from a straight line, see the multiple dispatch method\n\ngeometric_min_action_method(sys::CoupledSDEs, init::Matrix, arclength::Real; kwargs...).\n\nKeyword arguments\n\nmaxiter::Int=100: maximum number of optimization iterations before the algorithm stops\nabstol=1e-8: absolute tolerance of action gradient to determine convergence\nreltol=1e-8: relative tolerance of action gradient to determine convergence\nmethod = Adam(): minimization algorithm (see Optimization.jl)\n=0.1: step size parameter in gradient descent HeymannVandenEijnden implementation.\nverbose=false: if true, print additional output\nshow_progress=true: if true, display a progress bar\n\nOptimization algorithms\n\nThe method keyword argument takes solver methods of the Optimization.jl package; alternatively, the option solver = \"HeymannVandenEijnden\" uses the original gMAM algorithm[1].\n\n[1]: Heymann and Vanden-Eijnden, PRL (2008)\n\n\n\n\n\ngeometric_min_action_method(\n    sys::ContinuousTimeDynamicalSystem,\n    init::Matrix;\n    maxiter,\n    abstol,\n    reltol,\n    method,\n    AD,\n    ϵ,\n    verbose,\n    show_progress\n) -> MinimumActionPath{_A, _B, _C, Nothing, Nothing, Nothing, Nothing, Nothing} where {_A, _B<:Real, _C}\n\n\nRuns the geometric Minimum Action Method (gMAM) to find the minimum action path (instanton) from an initial condition init, given a system sys and total arc length arclength.\n\nThe initial path init must be a matrix of size (D, N), where D is the dimension of the system and N is the number of path points.\n\nFor more information see the main method, geometric_min_action_method(sys::CoupledSDEs, x_i, x_f, arclength::Real; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Simple-Geometric-minimum-action-method-(sgMAM)","page":"Large deviation theory","title":"Simple Geometric minimum action method (sgMAM)","text":"","category":"section"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"Simplified minimization of the geometric action following Grafke et al. (2017). The simple gMAM reduces the complexity of the original gMAM by requiring only first-order derivatives of the underlying Hamiltonian optimisation formulation. This simplifies the numerical treatment and the computational complexity.","category":"page"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"The implementation below perform a constrained gradient descent where it assumes an autonomous system with additive Gaussian noise.","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.simple_geometric_min_action_method","page":"Large deviation theory","title":"CriticalTransitions.simple_geometric_min_action_method","text":"simple_geometric_min_action_method(\n    sys::ExtendedHamiltonianSystem,\n    x_initial::Array{T, 2};\n    ϵ,\n    iterations,\n    show_progress,\n    reltol\n) -> MinimumActionPath{_A, _B, _C, Nothing, Nothing, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}} where {_A, _B<:Real, _C}\n\n\nPerforms the simplified geometric Minimal Action Method (sgMAM) on the given system sys. Our implementation is only valid for additive noise.\n\nThis method computes the optimal path in the phase space of a Hamiltonian system that minimizes the Freidlin–Wentzell action. The Hamiltonian functions H_x and H_p define the system's dynamics in a doubled phase. The initial state x_initial is evolved iteratively using constrained gradient descent with step size parameter ϵ over a specified number of iterations. The method can display a progress meter and will stop early if the relative tolerance reltol is achieved.\n\nThe function returns a tuple containing the final state, the action value, the Lagrange multipliers, the momentum, and the state derivatives. The implementation is based on the work of Grafke et al. (2019).\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#CriticalTransitions.ExtendedHamiltonianSystem","page":"Large deviation theory","title":"CriticalTransitions.ExtendedHamiltonianSystem","text":"A structure representing a system with Hamiltonian functions Hx and Hp.\n\nThis system operates in an extended phase space where the Hamiltonian is assumed to be quadratic in the extended momentum. The phase space coordinates x are doubled to form a 2n-dimensional extended phase space.\n\n\n\n\n\n","category":"type"},{"location":"man/largedeviations/#Action-functionals","page":"Large deviation theory","title":"Action functionals","text":"","category":"section"},{"location":"man/largedeviations/#Freidlin-Wentzell-action","page":"Large deviation theory","title":"Freidlin-Wentzell action","text":"","category":"section"},{"location":"man/largedeviations/#CriticalTransitions.fw_action","page":"Large deviation theory","title":"CriticalTransitions.fw_action","text":"fw_action(sys::CoupledSDEs, path, time) -> Any\n\n\nCalculates the Freidlin-Wentzell action of a given path with time points time in a drift field specified by the deterministic dynamics f = dynamic_rule(sys) and (normalized) noise covariance matrix covariance_matrix(sys).\n\nThe path must be a (D x N) matrix, where D is the dimensionality of the system sys and N is the number of path points. The time array must have length N.\n\nReturns a single number, which is the value of the action functional\n\nS_Tphi_t = frac12 int_0^T  dot phi_t - f(phi_t) ^2_Q textdt\n\nwhere phi_t denotes the path in state space, b the drift field, and T the total time of the path. The subscript Q refers to the generalized norm a_Q^2 = langle a Q^-1 b rangle (see anorm). Here Q is the noise covariance matrix normalized by DL_1(Q), with L_1 being the L1 matrix norm.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Geometric-Freidlin-Wentzell-action","page":"Large deviation theory","title":"Geometric Freidlin-Wentzell action","text":"","category":"section"},{"location":"man/largedeviations/#CriticalTransitions.geometric_action","page":"Large deviation theory","title":"CriticalTransitions.geometric_action","text":"geometric_action(sys::CoupledSDEs, path) -> Any\ngeometric_action(sys::CoupledSDEs, path, arclength) -> Any\n\n\nCalculates the geometric action of a given path with specified arclength for the drift field specified by the deterministic dynamics f = dynamic_rule(sys) and (normalized) noise covariance matrix covariance_matrix(sys).\n\nFor a given path varphi, the geometric action bar S corresponds to the minimum of the Freidlin-Wentzell action S_T(varphi) over all travel times T0, where varphi denotes the path's parameterization in physical time (see fw_action). It is given by the integral\n\nbar Svarphi = int_0^L left( varphi_Q  f(varphi)_Q - langle varphi      f(varphi) rangle_Q right)  textds\n\nwhere s is the arclength coordinate, L the arclength, f the drift field, and the subscript Q refers to the generalized dot product langle a b rangle_Q = a^top cdot Q^-1 b (see anorm). Here Q is the noise covariance matrix normalized by DL_1(Q), with L_1 being the L1 matrix norm.\n\nReturns the value of the geometric action bar S.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#Onsager-Machlup-action","page":"Large deviation theory","title":"Onsager-Machlup action","text":"","category":"section"},{"location":"man/largedeviations/#CriticalTransitions.om_action","page":"Large deviation theory","title":"CriticalTransitions.om_action","text":"om_action(sys::CoupledSDEs, path, time, noise_strength)\n\nCalculates the Onsager-Machlup action of a given path with time points time for the drift field f = dynamic_rule(sys) at given noise_strength.\n\nThe path must be a (D x N) matrix, where D is the dimensionality of the system sys and N is the number of path points. The time array must have length N.\n\nReturns a single number, which is the value of the action functional\n\nS^sigma_Tphi_t = frac12 int_0^T left(  dot phi_t - f(phi_t) ^2_Q + sigma^2 nabla cdot f right)  textd t\n\nwhere phi_t denotes the path in state space, b the drift field, T the total time of the path, and sigma the noise strength. The subscript Q refers to the generalized norm a_Q^2 = langle a Q^-1 b rangle (see anorm). Here Q is the noise covariance matrix normalized by DL_1(Q), with L_1 being the L1 matrix norm.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/","page":"Large deviation theory","title":"Large deviation theory","text":"For convenience, a general action function is available where the type of functional is set as an argument:","category":"page"},{"location":"man/largedeviations/#CriticalTransitions.action","page":"Large deviation theory","title":"CriticalTransitions.action","text":"action(\n    sys::CoupledSDEs,\n    path::Matrix,\n    time,\n    functional;\n    noise_strength\n) -> Any\n\n\nComputes the action functional specified by functional for a given CoupledSDEs sys and path parameterized by time.\n\nfunctional = \"FW\": Returns the Freidlin-Wentzell action (fw_action)\nfunctional = \"OM\": Returns the Onsager-Machlup action (om_action)\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#Analyzing-a-system's-stability-properties","page":"Stability analysis","title":"Analyzing a system's stability properties","text":"","category":"section"},{"location":"man/systemanalysis/","page":"Stability analysis","title":"Stability analysis","text":"To use the following functionalities, you need to load ChoasTools.jl and Attractors.jl.","category":"page"},{"location":"man/systemanalysis/#Fixed-points","page":"Stability analysis","title":"Fixed points","text":"","category":"section"},{"location":"man/systemanalysis/#ChaosTools.fixedpoints","page":"Stability analysis","title":"ChaosTools.fixedpoints","text":"fixedpoints(\n    sys::CoupledSDEs,\n    bmin::Vector,\n    bmax::Vector\n) -> Tuple{StateSpaceSet, Vector{Vector{ComplexF64}}, Vector{Bool}}\n\n\nReturns fixed points, their eigenvalues and stability of the system sys within the state space volume defined by bmin and bmax.\n\nThis is a wrapper around the fixedpoints function of DynamicalSystems.jl.\n\nInput\n\nbmin (Vector): lower limits of the state space box to be considered, as a vector of coordinates\nbmax (Vector): upper limits\nalternatively box (IntervalBox) can replace bmin and bmax\n\nExample: fixedpoints(sys, [-2,-1,0], [2,1,1]) finds the fixed points of the 3D system sys in a cube defined by the intervals [-2,2] × [-1,1] × [0,1].\n\nOutput\n\n[fp, eigs, stable]\n\nfp: StateSpaceSet of fixed points\neigs: vector of Jacobian eigenvalues of each fixed point\nstable: vector of booleans indicating the stability of each fixed point (true=stable, false=unstable)\n\nAdditional methods\n\nfixedpoints(sys::CoupedSDEs, box)\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#Edge-tracking","page":"Stability analysis","title":"Edge tracking","text":"","category":"section"},{"location":"man/systemanalysis/","page":"Stability analysis","title":"Stability analysis","text":"The edge tracking algorithm is a simple numerical method to find the edge state or (possibly chaotic) saddle on the boundary between two basins of attraction. It is first introduced by Battelino et al. (1988) and further described by Skufca et al. (2006).","category":"page"},{"location":"man/systemanalysis/#Attractors.edgetracking","page":"Stability analysis","title":"Attractors.edgetracking","text":"edgetracking(ds::CoupledSDEs, attractors::Dict; diffeq, kwars...)\n\nRuns the edge tracking algorithm for the deterministic part of the CoupledSDEs ds.\n\nKeyword arguments\n\ndiffeq=(;alg = Vern9(), reltol=1e-11): ODE solver settings\nkwargs...: all keyword arguments of Attractors.edgetracking\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#Attractors.bisect_to_edge","page":"Stability analysis","title":"Attractors.bisect_to_edge","text":"bisect_to_edge(ds::CoupledSDEs, attractors::Dict;\n    u1, u2, bisect_thresh, diffeq, verbose, kwargs...)\n\nRuns the bisect_to_edge function for the deterministic part of the CoupledSDEs ds.\n\nKeyword arguments\n\nu1: State 1 (default: first state in attractors)\nu2: State 2 (default: second state in attractors)\nbisect_thresh=1e-6: distance threshold\ndiffeq=(;alg = Vern9(), reltol=1e-11): ODE solver settings\nverbose=false: Verbosity of output\nϵ_mapper=nothing: ϵ argument of Attractors.AttractorsViaProximity\nkwargs...: Keyword arguments passed to Attractors.AttractorsViaProximity\n\n\n\n\n\n","category":"function"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"We demonstrate the simple geometric minimum action method (sgMAM) on the Kerr parametric oscillator (KPO). The method computes the optimal path between two attractors in the phase space that minimizes the action of the system. It is a simplification of the geometric minimum action method (gMAM) by avoiding the computation of the second order derivatives of the extended Hamiltonian of the optimisation problem.","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"using CriticalTransitions, CairoMakie","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"The KPO equation is a nonlinear ordinary differential equation that describes the response of the nonlinear parametrically driven resonator at its dominant resonant condition. The equation of motion are of the form:","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"dotmathbfx = mathbff(mathbfx) + sigmamathbfξ(t)","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"where f is an autonemous drift function and and we have brownian noise ξ with intensity σ.","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"Here we define the define the drift of each separable variable u and v. In addition, we hard-code the Jacobian of the drift function.","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"const λ = 3 / 1.21 * 2 / 295\nconst ω0 = 1.000\nconst ω = 1.000\nconst γ = 1 / 295\nconst η = 0\nconst α = -1\n\nfunction fu(u, v)\n    return (-4 * γ * ω * u - 2 * λ * v - 4 * (ω0 - ω^2) * v - 3 * α * v * (u^2 + v^2)) /\n           (8 * ω)\nend\nfunction fv(u, v)\n    return (-4 * γ * ω * v - 2 * λ * u + 4 * (ω0 - ω^2) * u + 3 * α * u * (u^2 + v^2)) /\n           (8 * ω)\nend\nstream(u, v) = Point2f(fu(u, v), fv(u, v))\ndfvdv(u, v) = (-4 * γ * ω + 6 * α * u * v) / (8 * ω)\ndfudu(u, v) = (-4 * γ * ω - 6 * α * u * v) / (8 * ω)\ndfvdu(u, v) = (-2 * λ + 4 * (ω0 - ω^2) + 9 * α * u^2 + 3 * α * v^2) / (8 * ω)\ndfudv(u, v) = (-2 * λ - 4 * (ω0 - ω^2) - 3 * α * u^2 - 9 * α * v^2) / (8 * ω)","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"The optimisation is performed in a doubled phase space, i.e., every variable of the SDE system is considered as a generelised coordinate mathbfx and gets a corresponding generalised momentum mathbfp. The makes it that also systems with dissipative flow can be solved. As such, we extend the phase space by defining the hamiltionian","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"H = sum_i fracp_i^22 + f_i(mathbfx)p_i","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"Hence, to use the sgMAM method, we need to define the derivatives of the Hamiltonian with respect to the phase space coordinates and the generalised momentum:","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"function H_x(x, p) # ℜ² → ℜ²\n    u, v = eachrow(x)\n    pu, pv = eachrow(p)\n\n    H_u = @. pu * dfudu(u, v) + pv * dfvdu(u, v)\n    H_v = @. pu * dfudv(u, v) + pv * dfvdv(u, v)\n    return Matrix([H_u H_v]')\nend\nfunction H_p(x, p) # ℜ² → ℜ²\n    u, v = eachrow(x)\n    pu, pv = eachrow(p)\n\n    H_pu = @. pu + fu(u, v)\n    H_pv = @. pv + fv(u, v)\n    return Matrix([H_pu H_pv]')\nend\n\nsys = ExtendedHamiltonianSystem{false,2}(H_x, H_p)","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"We saved this function in the ExtendedHamiltonianSystem struct. We want to find the optimal path between two attractors in the phase space. We define the initial trajectory as wiggle between the two attractors.","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"Nt = 500  # number of discrete time steps\ns = collect(range(0; stop=1, length=Nt))\n\nxa = [-0.0208, 0.0991]\nxb = -xa\nxsaddle = [0.0, 0.0]","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"Initial trajectory","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"xx = @. (xb[1] - xa[1]) * s + xa[1] + 4 * s * (1 - s) * xsaddle[1]\nyy = @. (xb[2] - xa[2]) * s + xa[2] + 4 * s * (1 - s) * xsaddle[2] + 0.01 * sin(2π * s)\nx_initial = Matrix([xx yy]')","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"The optimisation is the performed by the simple_geometric_min_action_method function:","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"MLP = simple_geometric_min_action_method(sys, x_initial; iterations=1_000, ϵ=10e2, show_progress=false)\nx_min = MLP.path;\nnothing #hide","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"The function returns the optimal path x_min, the minimal action S_min, the Lagrange multipliers lambda associated with the optimal path, the optimal generalised momentum p, and the time derivative of the optimal path xdot. We can plot the initial trajectory and the optimal path:","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"fig, ax, _ = lines(\n    x_initial[1, :], x_initial[2, :]; label=\"init\", linewidth=3, color=:black\n)\nlines!(x_min[:, 1], x_min[:, 2]; label=\"MLP\", linewidth=3, color=:red)\nstreamplot!(\n    ax,\n    stream,\n    (-0.08, 0.08),\n    (-0.15, 0.15);\n    gridsize=(20, 20),\n    arrow_size=10,\n    stepsize=0.001,\n    colormap=[:gray, :gray],\n)\naxislegend(ax)\nfig","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"","category":"page"},{"location":"examples/sgMAM_KPO/","page":"sgMAM for the Kerr Parametric Oscillator","title":"sgMAM for the Kerr Parametric Oscillator","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/OC_mam/#Minimal-Action-Method-using-Optimal-Control","page":"Minimal action method as an Optimal Control problem","title":"Minimal Action Method using Optimal Control","text":"","category":"section"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"The Minimal Action Method is a numerical technique for finding the most probable transition pathway between stable states in stochastic dynamical systems. It achieves this by minimizing an action functional that represents the path's deviation from the deterministic dynamics, effectively identifying the path of least resistance through the system's landscape. This tutorial demonstrates how to implement MAM as an optimal control problem.","category":"page"},{"location":"examples/OC_mam/#Required-Packages","page":"Minimal action method as an Optimal Control problem","title":"Required Packages","text":"","category":"section"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots, Printf","category":"page"},{"location":"examples/OC_mam/#Problem-Setup","page":"Minimal action method as an Optimal Control problem","title":"Problem Setup","text":"","category":"section"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"We'll consider a 2D system with a double-well flow, called the Maier-Stein model. It is a famous benchmark problem as it exhibits non-gradient dynamics with two stable equilibrium points at (-1,0) and (1,0), connected by a non-trivial transition path. The system's deterministic dynamics are given by:","category":"page"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"Define the vector field","category":"page"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"f(u, v) = [u - u^3 - 10*u*v^2, -(1 - u^2)*v]\nf(x) = f(x...)\nnothing # hide","category":"page"},{"location":"examples/OC_mam/#Optimal-Control-Formulation","page":"Minimal action method as an Optimal Control problem","title":"Optimal Control Formulation","text":"","category":"section"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"The minimal action path minimizes the deviation from the deterministic dynamics:","category":"page"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"function ocp(T)\n    action = @def begin\n        t ∈ [0, T], time\n        x ∈ R², state\n        u ∈ R², control\n        x(0) == [-1, 0]    # Starting point (left well)\n        x(T) == [1, 0]     # End point (right well)\n        ẋ(t) == u(t)       # Path dynamics\n        ∫(sum((u(t) - f(x(t))) .^ 2)) → min  # Minimize deviation from deterministic flow\n    end\n    return action\nend\nnothing # hide","category":"page"},{"location":"examples/OC_mam/#Initial-Guess","page":"Minimal action method as an Optimal Control problem","title":"Initial Guess","text":"","category":"section"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"We provide an initial guess for the path using a simple interpolation:","category":"page"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"T = 50 # Time horizon\n\nx1(t) = -(1 - t/T) + t/T # Linear interpolation for x₁\nx2(t) = 0.3(-x1(t)^2 + 1) # Parabolic guess for x₂\n\nx(t) = [x1(t), x2(t)]\nu(t) = f(x(t))\n\ninit = (state=x, control=u) # Initial guess\nnothing # hide","category":"page"},{"location":"examples/OC_mam/#Solving-the-Problem","page":"Minimal action method as an Optimal Control problem","title":"Solving the Problem","text":"","category":"section"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"We solve the problem in two steps for better accuracy:","category":"page"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"sol = solve(ocp(T); init=init, grid_size=50) # First solve with coarse grid\nsol = solve(ocp(T); init=sol, grid_size=1000) # Refine solution\nobjective(sol) # Objective value","category":"page"},{"location":"examples/OC_mam/#Visualizing-Results","page":"Minimal action method as an Optimal Control problem","title":"Visualizing Results","text":"","category":"section"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"Let's plot the solution trajectory and phase space:","category":"page"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"plot(sol)","category":"page"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"MLP = state(sol).(time_grid(sol))\nscatter(\n    first.(MLP),\n    last.(MLP);\n    title=\"Minimal Action Path\",\n    xlabel=\"u\",\n    ylabel=\"v\",\n    label=\"Transition path\",\n) # Phase space plot","category":"page"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"The resulting path shows the most likely transition between the two stable states given a transient time T=50, minimizing the action functional while respecting the system's dynamics.","category":"page"},{"location":"examples/OC_mam/#Minimize-with-respect-to-T","page":"Minimal action method as an Optimal Control problem","title":"Minimize with respect to T","text":"","category":"section"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"To find the maximum likelihood path, we also need to minimize the transient time T. Hence, we perform a discrete continuation over the parameter T by solving the optimal control problem over a continuous range of final times T, using each solution to initialize the next problem.","category":"page"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"objectives = []\nTs = range(1, 100, 30)\nsol = solve(ocp(Ts[1]); display=false, init=init, grid_size=50)\nprintln(\" Time   Objective     Iterations\")\nfor T in Ts\n    global sol = solve(ocp(T); display=false, init=sol, grid_size=1000, tol=1e-8)\n    @printf(\"%6.2f  %9.6e  %d\\n\", T, objective(sol), iterations(sol))\n    push!(objectives, objective(sol))\nend","category":"page"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"T_min = Ts[argmin(objectives)]\nplt1 = scatter(Ts, log10.(objectives); xlabel=\"Time\", label=\"Objective (log10)\")\nvline!(plt1, [T_min]; label=\"Minimum\", z_order=:back)\nplt2 = scatter(\n    Ts[10:30], log10.(objectives[10:30]); xlabel=\"Time\", label=\"Objective (log10)\"\n)\nvline!(plt2, [T_min]; label=\"Minimum\", z_order=:back)\nplot(plt1, plt2; layout=(2, 1), size=(800, 800))","category":"page"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"","category":"page"},{"location":"examples/OC_mam/","page":"Minimal action method as an Optimal Control problem","title":"Minimal action method as an Optimal Control problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/sampling/#Sampling-transitions","page":"Sampling transitions","title":"Sampling transitions","text":"","category":"section"},{"location":"man/sampling/#CriticalTransitions.TransitionEnsemble","page":"Sampling transitions","title":"CriticalTransitions.TransitionEnsemble","text":"struct TransitionEnsemble{SSS, T, ES}\n\nEnsemble of transition paths between two points in a state space.\n\nFields\n\npaths::Vector: paths sampled from the transition process\ntimes::Array{Vector{T}, 1} where T: coresponsing times of the paths\nstats::CriticalTransitions.TransitionStatistics: statistics of the ensemble\nsciml_ensemble::Any: original ensemble solution of the SciML Ensemble problem\n\nConstructors\n\nTransitionEnsemble(sim, success_rate)\n\ndefined at /home/runner/work/CriticalTransitions.jl/CriticalTransitions.jl/src/trajectories/TransitionEnsemble.jl:55.\n\n\n\n\n\n","category":"type"},{"location":"man/sampling/#CriticalTransitions.TransitionStatistics","page":"Sampling transitions","title":"CriticalTransitions.TransitionStatistics","text":"struct TransitionStatistics{T}\n\nStatistics of the ensemble of transition paths between two points in a state space.\n\nFields\n\nsuccess_rate::Any: success rate of the transition process\nresidence_time::Any: mean residence time of the transition process\ntransition_time::Any: mean transition time of the transition process\nrareness::Any: rareness of the transition process\n\nConstructors\n\nTransitionStatistics(sim, success_rate)\n\ndefined at /home/runner/work/CriticalTransitions.jl/CriticalTransitions.jl/src/trajectories/TransitionEnsemble.jl:23.\n\n\n\n\n\n","category":"type"},{"location":"man/sampling/#...-by-direct-simulation","page":"Sampling transitions","title":"... by direct simulation","text":"","category":"section"},{"location":"man/sampling/","page":"Sampling transitions","title":"Sampling transitions","text":"These functions generate noise-induced transitions between an initial and final state.","category":"page"},{"location":"man/sampling/#CriticalTransitions.transition","page":"Sampling transitions","title":"CriticalTransitions.transition","text":"transition(\n    sys::CoupledSDEs,\n    x_i,\n    x_f;\n    radii,\n    tmax,\n    radius_directions,\n    cut_start,\n    kwargs...\n) -> Tuple{Any, Any, Bool}\n\n\nGenerates a sample transition from point x_i to point x_f.\n\nThis function simulates sys in time, starting from initial condition x_i, until entering a ball of given radius around x_f. If a seed was given to sys the solver is initialized with this seed. To change the seed you can pass a new seed to the seed keyword.\n\nKeyword arguments\n\nradii=(0.1, 0.1): radius of the ball around x_i and x_f, respectively\ntmax=1e3: maximum time until the simulation stops even x_f has not been reached\nradius_directions=1:length(sys.u): the directions in phase space to consider when calculating the radii rad_i and rad_f. Defaults to all directions. To consider only a subspace of state space, insert a vector of indices of the dimensions to be included.\ncut_start=true: if false, returns the whole trajectory up to the transition\nkwargs...: keyword arguments passed to CommonSolve.solve\n\nOutput\n\n[path, times, success]\n\npath (Matrix): transition path (size [dim × N], where N is the number of time points)\ntimes (Vector): time values (since start of simulation) of the path points (size N)\nsuccess (bool): if true, a transition occurred (i.e. the ball around x_f has been reached), else false\n\nSee also transitions, trajectory.\n\n\n\n\n\n","category":"function"},{"location":"man/sampling/#CriticalTransitions.transitions","page":"Sampling transitions","title":"CriticalTransitions.transitions","text":"transitions(\n    sys::CoupledSDEs,\n    x_i,\n    x_f;\n    ...\n) -> CriticalTransitions.TransitionEnsemble{_A, _B, EnsembleSolution{T, N, S}} where {_A, _B, T, N, S}\ntransitions(\n    sys::CoupledSDEs,\n    x_i,\n    x_f,\n    N::Int64;\n    radii,\n    tmax,\n    Nmax,\n    cut_start,\n    radius_directions,\n    show_progress,\n    EnsembleAlg,\n    kwargs...\n) -> CriticalTransitions.TransitionEnsemble{_A, _B, EnsembleSolution{T, N, S}} where {_A, _B, T, N, S}\n\n\nGenerates an ensemble of N transition samples of sys from point x_i to point x_f. The transitions is by default simulated using threading. To sample the transitions in serial, GPU or Distributed enverionment, pass the desired SciMLBase.EnsembleAlgorithm to the EnsembleAlg algorithm.\n\nKeyword arguments\n\nradii=(0.1, 0.1): radius of the ball around x_i and x_f, respectively\nNmax: number of attempts before the algorithm stops even if less than N transitions occurred.\ntmax=1e3: maximum time when the simulation stops even x_f has not been reached\nradius_directions=1:length(sys.u): the directions in phase space to consider when calculating the radii rad_i and rad_f. Defaults to all directions. To consider only a subspace of state space, insert a vector of indices of the dimensions to be included.\ncut_start=true: if false, returns the whole trajectory up to the transition\nshow_progress=true: shows a progress bar with respect to Nmax\nkwargs...: keyword arguments passed to CommonSolve.solve\n\nSee also transition.\n\nReturns a TransitionEnsemble object.\n\n\n\n\n\n","category":"function"},{"location":"man/sampling/#...-in-pathspace","page":"Sampling transitions","title":"... in pathspace","text":"","category":"section"},{"location":"man/sampling/","page":"Sampling transitions","title":"Sampling transitions","text":"Coming soon...","category":"page"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#Installation","page":"Quickstart","title":"Installation","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Although the package is not yet registered, you can install it from Github via the Julia package manager:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using Pkg; Pkg.add('https://github.com/juliadynamics/CriticalTransitions.jl.git')","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The package is currently tested to be compatible with Julia versions 1.10 and 1.11.","category":"page"},{"location":"quickstart/#Basic-usage","page":"Quickstart","title":"Basic usage","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The general workflow of CriticalTransitions essentially follows two steps:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Define your system as a CoupledSDEs (see Define a CoupledSDEs system)\nInvestigate the system by calling methods (see Methods)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"info: New system type: RateSystem\nWe are planning to introduce the the struct RateSystem along CoupledSDEs. In a RateSystem, the time dependence of parameters can conveniently be specified, laying the foundation for a toolbox to study rate-induced tipping, or R-tipping.","category":"page"},{"location":"quickstart/#Methods","page":"Quickstart","title":"Methods","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Currently the following functions are implemented to analyze a CoupledSDEs and  corresponding sample transition paths.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Pages = [\"man/systemanalysis.md\", \"man/simulation.md\", \"man/sampling.md\", \"man/largedeviations.md\", \"man/utils.md\"]","category":"page"},{"location":"#CriticalTransitions.jl","page":"Home","title":"CriticalTransitions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for the numerical investigation of noise- and rate-induced transitions in dynamical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Building on DynamicalSystems.jl and DifferentialEquations.jl, this package aims to provide a toolbox for dynamical systems under time-dependent forcing, with a focus on tipping phenomena and metastability.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: CT.jl infographic)","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Current features\nStochastic simulation made easy: Gaussian noise, uncorrelated and correlated, additive and multiplicative\nTransition path sampling: Parallelized ensemble rejection sampling\nLarge deviation theory tools: Action functionals and minimization algorithms (MAM, gMAM)","category":"page"},{"location":"","page":"Home","title":"Home","text":"ukw: Planned features\nRare event simulation: importance sampling, AMS\nQuasipotentials: Ordered line integral method (OLIM)\nRate-induced tipping tools\nSymbolic differentiation of action functionals\n...?","category":"page"},{"location":"","page":"Home","title":"Home","text":"Developers: Reyk Börner, Ryan Deeley, Raphael Römer and Orjan Ameye","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thanks to Jeroen Wouters, Calvin Nesbitt, Tobias Grafke, George Datseris and Oliver Mehling","category":"page"},{"location":"","page":"Home","title":"Home","text":"This work is part of the CriticalEarth project.","category":"page"},{"location":"man/CoupledSDEs/#Define-a-CoupledSDEs-system","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"","category":"section"},{"location":"man/CoupledSDEs/#DynamicalSystemsBase.CoupledSDEs","page":"Define a CoupledSDEs system","title":"DynamicalSystemsBase.CoupledSDEs","text":"CoupledSDEs(ds::CoupledODEs, p; kwargs...)\n\nConverts a CoupledODEs  system into a CoupledSDEs.\n\n\n\n\n\n","category":"type"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"info: Info\nNote that nonlinear mixings of the Noise Process mathcalW fall into the class of random ordinary differential equations (RODEs) which have a separate set of solvers. See this example of DifferentialEquations.jl.","category":"page"},{"location":"man/CoupledSDEs/#defining-stochastic-dynamics","page":"Define a CoupledSDEs system","title":"Examples: Defining stochastic dynamics","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"Let's look at some examples of the different types of stochastic systems that can be defined.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"For simplicity, we choose a slow exponential growth in 2 dimensions as the deterministic dynamics f:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"using DynamicalSystemsBase, StochasticDiffEq, DiffEqNoiseProcess\nusing CairoMakie\nimport Random # hide\nRandom.seed!(10) # hide\nf!(du, u, p, t) = du .= 1.01u # deterministic part\n\nfunction plot_trajectory(Y, t)\n    fig = Figure()\n    ax = Axis(fig[1,1]; xlabel = \"time\", ylabel = \"variable\")\n    for var in columns(Y)\n        lines!(ax, t, var)\n    end\n    fig\nend;","category":"page"},{"location":"man/CoupledSDEs/#Additive-noise","page":"Define a CoupledSDEs system","title":"Additive noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"When g(u p t) is independent of the state u, the noise is called additive; otherwise, it is multiplicative. We can define a simple additive noise system as follows:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"sde = CoupledSDEs(f!, zeros(2));","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"which is equivalent to","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"t0 = 0.0; W0 = zeros(2);\nW = WienerProcess(t0, W0, 0.0)\nsde = CoupledSDEs(f!, zeros(2);\n    noise_process=W, covariance=[1 0; 0 1], noise_strength=1.0\n    );","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"We defined a Wiener process W, whose increments are vectors of normally distributed random numbers of length matching the output of g. The noise is applied element-wise, i.e., g.*dW. Since the noise processes are uncorrelated, meaning the covariance matrix is diagonal, this type of noise is referred to as diagonal.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"We can sample a trajectory from this system using the trajectory function also used for the deterministic systems:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"tr = trajectory(sde, 1.0)\nplot_trajectory(tr...)","category":"page"},{"location":"man/CoupledSDEs/#Correlated-noise","page":"Define a CoupledSDEs system","title":"Correlated noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"In the case of correlated noise, the random numbers in a vector increment dW are correlated. This can be achieved by specifying the covariance matrix Sigma via the covariance keyword:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"ρ = 0.3\nΣ = [1 ρ; ρ 1]\ndiffeq = (alg = LambaEM(), dt=0.1)\nsde = CoupledSDEs(f!, zeros(2); covariance=Σ, diffeq=diffeq)","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"Alternatively, we can parametrise the covariance matrix by defining the diffusion function g ourselves:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"g!(du, u, p, t) = (du .= [1 p[1]; p[1] 1]; return nothing) \nsde = CoupledSDEs(f!, zeros(2), (ρ); g=g!, noise_prototype=zeros(2, 2))","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"Here, we had to provide noise_prototype to indicate that the diffusion function g will output a 2x2 matrix.","category":"page"},{"location":"man/CoupledSDEs/#Scalar-noise","page":"Define a CoupledSDEs system","title":"Scalar noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"If all state variables are forced by the same single random variable, we have scalar noise. To define scalar noise, one has to give an one-dimensional noise process to the noise_process keyword of the CoupledSDEs constructor. ","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"t0 = 0.0; W0 = 0.0;\nnoise = WienerProcess(t0, W0, 0.0)\nsde = CoupledSDEs(f!, rand(2)/10; noise_process=noise)\n\ntr = trajectory(sde, 1.0)\nplot_trajectory(tr...)","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"We can see that noise applied to each variable is the same.","category":"page"},{"location":"man/CoupledSDEs/#Multiplicative-and-time-dependent-noise","page":"Define a CoupledSDEs system","title":"Multiplicative and time-dependent noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"In the SciML ecosystem, multiplicative noise is defined through the condition g_i(t u)=a_i u. However, in the literature the name is more broadly used for any situation where the noise is non-additive and depends on the state u, possibly also in a non-linear way. When defining a CoupledSDEs, we can make the noise term time- and state-dependent by specifying an explicit time- or state-dependence in the noise function g, just like we would define f. For example, we can define a system with temporally decreasing multiplicative noise as follows:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"function g!(du, u, p, t)\n    du .= u ./ (1+t)\n    return nothing\nend\nsde = CoupledSDEs(f!, rand(2)./10; g=g!)","category":"page"},{"location":"man/CoupledSDEs/#Non-diagonal-noise","page":"Define a CoupledSDEs system","title":"Non-diagonal noise","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"Non-diagonal noise allows for the terms to be linearly mixed (correlated) via g being a matrix. Suppose we have two Wiener processes and two state variables such that the output of g is a 2x2 matrix. Therefore, we have","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"du_1 = f_1(upt)dt + g_11(upt)dW_1 + g_12(upt)dW_2 \ndu_2 = f_2(upt)dt + g_21(upt)dW_1 + g_22(upt)dW_2","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"To indicate the structure that g should have, we must use the noise_prototype keyword. Let us define a special type of non-diagonal noise called commutative noise. For this we can utilize the RKMilCommute algorithm which is designed to utilize the structure of commutative noise.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"σ = 0.25 # noise strength\nfunction g!(du, u, p, t)\n  du[1,1] = σ*u[1]\n  du[2,1] = σ*u[2]\n  du[1,2] = σ*u[1]\n  du[2,2] = σ*u[2]\n    return nothing\nend\ndiffeq = (alg = RKMilCommute(), reltol = 1e-3, abstol = 1e-3, dt=0.1)\nsde = CoupledSDEs(f!, rand(2)./10; g=g!, noise_prototype = zeros(2, 2), diffeq = diffeq)","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"warning: Warning\nNon-diagonal problems need specific solvers. See the SciML recommendations.","category":"page"},{"location":"man/CoupledSDEs/#Interface-to-DynamicalSystems.jl","page":"Define a CoupledSDEs system","title":"Interface to DynamicalSystems.jl","text":"","category":"section"},{"location":"man/CoupledSDEs/#Converting-between-CoupledSDEs-and-CoupledODEs","page":"Define a CoupledSDEs system","title":"Converting between CoupledSDEs and CoupledODEs","text":"","category":"section"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"tip: Analyzing deterministic dynamics with DynamicalSystems.jl\nThe deterministic part of a CoupledSDEs system can easily be extracted as a  CoupledODEs, a common subtype of a ContinuousTimeDynamicalSystem in DynamicalSystems.jl.","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"CoupledODEs(sde::CoupledSDEs) extracts the deterministic part of sde as a CoupledODEs.\nCoupledSDEs(ode::CoupledODEs; kwargs) turns ode into a CoupledSDEs.","category":"page"},{"location":"man/CoupledSDEs/#DynamicalSystemsBase.CoupledODEs","page":"Define a CoupledSDEs system","title":"DynamicalSystemsBase.CoupledODEs","text":"CoupledODEs(ds::CoupledSDEs; kwargs...)\n\nConverts a CoupledSDEs into a CoupledODEs by extracting the deterministic part of ds.\n\n\n\n\n\n","category":"type"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"For example, the Lyapunov spectrum of a CoupledSDEs in the absence of noise, here exemplified by the FitzHugh-Nagumo model, can be computed by typing:","category":"page"},{"location":"man/CoupledSDEs/","page":"Define a CoupledSDEs system","title":"Define a CoupledSDEs system","text":"using CriticalTransitions\nusing DynamicalSystems: lyapunovspectrum\n\nfunction fitzhugh_nagumo(u, p, t)\n    x, y = u\n    ϵ, β, α, γ, κ, I = p\n\n    dx = (-α * x^3 + γ * x - κ * y + I) / ϵ\n    dy = -β * y + x\n\n    return SA[dx, dy]\nend\n\np = [1.,3.,1.,1.,1.,0.]\n\nsys = CoupledSDEs(fitzhugh_nagumo, zeros(2), p; noise_strength=0.1)\nls = lyapunovspectrum(CoupledODEs(sys), 10000)","category":"page"}]
}

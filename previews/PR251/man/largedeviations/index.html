<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Large deviation theory · CriticalTransitions.jl</title><meta name="title" content="Large deviation theory · CriticalTransitions.jl"/><meta property="og:title" content="Large deviation theory · CriticalTransitions.jl"/><meta property="twitter:title" content="Large deviation theory · CriticalTransitions.jl"/><meta name="description" content="Documentation for CriticalTransitions.jl."/><meta property="og:description" content="Documentation for CriticalTransitions.jl."/><meta property="twitter:description" content="Documentation for CriticalTransitions.jl."/><meta property="og:url" content="https://juliadynamics.github.io/CriticalTransitions.jl/man/largedeviations/"/><meta property="twitter:url" content="https://juliadynamics.github.io/CriticalTransitions.jl/man/largedeviations/"/><link rel="canonical" href="https://juliadynamics.github.io/CriticalTransitions.jl/man/largedeviations/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.jpg" alt="CriticalTransitions.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CriticalTransitions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quickstart/">Getting started</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/tutorial/">Tutorial</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Defining a system</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/stochastic-dynamics/">Stochastic system</a></li><li><a class="tocitem" href="../../examples/RateSystem/">Nonautonomous system</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">System analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/gMAM_Maierstein/">Large deviations: Maier-Stein system</a></li><li><a class="tocitem" href="../../examples/sgMAM_KPO/">Simple gMAM: Kerr Parametric Oscillator</a></li><li><a class="tocitem" href="../../examples/OC_mam/">Minimal action method: Optimal Control problem</a></li><li><a class="tocitem" href="../../examples/transition_path_theory_double_well/">Transition path theory: Finite element method</a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../system_construction/">Define your system</a></li><li><a class="tocitem" href="../systemanalysis/">Stability analysis</a></li><li><a class="tocitem" href="../simulation/">Simulating the system</a></li><li><a class="tocitem" href="../sampling/">Sampling transitions</a></li><li class="is-active"><a class="tocitem" href>Large deviation theory</a><ul class="internal"><li><a class="tocitem" href="#Action-minimizers"><span>Action minimizers</span></a></li><li><a class="tocitem" href="#Action-functionals"><span>Action functionals</span></a></li><li><a class="tocitem" href="#String-method"><span>String method</span></a></li></ul></li><li><a class="tocitem" href="../r-tipping/">Rate-induced transitions</a></li><li><a class="tocitem" href="../transition_path_theory/">Transition path theory</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../bibliography/">Bibliography</a></li></ul></li><li><a class="tocitem" href="../../refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Large deviation theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Large deviation theory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/CriticalTransitions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/main/docs/src/man/largedeviations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Large-deviation-theory"><a class="docs-heading-anchor" href="#Large-deviation-theory">Large deviation theory</a><a id="Large-deviation-theory-1"></a><a class="docs-heading-anchor-permalink" href="#Large-deviation-theory" title="Permalink"></a></h1><p>This section applies results of large deviation theory (LDT), particularly action minimization problems for computing most probable transition paths in stochastic dynamical systems driven by weak noise. For a description of the theory, see <a href="../../refs/#freidlin_random_1998">Freidlin and Wentzell [8]</a> and [<a href="../../refs/#borner_climate_2025">9</a>]. An overview of numerical methods applying LDT is given in <a href="../../refs/#grafke_numerical_2019">Grafke and Vanden-Eijnden [10]</a>.</p><div class="admonition is-info" id="Info-1cbe1a3f19a9f912"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-1cbe1a3f19a9f912" title="Permalink"></a></header><div class="admonition-body"><p>The methods in this section apply to <span>$D$</span>-dimensional stochastic dynamical systems of the form</p><p class="math-container">\[\text{d} \mathbf{x} = \mathbf{b} (\mathbf{x}) \text{d}t + \sigma \mathbf{\Sigma} \text{d}\mathbf{W}_t \,,\]</p><p>where the drift field <span>$\mathbf{b}$</span> may be non-gradient but the noise term must consist of Gaussian noise (<span>$\mathbf{W}_t$</span> is a <span>$D$</span>-dimensional vector of independent standard Wiener processes) and a constant covariance matrix <span>$\mathbf{Q} = \mathbf{\Sigma}\mathbf{\Sigma}^\top$</span>.</p><p>This is a special case of the broader class of noise types supported by <a href="../system_construction/#DynamicalSystemsBase.CoupledSDEs"><code>CoupledSDEs</code></a>.</p></div></div><h2 id="Action-minimizers"><a class="docs-heading-anchor" href="#Action-minimizers">Action minimizers</a><a id="Action-minimizers-1"></a><a class="docs-heading-anchor-permalink" href="#Action-minimizers" title="Permalink"></a></h2><p>Several methods have been proposed to calculate transition paths that minimize a given <a href="#Action-functionals">action functional</a>. In the weak-noise limit, this minimum action path (or instanton) corresponds to the most probable transition path. While the minimum action method (MAM) is the most basic version, it is often beneficial to minimize the <a href="#Geometric-Freidlin-Wentzell-action">geometric action</a> via a time-independent version called gMAM. The problem can also be cast in a Hamiltonian form, implemented as simple gMAM (sgMAM), which can have numerical advantages.</p><p>These methods apply to non-gradient systems driven by Gaussian noise. In gradient systems, minimum action paths between attractors coincide with heteroclinic orbits, which can be computed via the so-called string method.</p><p>To summarize, the following methods are available:</p><ul><li>Minimum action method <a href="#Minimum-action-method-(MAM)">(MAM)</a></li><li>Geometric minimum action method <a href="#Geometric-minimum-action-method-(gMAM)">(gMAM)</a></li><li>Simple geometric minimum action method <a href="#Simple-geometric-minimum-action-method-(sgMAM)">(sgMAM)</a></li><li><a href="#String-method">String method</a></li></ul><h3 id="Minimum-action-method-(MAM)"><a class="docs-heading-anchor" href="#Minimum-action-method-(MAM)">Minimum action method (MAM)</a><a id="Minimum-action-method-(MAM)-1"></a><a class="docs-heading-anchor-permalink" href="#Minimum-action-method-(MAM)" title="Permalink"></a></h3><p>Minimization of the specified action functional using the optimization algorithm of <code>Optimization.jl</code>. See also <a href="../../refs/#e_minimum_2004">E <em>et al.</em> [11]</a>.</p><article><details class="docstring" open="true"><summary id="CriticalTransitions.min_action_method"><a class="docstring-binding" href="#CriticalTransitions.min_action_method"><code>CriticalTransitions.min_action_method</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">min_action_method(sys::ContinuousTimeDynamicalSystem, x_i, x_f, T::Real; kwargs...)</code></pre><p>Minimizes an action functional to obtain a minimum action path (instanton) between an initial state <code>x_i</code> and final state <code>x_f</code> in phase space.</p><p>This algorithm uses the <a href="https://github.com/SciML/Optimization.jl"><code>Optimization.jl</code></a> package to minimize the specified action functional (either <a href="#CriticalTransitions.fw_action"><code>fw_action</code></a> or <a href="#CriticalTransitions.om_action"><code>om_action</code></a>) for the system <code>sys</code> over paths connecting <code>x_i</code> to <code>x_f</code> in time <code>T</code>.</p><p>The path is initialized as a straight line between <code>x_i</code> and <code>x_f</code>, parameterized in time via <code>N</code> equidistant points and total time <code>T</code>. Thus, the time step between discretized path points is <span>$\Delta t = T/N$</span>. To set an initial path different from a straight line, see the multiple dispatch method</p><blockquote><p><code>min_action_method(sys::ContinuousTimeDynamicalSystem, init::Matrix, T::Real; kwargs...)</code>.</p></blockquote><p>Returns a <a href="#MinimumActionPath"><code>MinimumActionPath</code></a> object containing the optimized path and the action value.</p><p><strong>Keyword arguments</strong></p><ul><li><code>functional = &quot;FW&quot;</code>: type of action functional to minimize. Defaults to <a href="#CriticalTransitions.fw_action"><code>fw_action</code></a>, alternative: &quot;OM&quot; for <a href="#CriticalTransitions.om_action"><code>om_action</code></a>.</li><li><code>N = 100</code>: number of path points to use for the discretization of the path.</li><li><code>noise_strength = nothing</code>: noise strength for the action functional. Specify only if <code>functional = &quot;OM&quot;</code>.</li><li><code>method = Optimisers.Adam()</code>: minimization algorithm (see <a href="https://docs.sciml.ai/Optimization/stable/optimization_packages/optimisers/"><code>Optimization.jl</code></a>)</li><li><code>ad_type = Optimization.AutoFiniteDiff()</code>: type of automatic differentiation to use (see <a href="https://docs.sciml.ai/Optimization/stable/optimization_packages/optimisers/"><code>Optimization.jl</code></a>)</li><li><code>maxiters = 100</code>: maximum number of iterations before the algorithm stops.</li><li><code>abstol=1e-8</code>: absolute tolerance of action gradient to determine convergence</li><li><code>reltol=1e-8</code>: relative tolerance of action gradient to determine convergence</li><li><code>verbose = true</code>: whether to print Optimization information during the run</li><li><code>show_progress = false</code>: whether to print a progress bar</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19/src/largedeviations/min_action_method.jl#L1-L36">source</a></section><section><div><pre><code class="language-julia hljs">min_action_method(sys::ContinuousTimeDynamicalSystem, init::Matrix, T::Real; kwargs...)</code></pre><p>Minimizes the specified action functional to obtain a minimum action path (instanton) between fixed end points given a system <code>sys</code> and total path time <code>T</code>.</p><p>The initial path <code>init</code> must be a matrix of size <code>(D, N)</code>, where <code>D</code> is the dimension of the system and <code>N</code> is the number of path points. The physical time of the path is specified by <code>T</code>, such that the time step between consecutive path points is <span>$\Delta t = T/N$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19/src/largedeviations/min_action_method.jl#L44-L54">source</a></section></details></article><h3 id="Geometric-minimum-action-method-(gMAM)"><a class="docs-heading-anchor" href="#Geometric-minimum-action-method-(gMAM)">Geometric minimum action method (gMAM)</a><a id="Geometric-minimum-action-method-(gMAM)-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-minimum-action-method-(gMAM)" title="Permalink"></a></h3><p>Minimization of the geometric action following <a href="../../refs/#heymann_pathways_2008">Heymann and Vanden-Eijnden [12]</a> and <a href="../../refs/#heymann_geometric_2008">Heymann and Vanden-Eijnden [13]</a>. gMAM reformulates MAM to avoid double optimization of both the action and the transition time. It achieves this by using a <a href="#Geometric-Freidlin-Wentzell-action">geometric action</a> functional that is independent of the time parametrization of the path. This reparameterization invariance makes the method more robust and computationally efficient, particularly for multiscale systems.</p><article><details class="docstring" open="true"><summary id="CriticalTransitions.geometric_min_action_method"><a class="docstring-binding" href="#CriticalTransitions.geometric_min_action_method"><code>CriticalTransitions.geometric_min_action_method</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">geometric_min_action_method(
    sys::ContinuousTimeDynamicalSystem,
    x_i,
    x_f;
    N,
    kwargs...
) -&gt; MinimumActionPath{_A, _B, _C, Nothing, Nothing, Nothing, Nothing, Nothing} where {_A, _B&lt;:Real, _C}
</code></pre><p>Computes the minimizer of the geometric Freidlin-Wentzell action based on the geometric minimum action method (gMAM), using optimizers of Optimization.jl or the original formulation by Heymann and Vanden-Eijnden <a href="../../refs/#heymann_pathways_2008">Heymann and Vanden-Eijnden [12]</a>. Only the Freidlin-Wentzell action has a geometric formulation.</p><p>To set an initial path different from a straight line, see the multiple dispatch method</p><ul><li><code>geometric_min_action_method(sys::CoupledSDEs, init::Matrix, arclength::Real; kwargs...)</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>maxiters::Int=100</code>: maximum number of optimization iterations before the algorithm stops</li><li><code>abstol=1e-8</code>: absolute tolerance of action gradient to determine convergence</li><li><code>reltol=1e-8</code>: relative tolerance of action gradient to determine convergence</li><li><code>method = Adam()</code>: minimization algorithm (see below)</li><li><code>ϵ=0.1</code>: step size parameter in gradient descent HeymannVandenEijnden implementation</li><li><code>verbose=false</code>: if true, print additional output</li><li><code>show_progress=true</code>: if true, display a progress bar</li></ul><p><strong>Minimization algorithms</strong></p><p>The <code>method</code> keyword argument takes solver methods of the <a href="https://docs.sciml.ai/Optimization/"><code>Optimization.jl</code></a> package; alternatively, the option <code>method = &quot;HeymannVandenEijnden&quot;</code> implements the original gMAM algorithm [<a href="../../refs/#heymann_pathways_2008">12</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19/src/largedeviations/geometric_min_action_method.jl#L1">source</a></section><section><div><pre><code class="language-julia hljs">geometric_min_action_method(
    sys::ContinuousTimeDynamicalSystem,
    init::Matrix;
    maxiters,
    abstol,
    reltol,
    method,
    AD,
    ϵ,
    verbose,
    show_progress
) -&gt; MinimumActionPath{_A, _B, _C, Nothing, Nothing, Nothing, Nothing, Nothing} where {_A, _B&lt;:Real, _C}
</code></pre><p>Runs the geometric Minimum Action Method (gMAM) to find the minimum action path (instanton) from an initial condition <code>init</code>, given a system <code>sys</code> and total arc length <code>arclength</code>.</p><p>The initial path <code>init</code> must be a matrix of size <code>(D, N)</code>, where <code>D</code> is the dimension of the system and <code>N</code> is the number of path points.</p><p>For more information see the main method, <a href="#CriticalTransitions.geometric_min_action_method"><code>geometric_min_action_method(sys::CoupledSDEs, x_i, x_f, arclength::Real; kwargs...)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19/src/largedeviations/geometric_min_action_method.jl#L37">source</a></section></details></article><h3 id="Simple-geometric-minimum-action-method-(sgMAM)"><a class="docs-heading-anchor" href="#Simple-geometric-minimum-action-method-(sgMAM)">Simple geometric minimum action method (sgMAM)</a><a id="Simple-geometric-minimum-action-method-(sgMAM)-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-geometric-minimum-action-method-(sgMAM)" title="Permalink"></a></h3><p>Simplified minimization of the geometric action following <a href="../../refs/#grafke_long_2017">Grafke <em>et al.</em> [14]</a>. The simple gMAM reduces the complexity of the original gMAM by requiring only first-order derivatives of the underlying Hamiltonian optimization formulation. This simplifies the numerical treatment and computational complexity.</p><p>The implementation below performs a constrained gradient descent assuming an autonomous system with additive Gaussian noise.</p><article><details class="docstring" open="true"><summary id="CriticalTransitions.simple_geometric_min_action_method"><a class="docstring-binding" href="#CriticalTransitions.simple_geometric_min_action_method"><code>CriticalTransitions.simple_geometric_min_action_method</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simple_geometric_min_action_method(
    sys::ExtendedPhaseSpace,
    x_initial::Array{T, 2};
    ϵ,
    iterations,
    show_progress,
    reltol
) -&gt; MinimumActionPath{_A, _B, _C, Nothing, Nothing, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}} where {_A, _B&lt;:Real, _C}
</code></pre><p>Performs the simplified geometric Minimal Action Method (sgMAM) on the given system <code>sys</code>. Our implementation is only valid for additive noise.</p><p>This method computes the optimal path in the phase space of a Hamiltonian system that minimizes the Freidlin–Wentzell action. The Hamiltonian functions <code>H_x</code> and <code>H_p</code> define the system&#39;s dynamics in a doubled phase. The initial state <code>x_initial</code> is evolved iteratively using constrained gradient descent with step size parameter <code>ϵ</code> over a specified number of iterations. The method can display a progress meter and will stop early if the relative tolerance <code>reltol</code> is achieved.</p><p>The function returns a tuple containing the final state, the action value, the Lagrange multipliers, the momentum, and the state derivatives. The implementation is based on the work of <a href="https://homepages.warwick.ac.uk/staff/T.Grafke/simplified-geometric-minimum-action-method-for-the-computation-of-instantons.html. ">Grafke et al. (2019)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19/src/largedeviations/sgMAM.jl#L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CriticalTransitions.ExtendedPhaseSpace"><a class="docstring-binding" href="#CriticalTransitions.ExtendedPhaseSpace"><code>CriticalTransitions.ExtendedPhaseSpace</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A structure representing a extanded phase space system where your dissipative vector field is embedded in a doubled dimensional phase space. Given old phase space coordinates <code>x</code> of a vector field <code>f(x)</code>, we can define the canonical momenta <code>p</code>, such that the new phase space coordinates are <code>(x, p)</code>. The dynamics in this extended phase space are then governed by the Hamtiltonian system:</p><p><span>$H = p^2 + x \dot f(x)$</span></p><p>Hence, this system operates in an extended phase space where the Hamiltonian is assumed to be quadratic in the extended momentum.</p><p>The struct <code>ExtendedPhaseSpace</code> holds the Hamilton&#39;s functions <code>H_x</code> and <code>H_p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19/src/largedeviations/sgMAM.jl#L1-L9">source</a></section></details></article><h3 id="MinimumActionPath"><a class="docs-heading-anchor" href="#MinimumActionPath"><code>MinimumActionPath</code></a><a id="MinimumActionPath-1"></a><a class="docs-heading-anchor-permalink" href="#MinimumActionPath" title="Permalink"></a></h3><p><a href="#Geometric-minimum-action-method-(gMAM)">(gMAM)</a> and <a href="#Simple-geometric-minimum-action-method-(sgMAM)">(sgMAM)</a> return their output as a <code>MinimumActionPath</code> type:</p><article><details class="docstring" open="true"><summary id="CriticalTransitions.MinimumActionPath"><a class="docstring-binding" href="#CriticalTransitions.MinimumActionPath"><code>CriticalTransitions.MinimumActionPath</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct MinimumActionPath{D, T&lt;:Real, V, Phis, Ahis, Lambda, PV, GPV}</code></pre><p>The minimum action path between two points in a D-dimensional phase space.</p><p><strong>Fields</strong></p><ul><li><p><code>path::StateSpaceSet{D, T, V} where {D, T&lt;:Real, V}</code>: The path matrix.</p></li><li><p><code>action::Real</code>: The action value associated to the path.</p></li><li><p><code>path_history::Any</code>: The history of action of the paths in the optimisation algorithm (optional).</p></li><li><p><code>action_history::Any</code>: The history of action of the paths in the optimisation algorithm (optional).</p></li><li><p><code>λ::Any</code>: The Lagrange multiplier parameter for the minimum action path (optional).</p></li><li><p><code>generalized_momentum::Any</code>: The generalized momentum of the phase space variables (optional).</p></li><li><p><code>path_velocity::Any</code>: The path velocity (optional).</p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">MinimumActionPath(
    path,
    action;
    path_history,
    action_history,
    λ,
    generalized_momentum,
    path_velocity
)</code></pre><p>defined at <a href="https://github.com/JuliaDynamics/CriticalTransitions.jl/tree/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19//src/largedeviations/MinimumActionPath.jl#L29"><code>/home/runner/work/CriticalTransitions.jl/CriticalTransitions.jl/src/largedeviations/MinimumActionPath.jl:29</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19/src/largedeviations/MinimumActionPath.jl#L1">source</a></section></details></article><h2 id="Action-functionals"><a class="docs-heading-anchor" href="#Action-functionals">Action functionals</a><a id="Action-functionals-1"></a><a class="docs-heading-anchor-permalink" href="#Action-functionals" title="Permalink"></a></h2><h3 id="Freidlin-Wentzell-action"><a class="docs-heading-anchor" href="#Freidlin-Wentzell-action">Freidlin-Wentzell action</a><a id="Freidlin-Wentzell-action-1"></a><a class="docs-heading-anchor-permalink" href="#Freidlin-Wentzell-action" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="CriticalTransitions.fw_action"><a class="docstring-binding" href="#CriticalTransitions.fw_action"><code>CriticalTransitions.fw_action</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fw_action(sys::CoupledSDEs, path, time) -&gt; Any
</code></pre><p>Calculates the Freidlin-Wentzell action of a given <code>path</code> with time points <code>time</code> in a drift field specified by the deterministic dynamics <code>f = dynamic_rule(sys)</code> and (normalized) noise covariance matrix <code>covariance_matrix(sys)</code>.</p><p>The path must be a <code>(D x N)</code> matrix, where <code>D</code> is the dimensionality of the system <code>sys</code> and <code>N</code> is the number of path points. The <code>time</code> array must have length <code>N</code>.</p><p>Returns a single number, which is the value of the action functional</p><p><span>$S_T[\phi_t] = \frac{1}{2} \int_0^T || \dot \phi_t - f(\phi_t) ||^2_Q \text{d}t$</span></p><p>where <span>$\phi_t$</span> denotes the path in state space, <span>$b$</span> the drift field, and <span>$T$</span> the total time of the path. The subscript <span>$Q$</span> refers to the generalized norm <span>$||a||_Q^2 := \langle a, Q^{-1} b \rangle$</span> (see <code>anorm</code>). Here <span>$Q$</span> is the noise covariance matrix normalized by <span>$D/L_1(Q)$</span>, with <span>$L_1$</span> being the L1 matrix norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19/src/largedeviations/action.jl#L1">source</a></section></details></article><h3 id="Geometric-Freidlin-Wentzell-action"><a class="docs-heading-anchor" href="#Geometric-Freidlin-Wentzell-action">Geometric Freidlin-Wentzell action</a><a id="Geometric-Freidlin-Wentzell-action-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-Freidlin-Wentzell-action" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="CriticalTransitions.geometric_action"><a class="docstring-binding" href="#CriticalTransitions.geometric_action"><code>CriticalTransitions.geometric_action</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">geometric_action(sys::CoupledSDEs, path) -&gt; Any
geometric_action(sys::CoupledSDEs, path, arclength) -&gt; Any
</code></pre><p>Calculates the geometric action of a given <code>path</code> with specified <code>arclength</code> for the drift field specified by the deterministic dynamics <code>f = dynamic_rule(sys)</code> and (normalized) noise covariance matrix <code>covariance_matrix(sys)</code>.</p><p>For a given path <span>$\varphi$</span>, the geometric action <span>$\bar S$</span> corresponds to the minimum of the Freidlin-Wentzell action <span>$S_T(\varphi)$</span> over all travel times <span>$T&gt;0$</span>, where <span>$\varphi$</span> denotes the path&#39;s parameterization in physical time (see <a href="#CriticalTransitions.fw_action"><code>fw_action</code></a>). It is given by the integral</p><p><span>$\bar S[\varphi] = \int_0^L \left( ||\varphi&#39;||_Q \, ||f(\varphi)||_Q - \langle \varphi&#39;, \,     f(\varphi) \rangle_Q \right) \, \text{d}s$</span></p><p>where <span>$s$</span> is the arclength coordinate, <span>$L$</span> the arclength, <span>$f$</span> the drift field, and the subscript <span>$Q$</span> refers to the generalized dot product <span>$\langle a, b \rangle_Q := a^{\top} \cdot Q^{-1} b$</span> (see <code>anorm</code>). Here <span>$Q$</span> is the noise covariance matrix normalized by <span>$D/L_1(Q)$</span>, with <span>$L_1$</span> being the L1 matrix norm.</p><p>Returns the value of the geometric action <span>$\bar S$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19/src/largedeviations/action.jl#L90">source</a></section></details></article><h3 id="Onsager-Machlup-action"><a class="docs-heading-anchor" href="#Onsager-Machlup-action">Onsager-Machlup action</a><a id="Onsager-Machlup-action-1"></a><a class="docs-heading-anchor-permalink" href="#Onsager-Machlup-action" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="CriticalTransitions.om_action"><a class="docstring-binding" href="#CriticalTransitions.om_action"><code>CriticalTransitions.om_action</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">om_action(sys::CoupledSDEs, path, time, noise_strength)</code></pre><p>Calculates the Onsager-Machlup action of a given <code>path</code> with time points <code>time</code> for the drift field <code>f = dynamic_rule(sys)</code> at given <code>noise_strength</code>.</p><p>The path must be a <code>(D x N)</code> matrix, where <code>D</code> is the dimensionality of the system <code>sys</code> and <code>N</code> is the number of path points. The <code>time</code> array must have length <code>N</code>.</p><p>Returns a single number, which is the value of the action functional</p><p><span>$S^{\sigma}_T[\phi_t] = \frac{1}{2} \int_0^T \left( || \dot \phi_t - f(\phi_t) ||^2_Q + \sigma^2 \nabla \cdot f \right) \, \text{d} t$</span></p><p>where <span>$\phi_t$</span> denotes the path in state space, <span>$b$</span> the drift field, <span>$T$</span> the total time of the path, and <span>$\sigma$</span> the noise strength. The subscript <span>$Q$</span> refers to the generalized norm <span>$||a||_Q^2 := \langle a, Q^{-1} b \rangle$</span> (see <code>anorm</code>). Here <span>$Q$</span> is the noise covariance matrix normalized by <span>$D/L_1(Q)$</span>, with <span>$L_1$</span> being the L1 matrix norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19/src/largedeviations/action.jl#L36-L54">source</a></section></details></article><p>For convenience, a general <a href="#CriticalTransitions.action"><code>action</code></a> function is available where the type of functional is set as an argument:</p><article><details class="docstring" open="true"><summary id="CriticalTransitions.action"><a class="docstring-binding" href="#CriticalTransitions.action"><code>CriticalTransitions.action</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">action(
    sys::CoupledSDEs,
    path::Matrix,
    time,
    functional;
    noise_strength
) -&gt; Any
</code></pre><p>Computes the action functional specified by <code>functional</code> for a given CoupledSDEs <code>sys</code> and <code>path</code> parameterized by <code>time</code>.</p><ul><li><code>functional = &quot;FW&quot;</code>: Returns the Freidlin-Wentzell action (<a href="#CriticalTransitions.fw_action"><code>fw_action</code></a>)</li><li><code>functional = &quot;OM&quot;</code>: Returns the Onsager-Machlup action (<a href="#CriticalTransitions.om_action"><code>om_action</code></a>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19/src/largedeviations/action.jl#L71">source</a></section></details></article><h2 id="String-method"><a class="docs-heading-anchor" href="#String-method">String method</a><a id="String-method-1"></a><a class="docs-heading-anchor-permalink" href="#String-method" title="Permalink"></a></h2><p>The string method is a technique for finding transition paths between two states in a dynamical system <a href="../../refs/#e_string_2007">E <em>et al.</em> [15]</a>. The method represents the path as a &quot;string&quot; of points that connects the states and evolves it to minimize the drift along the path. The resulting tangent path is parallel to the drift of the system, i.e., the string method computes the heteroclinic orbit. For non-gradient systems (detailed -balance is broken), the heteroclinic orbit differs from the transition path, it does correctly predict, it correctly captures the deterministic dynamics from the saddle point onward (&quot;downhill&quot; portion of the path).</p><article><details class="docstring" open="true"><summary id="CriticalTransitions.string_method"><a class="docstring-binding" href="#CriticalTransitions.string_method"><code>CriticalTransitions.string_method</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">string_method(
    sys::Union{Function, ExtendedPhaseSpace},
    x_initial::Matrix;
    ϵ,
    alg,
    iterations,
    show_progress
) -&gt; Any
</code></pre><p>Compute the string method for a given system using the method of <a href="../../refs/#e_string_2007">E <em>et al.</em> [15]</a>.</p><p>The string method is an iterative algorithm used to find minimum energy path (MEP) between two points in phase space. It works by evolving a discretized path (string) according to the system&#39;s drift while maintaining equal arc-length parametrization between points.</p><p>This implementation allows for computation between arbitrary points, not just stable fixed points.</p><p><strong>References</strong></p><ul><li>[<a href="../../refs/#e_string_2007">15</a>]</li></ul><p><strong>Arguments</strong></p><ul><li><code>sys::ExtendedPhaseSpace</code>: The doubled phase space system for which the string method is computed</li><li><code>x_initial</code>: Initial path discretized as a matrix where each column represents a point on the path</li><li><code>ϵ::Real</code>: Step size for the evolution step</li><li><code>alg</code>: SciML integrator algorithm (e.g. <code>Euler()</code>, <code>Tsit5()</code>). Defaults to <code>Euler()</code>.</li><li><code>iterations::Int64</code>: Maximum number of iterations for path convergence</li><li><code>show_progress::Bool</code>: Whether to display a progress meter during computation</li></ul><p><strong>Returns</strong></p><ul><li><code>x</code>: The final converged path representing the MEP</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19/src/largedeviations/string_method.jl#L1-L24">source</a></section><section><div><pre><code class="language-julia hljs">string_method(
    sys::ContinuousTimeDynamicalSystem,
    init;
    kwargs...
) -&gt; Any
</code></pre><p>Compute the string method for a given system using the method of <a href="../../refs/#e_string_2007">E <em>et al.</em> [15]</a>.</p><p>The string method is an iterative algorithm used to find minimum energy path (MEP) between two points in phase space. It works by evolving a discretized path (string) according to the system&#39;s drift while maintaining equal arc-length parametrization between points.</p><p>This implementation allows for computation between arbitrary points, not just stable fixed points.</p><p><strong>References</strong></p><ul><li>[<a href="../../refs/#e_string_2007">15</a>]</li></ul><p><strong>Arguments</strong></p><ul><li><code>sys::CoupledSDEs</code>: The system for which the string method is computed</li><li><code>x_initial</code>: Initial path discretized as a matrix where each column represents a point on the path</li><li><code>ϵ::Real</code>: Step size for the evolution step</li><li><code>alg</code>: SciML integrator algorithm (e.g. <code>Euler()</code>, <code>Tsit5()</code>). Defaults to <code>Euler()</code>.</li><li><code>iterations::Int64</code>: Maximum number of iterations for path convergence</li><li><code>show_progress::Bool</code>: Whether to display a progress meter during computation</li></ul><p><strong>Returns</strong></p><ul><li><code>x</code>: The final converged path representing the MEP</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/a7dd5169f5e5c3fe9c18d1541758820e10f4ad19/src/largedeviations/string_method.jl#L54-L77">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sampling/">« Sampling transitions</a><a class="docs-footer-nextpage" href="../r-tipping/">Rate-induced transitions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 22 January 2026 15:55">Thursday 22 January 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

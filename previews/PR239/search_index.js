var documenterSearchIndex = {"docs":
[{"location":"examples/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"To give you an idea of how our package works, this tutorial provides some example code with explanations.","category":"section"},{"location":"examples/tutorial/#Example:-FitzHugh-Nagumo-model","page":"Tutorial","title":"Example: FitzHugh-Nagumo model","text":"Let's consider a simple 2-dimensional dynamical system - the FitzHugh-Nagumo model:\n\nbeginaligned\nfracdudt = frac1epsilon left( -alpha u^3 + gamma u - kappa v + I right) \nfracdvdt = -beta v + u  \nendaligned\n\nwhere epsilon is the parameter of time scale separation between the state variables u and v. The parameters alpha 0, beta 1, gamma0, and kappa0 are real constants, and I denotes a driving term.\n\nLet's investigate this system under stochastic forcing.","category":"section"},{"location":"examples/tutorial/#System-definition","page":"Tutorial","title":"System definition","text":"First, we need to translate the system equations above into Julia code.\n\nThis works exactly as in DynamicalSystems.jl by defining a function f(u,p,t) which takes as input a vector u of state variables (u,v), a vector p of parameters, and time t. The function must return an array of flow increments (textdu, textdv). For performance reasons, it is advisable to return a StaticArray SA[du, dv] rather than just a Vector [du, dv].\n\nusing CriticalTransitions\nimport Random # hide\nRandom.seed!(1) # hide\n\nfunction fitzhugh_nagumo(u,p,t)\n    u, v = u\n    ϵ, β, α, γ, κ, I = p\n\n    du = (-α*u^3 + γ*u - κ*v + I)/ϵ\n    dv = -β*v + u\n\n    SA[du, dv]\nend\n\ntip: In-place vs. out-of-place\nThe function fitzhugh_nagumo(u,p,t) is defined out-of-place. It is also possible to define the system in-place as fitzhugh_nagumo!(du,u,p,t). For more info, see here.","category":"section"},{"location":"examples/tutorial/#CoupledSDE","page":"Tutorial","title":"CoupledSDE","text":"Next, we construct a stochastic system with the fitzhugh_nagumo equation as the deterministic part. Suppose we would like to force both state variables u and v with additive, uncorrelated Gaussian noise of intensity sigma. This is the default case. We simply write\n\np = [1., 3., 1., 1., 1., 0.] # Parameters (ϵ, β, α, γ, κ, I)\nσ = 0.2 # noise strength\n\n# CoupledSDE\nsys = CoupledSDEs(fitzhugh_nagumo, zeros(2), p; noise_strength=σ)\n\nHere the first field fitzhugh_nagumo specifies the deterministic dynamics f (see CoupledSDEs). We have chosen zeros(2) as the initial state of the system, which is the second field. The length of this vector must match the system's dimensionality. In the (optional) third field, we specify the parameter vector p, which includes the parameters of f followed by the parameters of g (in this case, there are no parameters for g). Lastly, noise_strength sets the noise strength. Since we have not specified a noise process, the default case of an uncorrelated Wiener process is used.\n\nnote: Multiplicative and/or correlated noise\nOf course, it is also possible to define more complicated noise processes than simple additive white noise. This is done by specifying a custom noise function and covariance matrix in the CoupledSDEs definition. For more info, see CoupledSDEs.\n\nThat's it! Now we can apply the toolbox of CriticalTransitions to our stochastic FitzHugh-Nagumo system sys.","category":"section"},{"location":"examples/tutorial/#Find-stable-equilibria","page":"Tutorial","title":"Find stable equilibria","text":"For the parameters chosen above, the FitzHugh-Nagumo system is bistable. Let's compute the fixed points using the ChaosTools.fixedpoints function. This function is borrowed from ChaosTools.jl and is loaded as an extension when we write using ChaosTools.\n\nusing ChaosTools\n# Calculate fixed points and store the stable ones\neqs, eigs, stab = fixedpoints(sys, [-2,-2], [2,2])\nfp1, fp2 = eqs[stab]","category":"section"},{"location":"examples/tutorial/#Stochastic-simulation","page":"Tutorial","title":"Stochastic simulation","text":"Using the trajectory function, we now run a simulation of our system for 200 time units starting out from the fixed point fp1:\n\nsim = trajectory(sys, 200, fp1)\n\nIn the keyword arguments, we have specified at which interval the solution is saved. Further keyword arguments can be used to change the solver (the default is SOSRA() for stochastic integration) and other settings.\n\nThe simulated trajectory is stored in sim in the usual output format of the solve method of DifferentialEquations.jl, including the solution sim.u and the vector of time points sim.t. The solution can also be accessed as a matrix sim[i, t], where i is the i-th component of u and t the time index.\n\nLet's plot the result. Did the trajectory transition to the other attractor?\n\nusing Plots\nplt = plot(sim[1][:,1], sim[1][:,2]; xlabel=\"u\", ylabel=\"v\", legend=false)\nscatter!([fp1[1], fp2[1]], [fp1[2], fp2[2]], color=:red, markersize=4)\nxlims!(-1.2, 1.2)\nylims!(-0.6, 0.6)\nplt\n\nHopefully, this helped you to get started. For more info, check out the Manual section of these docs.","category":"section"},{"location":"man/r-tipping/#Rate-induced-transitions","page":"Rate-induced transitions","title":"Rate-induced transitions","text":"","category":"section"},{"location":"man/r-tipping/#Critical-Rate","page":"Rate-induced transitions","title":"Critical Rate","text":"In preparation.","category":"section"},{"location":"man/simulation/#Simulating-the-system","page":"Simulating the system","title":"Simulating the system","text":"We provide two main functions to simulate a CoupledSDEs forward in time:\n\nDynamicalSystemsBase.trajectory, which integrates the stochastic CoupledSDEs system forward in time\ndeterministic_orbit, which integrates only the deterministic part of the CoupledSDEs system ","category":"section"},{"location":"man/simulation/#DynamicalSystemsBase.trajectory","page":"Simulating the system","title":"DynamicalSystemsBase.trajectory","text":"trajectory(ds::DynamicalSystem, T [, u0]; kwargs...) → X, t\n\nEvolve ds for a total time of T and return its trajectory X, sampled at equal time intervals, and corresponding time vector. X is a StateSpaceSet. The returned time vector is t = (t0+Ttr):Δt:(t0+Ttr+T).\n\nOptionally provide a starting state u0 which is current_state(ds) by default.\n\nIf time evolution diverged or in general failed before T, the remaining of the trajectory is set to the last valid point.\n\nThe dimensions of X are automatically named if ds referrences an MTK model and if save_idxs remains at its default value.\n\nKeyword arguments\n\nΔt:  Time step of value output. For discrete time systems it must be an integer. Defaults to 0.1 for continuous and 1 for discrete time systems. If you don't have access to unicode, the keyword Dt can be used instead.\nTtr = 0: Transient time to evolve the initial state before starting saving states.\nt0 = initial_time(ds): Starting time.\ncontainer = SVector: Type of vector that will represent the state space points that will be included in the StateSpaceSet output. See StateSpaceSet for valid options.\nsave_idxs: Which variables to output in X. By default it is nothing (all variables). It can be a vector of any type of index that can be given to observe_state. Note: if you mix integer and symbolic indexing be sure to initialize the array as Any so that integers 1, 2, ... are not converted to symbolic expressions.\n\nDescription\n\ntrajectory is a very simple function provided for convenience. For continuous time systems, it doesn't play well with callbacks, use DifferentialEquations.solve if you want a trajectory that works with callbacks, or in general you want more flexibility in the generated trajectory (but remember to convert the output of solve to a StateSpaceSet).\n\n\n\n\n\n","category":"function"},{"location":"man/simulation/#CriticalTransitions.deterministic_orbit","page":"Simulating the system","title":"CriticalTransitions.deterministic_orbit","text":"deterministic_orbit(\n    sys::CoupledSDEs,\n    T;\n    ...\n) -> Tuple{Any, Any}\ndeterministic_orbit(\n    sys::CoupledSDEs,\n    T,\n    init;\n    diffeq,\n    kwargs...\n) -> Tuple{Any, Any}\n\n\nSimulates the deterministic (noise-free) dynamics of CoupledSDEs sys in time for a duration T, starting at initial condition init.\n\nThis function is equivalent to calling trajectory on the deterministic part of the CoupledSDEs (with noise_strength=0). It works with the ODE solvers used for CoupledODEs.\n\nKeyword arguments\n\ndiffeq=(alg=Tsit5(), abstol = 1e-6, reltol = 1e-6): ODE solver settings (see CoupledODEs)\nkwargs...: keyword arguments passed to trajectory\n\nFor more info, see ODEProblem. For stochastic integration, see trajectory.\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#Utility-functions","page":"Utilities","title":"Utility functions","text":"","category":"section"},{"location":"man/utils/#CriticalTransitions.intervals_to_box","page":"Utilities","title":"CriticalTransitions.intervals_to_box","text":"intervals_to_box(bmin::Vector, bmax::Vector) -> Any\n\n\nGenerates a box from specifying the interval limits in each dimension.\n\nbmin (Vector): lower limit of the box in each dimension\nbmax (Vector): upper limit\n\nExample\n\nintervals_to_box([-2,-1,0], [2,1,1]) returns a 3D box of dimensions [-2,2] × [-1,1] × [0,1].\n\n\n\n\n\n","category":"function"},{"location":"examples/stochastic-dynamics/#defining-stochastic-dynamics","page":"Stochastic system","title":"Examples: Defining stochastic dynamics","text":"Let's look at some examples of the different types of stochastic systems that can be defined.\n\nFor simplicity, we choose a slow exponential growth in 2 dimensions as the deterministic dynamics f:\n\nusing DynamicalSystemsBase, StochasticDiffEq, DiffEqNoiseProcess\nusing CairoMakie\nimport Random # hide\nRandom.seed!(10) # hide\nf!(du, u, p, t) = du .= 1.01u # deterministic part\n\nfunction plot_trajectory(Y, t)\n    fig = Figure()\n    ax = Axis(fig[1,1]; xlabel = \"time\", ylabel = \"variable\")\n    for var in columns(Y)\n        lines!(ax, t, var)\n    end\n    fig\nend;","category":"section"},{"location":"examples/stochastic-dynamics/#Additive-noise","page":"Stochastic system","title":"Additive noise","text":"When g(u p t) is independent of the state u, the noise is called additive; otherwise, it is multiplicative. We can define a simple additive noise system as follows:\n\nsde = CoupledSDEs(f!, zeros(2));\n\nwhich is equivalent to\n\nt0 = 0.0; W0 = zeros(2);\nW = WienerProcess(t0, W0, 0.0)\nsde = CoupledSDEs(f!, zeros(2);\n    noise_process=W, covariance=[1 0; 0 1], noise_strength=1.0\n    );\n\nWe defined a Wiener process W, whose increments are vectors of normally distributed random numbers of length matching the output of g. The noise is applied element-wise, i.e., g.*dW. Since the noise processes are uncorrelated, meaning the covariance matrix is diagonal, this type of noise is referred to as diagonal.\n\nWe can sample a trajectory from this system using the trajectory function also used for the deterministic systems:\n\ntr = trajectory(sde, 1.0)\nplot_trajectory(tr...)","category":"section"},{"location":"examples/stochastic-dynamics/#Correlated-noise","page":"Stochastic system","title":"Correlated noise","text":"In the case of correlated noise, the random numbers in a vector increment dW are correlated. This can be achieved by specifying the covariance matrix Sigma via the covariance keyword:\n\nρ = 0.3\nΣ = [1 ρ; ρ 1]\ndiffeq = (alg = LambaEM(), dt=0.1)\nsde = CoupledSDEs(f!, zeros(2); covariance=Σ, diffeq=diffeq)\n\nAlternatively, we can parametrise the covariance matrix by defining the diffusion function g ourselves:\n\ng!(du, u, p, t) = (du .= [1 p[1]; p[1] 1]; return nothing) \nsde = CoupledSDEs(f!, zeros(2), (ρ); g=g!, noise_prototype=zeros(2, 2))\n\nHere, we had to provide noise_prototype to indicate that the diffusion function g will output a 2x2 matrix.","category":"section"},{"location":"examples/stochastic-dynamics/#Scalar-noise","page":"Stochastic system","title":"Scalar noise","text":"If all state variables are forced by the same single random variable, we have scalar noise. To define scalar noise, one has to give an one-dimensional noise process to the noise_process keyword of the CoupledSDEs constructor. \n\nt0 = 0.0; W0 = 0.0;\nnoise = WienerProcess(t0, W0, 0.0)\nsde = CoupledSDEs(f!, rand(2)/10; noise_process=noise)\n\ntr = trajectory(sde, 1.0)\nplot_trajectory(tr...)\n\nWe can see that noise applied to each variable is the same.","category":"section"},{"location":"examples/stochastic-dynamics/#Multiplicative-and-time-dependent-noise","page":"Stochastic system","title":"Multiplicative and time-dependent noise","text":"In the SciML ecosystem, multiplicative noise is defined through the condition g_i(t u)=a_i u. However, in the literature the name is more broadly used for any situation where the noise is non-additive and depends on the state u, possibly also in a non-linear way. When defining a CoupledSDEs, we can make the noise term time- and state-dependent by specifying an explicit time- or state-dependence in the noise function g, just like we would define f. For example, we can define a system with temporally decreasing multiplicative noise as follows:\n\nfunction g!(du, u, p, t)\n    du .= u ./ (1+t)\n    return nothing\nend\nsde = CoupledSDEs(f!, rand(2)./10; g=g!)","category":"section"},{"location":"examples/stochastic-dynamics/#Non-diagonal-noise","page":"Stochastic system","title":"Non-diagonal noise","text":"Non-diagonal noise allows for the terms to be linearly mixed (correlated) via g being a matrix. Suppose we have two Wiener processes and two state variables such that the output of g is a 2x2 matrix. Therefore, we have\n\ndu_1 = f_1(upt)dt + g_11(upt)dW_1 + g_12(upt)dW_2 \ndu_2 = f_2(upt)dt + g_21(upt)dW_1 + g_22(upt)dW_2\n\nTo indicate the structure that g should have, we must use the noise_prototype keyword. Let us define a special type of non-diagonal noise called commutative noise. For this we can utilize the RKMilCommute algorithm which is designed to utilize the structure of commutative noise.\n\nσ = 0.25 # noise strength\nfunction g!(du, u, p, t)\n  du[1,1] = σ*u[1]\n  du[2,1] = σ*u[2]\n  du[1,2] = σ*u[1]\n  du[2,2] = σ*u[2]\n    return nothing\nend\ndiffeq = (alg = RKMilCommute(), reltol = 1e-3, abstol = 1e-3, dt=0.1)\nsde = CoupledSDEs(f!, rand(2)./10; g=g!, noise_prototype = zeros(2, 2), diffeq = diffeq)\n\nwarning: Warning\nNon-diagonal problems need specific solvers. See the SciML recommendations.","category":"section"},{"location":"examples/transition_path_theory_double_well/#TPT_example","page":"Transition path theory: Finite element method","title":"Transition Path Theory for the double well","text":"In this example, we explore the application of Transition Path Theory (TPT) to a double well system. We will compute various quantities of interest in TPT, such as the Hamiltonian, committor functions, reactive currents, and reaction rates. These computations will be performed on a triangular mesh in the phase space, providing insights into the system's dynamics and transition paths between different states.\n\nAs for now, TPT functionality is considered experimental, and the API may change in the future.\n\nusing CriticalTransitions\n\nusing CairoMakie\nusing OrdinaryDiffEq, DelaunayTriangulation, Contour","category":"section"},{"location":"examples/transition_path_theory_double_well/#System","page":"Transition path theory: Finite element method","title":"System","text":"We consider a simple model for a particle in a double-well potential, subject to dissipation and diffusion. The equation of motion under additive Gaussian noise is given by\n\ndotx = p \ndotp = -gamma p - nabla U + sqrtfrac2gammabeta dotW\n\nwith the potential energy U(x) = frac14x^4 - frac12x^2 and the kinetic energy K(p) = p^22. The parameters gamma and beta=1k_b T control the strength of the dissipation and noise, respectively. W(t) is a Wiener process, and the noise term is scaled by sqrt2gammabeta to ensure the correct temperature scaling for Langevin dynamics defined by the Hamiltonian H.\n\nIn CriticalTransitions.jl, a stochastic dynamical system of this form can be constructed as a LangevinSystem, which takes five input arguments as exemplified below: the Hamiltonian, the divergence-free part of the drift, the system's kinetic energy, the damping coefficient, and the inverse temperature (noise intensity).\n\nbeta = 20.0\ngamma = 0.5\n\nfunction Hamiltonian(x, y)\n    return 0.5 .* y .^ 2 .+ 0.25 .* x .^ 4 .- 0.5 .* x .^ 2\nend\n\nfunction KE(x)\n    return 0.5 .* (x[:, 2] .^ 2)\nend\n\nfunction divfree(x, y)\n    f1 = y\n    f2 = .-x .^ 3 .+ x\n    return f1, f2\nend\n\nfunction double_well(x, y)\n    f1 = y\n    f2 = .-gamma .* y .- x .^ 3 .+ x\n    return f1, f2\nend\n\nusing CriticalTransitions: LangevinSystem\nlangevin_sys = LangevinSystem(Hamiltonian, divfree, KE, gamma, beta)","category":"section"},{"location":"examples/transition_path_theory_double_well/#Phase-space-mesh","page":"Transition path theory: Finite element method","title":"Phase space mesh","text":"We can easily evaluate and visualize the Hamiltonian on an equally spaced grid in phase space.\n\nnx, ny = 41, 41\nnxy = nx * ny\nxmin, xmax = -2.0, 2.0\nymin, ymax = -2.0, 2.0\n\nx1 = range(xmin, xmax; length=nx)\ny1 = range(ymin, ymax; length=ny)\n\nx_grid = [xx for yy in y1, xx in x1]\ny_grid = [yy for yy in y1, xx in x1]\n\ndrift1, drift2 = double_well(x_grid, y_grid)\ndnorm = sqrt.(drift1 .^ 2 .+ drift2 .^ 2 .+ 1e-12)\nH_grid = Hamiltonian(x_grid, y_grid)\n\nfig = CairoMakie.contour(x1, y1, H_grid'; colormap=:viridis, levels=-1:0.4:2, linewidth=2)\nv(x::Point2) = Point2f(double_well(x[1], x[2])...)\nstreamplot!(\n    v,\n    -2 .. 2,\n    -2 .. 2;\n    linewidth=0.5,\n    colormap=[:black, :black],\n    gridsize=(40, 40),\n    arrow_size=8,\n)\nfig\n\nThe double well system is autonomous and respects detailed balance. In this case, the maximum likelihood path (MLP) follows parallel to a flowline of the drift field and can be computed via the string method. If the saddle point is known, one can easily compute the MLP by solving for the (reverse) flow/drift from the saddle point to each of the potential minima. The MLP from (-1,0) to (1,0) gives:\n\nusing OrdinaryDiffEq\n\nfunction reverse_drift!(du, u, p, t)\n    du[1] = -u[2]\n    return du[2] = -u[2] + u[1] * (u[1]^2 - 1)\nend\n\nfunction drift!(du, u, p, t)\n    du[1] = u[2]\n    return du[2] = -u[2] - u[1] * (u[1]^2 - 1)\nend\n\nprob0 = ODEProblem(reverse_drift!, [-0.001, 0.0], (0.0, 100.0))\nsol0 = solve(prob0, Tsit5(); abstol=1e-12, reltol=1e-12)\n\nprob1 = ODEProblem(drift!, [0.001, 0.0], (0.0, 100.0))\nsol1 = solve(prob1, Tsit5(); abstol=1e-12, reltol=1e-12)\n\nfig = streamplot(\n    v,\n    -2 .. 2,\n    -2 .. 2;\n    linewidth=0.5,\n    colormap=[:gray, :gray],\n    gridsize=(40, 40),\n    arrow_size=8,\n)\ny = sol0\nlines!(y[1, :], y[2, :]; linewidth=2, color=:black)\ny = sol1\nlines!(y[1, :], y[2, :]; linewidth=2, color=:black)\nfig\n\nClose to the local minima (-10 00) and (10 00) of the potential landscape, the system under the drift will dissipate to the corresponding attractor. TPT investigates the \"reaction\" (the name originates from studies of chemical reactions) between two sets in phase space A and B; here we define the two sets to be an ellipse around these minima:\n\nusing CriticalTransitions: get_ellipse\npoint_a = (-1.0, 0.0)\npoint_b = (1.0, 0.0)\nradii = (0.3, 0.4)\ndensity = 0.04\n\nNa = round(Int, π * sum(radii) / density) # the number of points on the A-circle\nNb = Na\n\nptsA = get_ellipse(point_a, radii, Na)\nptsB = get_ellipse(point_b, radii, Na);\nnothing #hide\n\nWe also compute an outer boundary of the phase space defined by the maximum value of the Hamiltonian: H_bound=0.5. For this, we use the Contour.jl package to compute the contour at the level H_bound. Just as the ellipse around the attractors, we also re-parameterize the boundary to have a uniform grid spacing.\n\nimport Contour as CTR\nH_bound = 0.5\ncont = CTR.contour(x1, y1, H_grid, H_bound)\nyc, xc = coordinates(CTR.lines(cont)[1])\np_outer = [xc yc]\n\nusing CriticalTransitions: reparameterization\npts_outer = reparameterization(p_outer, density);\nNouter = size(pts_outer, 1)\nNfix = Na + Nb + Nouter\n\nfig = scatter(ptsA[:, 1], ptsA[:, 2]; label=\"A points\")\nscatter!(ptsB[:, 1], ptsB[:, 2]; label=\"B points\")\nscatter!(pts_outer[:, 1], pts_outer[:, 2]; label=\"Outer points\")\nfig\n\nWe would like to compute the committor, the reactive current, and the reaction rate for the double well with additive Gaussian noise. We compute these quantities on a triangular mesh between the previously computed boundaries.\n\nusing CriticalTransitions: distmesh2D, dellipse, ddiff, dunion, huniform\nbox = [xmin, xmax, ymin, ymax]\npfix = zeros(Nfix, 2)\npfix[1:Na, :] .= ptsA\npfix[(Na + 1):(Na + Nb), :] .= ptsB\npfix[(Na + Nb + 1):Nfix, :] .= pts_outer\n\nfunction dfunc(p)\n    d0 = Hamiltonian(p[:, 1], p[:, 2])\n    dA = dellipse(p, point_a, radii)\n    dB = dellipse(p, point_b, radii)\n    d = ddiff(d0 .- H_bound, dunion(dA, dB))\n    return d\nend\n\nmesh = distmesh2D(dfunc, huniform, density, box, pfix)\n\npts, tri = mesh.pts, mesh.tri\nfig = Figure()\nax = Axis(fig[1, 1])\nfor i in 1:size(tri, 1)\n    lines!(\n        ax,\n        [pts[tri[i, j], 1] for j in [1, 2, 3, 1]],\n        [pts[tri[i, j], 2] for j in [1, 2, 3, 1]];\n        color=:black,\n        linewidth=0.1,\n    )\nend\nfig\n\n# Committor functions\n\nThe committor is a scalar function that measures the probability that a system, starting at a given point in phase space, reaches one designated region before another. Formally, for two disjoint sets A and B, the forward committor q_+(x p) from A to B gives the likelihood that a trajectory initiated at x will reach B before A under the system’s dynamics. The committor boundary-value problem for a Langevin system is given by:\n\n p fracmathrmdqmathrmdx - U(x) fracmathrmdqmathrmdp + gamma -p fracmathrmdqmathrmdp + beta^-1 fracmathrmd^2 qmathrmdp^2 = 0\n\nfor (xp) in (Acup B)^c, with boundary conditions q(partial A) = 0, q(partial B) = 1, and nabla nabla q = 0 on the outer boundary (xp)  H(xp) = mathrmH_bound. The homogeneous Neumann boundary condition nabla nabla q = 0 means that the trajectory reflects from the outer boundary whenever it reaches it. We can compute the committor function for the system using the committor function.\n\nusing CriticalTransitions: committor, find_boundary\n_, Aind = find_boundary(mesh.pts, point_a, radii, density)\n_, Bind = find_boundary(mesh.pts, point_b, radii, density)\n\nq = committor(langevin_sys, mesh, Aind, Bind)\n\n@show extrema(q)\n\ntricontourf(Triangulation(mesh.pts', mesh.tri'), q)\n\nWe can also compute the backward committor q_-(x p) from A to B, which is the probability that a trajectory initiated at x will reach A before B under the system’s dynamics. Hence, we must reverse the drift function in the Langevin system and swap the boundaries A and B in the committor function\n\nfunction divfree_reverse(x, y)\n    f1, f2 = divfree(x, y)\n    return -f1, -f2\nend\n\nlangevin_sys_reverse = LangevinSystem(Hamiltonian, divfree_reverse, KE, gamma, beta)\n\nqminus = committor(langevin_sys_reverse, mesh, Bind, Aind)\n\n@show extrema(qminus)\n\ntricontourf(Triangulation(mesh.pts', mesh.tri'), qminus)\n\nFor non-equilibrium processes, such as critical transitions in the double-well, we have q_-neq 1-q_+. In particular, for Langevin dynamics of the form above, time reversal involves a momentum flip such that q_-(x p)= 1-q_+(x -p).","category":"section"},{"location":"examples/transition_path_theory_double_well/#Probability-density-of-reactive-trajectories","page":"Transition path theory: Finite element method","title":"Probability density of reactive trajectories","text":"In general, we are interested in reactive trajectories that start in A and end in B without going back to A. The probability density of finding a reactive trajectory at a point in phase space is given by:\n\nrho_R(x p) = rho(x p) q(x p) q(x p)\n\nwhere rho(x p) is the probability density of finding a trajectory at (xp), rho(x p) is also called the invariant probability density (or invariant measure) of the system. For an overdamped Langevin system the invariant probability density reads:\n\nrho(x p) approx exp(-beta H(xp))Z\n\nwith Z=int exp(-beta H(xp)) mathrmdx mathrmdp the normalization. We can compute the integrated invariant probability density Z for the mesh using the invariant_pdf function.\n\nfunction dfuncA(p)\n    return dellipse(p, point_a, radii)\nend\n\nfunction dfuncB(p)\n    return dellipse(p, point_b, radii)\nend\n\nxa, ya = point_a\nxb, yb = point_b\nrx, ry = radii\nbboxA = [xa - rx, xa + rx, ya - ry, ya + ry]\nAmesh = distmesh2D(dfuncA, huniform, density, bboxA, ptsA)\nbboxB = [xb - rx, xb + rx, yb - ry, yb + ry]\nBmesh = distmesh2D(dfuncB, huniform, density, bboxB, ptsB)\n\nusing CriticalTransitions: invariant_pdf\nZ = invariant_pdf(langevin_sys, mesh, Amesh, Bmesh)\n\n@show Z\n\nHence, the probability density of a reactive trajectory is given by:\n\nmu = exp.(-beta * Hamiltonian(pts[:, 1], pts[:, 2])) / Z\nmuAB = mu .* q .* qminus\n\ntricontourf(Triangulation(mesh.pts', mesh.tri'), muAB)\n\nThe current of reactive trajectories is given by:\n\nJ_R = frace^-beta H q_+ q_-Zbinomp-nabla U+k_B T gamma Z^-1 e^-beta Hbinom0q_- fracpartial q_+partial p-q_+ fracpartial q_-partial p\n\nand the transition rate:\n\nv_R=k_B T gamma Z_H^-1 int sum_i=1^d m_ileft(fracpartial q_+partial p_iright)^2 e^-beta H(x p) d x d p\n\nThese can be computed using the reactive_current function:\n\nusing CriticalTransitions: reactive_current\nRcurrent, Rrate = reactive_current(langevin_sys, mesh, q, qminus, Z)\n@show Rrate\n\nPlotting the current norm reveals that the current is the strongest around the saddle point.\n\nARcurrent = vec(sqrt.(sum(Rcurrent .^ 2; dims=2)))\nARCmax = maximum(ARcurrent)\n\ntricontourf(Triangulation(mesh.pts', mesh.tri'), ARcurrent)\n\nThe transition current has a direction from A to B.\n\nc = ARcurrent ./ ARCmax\narrows2d(\n    pts[:, 1],\n    pts[:, 2],\n    Rcurrent[:, 1] ./ ARCmax,\n    Rcurrent[:, 2] ./ ARCmax;\n    color=c,\n    lengthscale=0.1,\n)\n\nusing CriticalTransitions: probability_reactive\nprob_reactive = probability_reactive(langevin_sys, mesh, q, qminus, Z)\nprint(\n    \"Probability that a trajectory is reactive at a randomly picked time: \", prob_reactive\n)\n\nusing CriticalTransitions: probability_last_A\nprob_lastA = probability_last_A(langevin_sys, mesh, Amesh, qminus, Z)\nprint(\"Probability that a trajectory last visited A: \", prob_lastA)\n\nAuthored by O. Ameye and R. Börner\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/gMAM_Maierstein/#The-Maier-Stein-model.","page":"Large deviations: Maier-Stein system","title":"The Maier-Stein model.","text":"using CriticalTransitions\n\nusing CairoMakie\nusing CairoMakie.Makie.MathTeXEngine: get_font\nfont = (;\n    regular=get_font(:regular),\n    bold=get_font(:bold),\n    italic=get_font(:italic),\n    bold_italic=get_font(:bolditalic),\n);\nnothing #hide\n\nLet us explore the features of CriticalTransitions.jl with Maier-Stein model.","category":"section"},{"location":"examples/gMAM_Maierstein/#Maier-stein-model","page":"Large deviations: Maier-Stein system","title":"Maier-stein model","text":"The Maier-Stein model (J. Stat. Phys 83, 3–4 (1996)) is commonly used in the field of nonlinear dynamics for benchmarking Large Deviation Theory (LDT) techniques, e.g., stoachastic transitions between different stable states. It is a simple model that describes the dynamics of a system with two degrees of freedom u and v, and is given by the following set of ordinary differential equations:\n\nbeginaligned\n    dotu = u-u^3 - beta*u*v^2\n    dotv = -alpha (1+u^2)*v\nendaligned\n\nThe parameter alpha0 controls the strength of the drift field and beta0 represents the softening of that drift field.\n\nfunction meier_stein!(du, u, p, t) # in-place\n    x, y = u\n    du[1] = x - x^3 - 10 * x * y^2\n    return du[2] = -(1 + x^2) * y\nend\nfunction meier_stein(u, p, t) # out-of-place\n    x, y = u\n    dx = x - x^3 - 10 * x * y^2\n    dy = -(1 + x^2) * y\n    return SA[dx, dy]\nend\nσ = 0.25\nsys = CoupledSDEs(meier_stein, zeros(2), (); noise_strength=σ)\n\nA good reference to read about the large deviations methods is this or this blog post by Tobias Grafke.","category":"section"},{"location":"examples/gMAM_Maierstein/#Attractors","page":"Large deviations: Maier-Stein system","title":"Attractors","text":"We start by investigating the deterministic dynamics of the Maier-Stein model.\n\nThe function fixed points return the attractors, their eigenvalues and stability within the state space volume defined by bmin and bmax.\n\nusing ChaosTools\n\nu_min = -1.1;\nu_max = 1.1;\nv_min = -0.4;\nv_max = 0.4;\nbmin = [u_min, v_min];\nbmax = [u_max, v_max];\nfp, eig, stab = fixedpoints(sys, bmin, bmax)\nstable_fp = fp[stab]\n\nusing LinearAlgebra: norm\nres = 100\nu_range = range(u_min, u_max; length=res)\nv_range = range(v_min, v_max; length=res)\n\ndu(u, v) = u - u^3 - 10 * u * v^2\ndv(u, v) = -(1 + u^2) * v\nodeSol(u, v) = Point2f(du(u, v), dv(u, v))\n\nz = [norm([du(x, y), dv(x, y)]) for x in u_range, y in v_range]\nzmin, zmax = minimum(z), maximum(z)\n\nfig = Figure(; size=(600, 400), fontsize=13)\nax = Axis(\n    fig[1, 1];\n    xlabel=\"u\",\n    ylabel=\"v\",\n    aspect=1.4,\n    xgridcolor=:transparent,\n    ygridcolor=:transparent,\n    ylabelrotation=0,\n)\n\nhm = heatmap!(ax, u_range, v_range, z; colormap=:Blues, colorrange=(zmin, zmax))\nColorbar(fig[1, 2], hm; label=\"\", width=15, ticksize=15, tickalign=1)\nstreamplot!(\n    ax,\n    odeSol,\n    (u_min, u_max),\n    (v_min, v_max);\n    gridsize=(20, 20),\n    arrow_size=10,\n    stepsize=0.01,\n    colormap=[:black, :black],\n)\ncolgap!(fig.layout, 7)\nlimits!(u_min, u_max, v_min, v_max)\nfig\n\n[\n    scatter!(ax, Point(fp[i]); color=stab[i] > 0 ? :red : :dodgerblue, markersize=10) for\n    i in eachindex(fp)\n]\nfig\n\nWe can simulate a stochastic trajectory using the function trajectory.\n\ntr, ts = trajectory(sys, 1000)\n\nfig = Figure(; size=(1000, 400), fontsize=13)\nax1 = Axis(\n    fig[1, 1];\n    xlabel=\"t\",\n    ylabel=\"u\",\n    aspect=1.2,\n    xgridcolor=:transparent,\n    ygridcolor=:transparent,\n    ylabelrotation=0,\n)\nax2 = Axis(\n    fig[1, 2];\n    xlabel=\"u\",\n    ylabel=\"v\",\n    aspect=1.2,\n    xgridcolor=:transparent,\n    ygridcolor=:transparent,\n    ylabelrotation=0,\n)\n\nlines!(ax1, ts, first.(tr); linewidth=2, color=:black)\n\nhm = heatmap!(ax2, u_range, v_range, z; colormap=:Blues, colorrange=(zmin, zmax))\nColorbar(fig[1, 3], hm; label=\"\", width=15, ticksize=15, tickalign=1)\nstreamplot!(\n    ax2,\n    odeSol,\n    (u_min, u_max),\n    (v_min, v_max);\n    gridsize=(20, 20),\n    arrow_size=10,\n    stepsize=0.01,\n    colormap=[:white, :white],\n)\ncolgap!(fig.layout, 7)\nlimits!(u_min, u_max, v_min, v_max)\nfig\n\n[\n    scatter!(ax2, Point(fp[i]); color=stab[i] > 0 ? :red : :dodgerblue, markersize=10) for\n    i in eachindex(fp)\n]\n\nlines!(ax2, reduce(hcat, tr); linewidth=1, color=(:black, 0.2))\nfig","category":"section"},{"location":"examples/gMAM_Maierstein/#Transitions","page":"Large deviations: Maier-Stein system","title":"Transitions","text":"We can quickly find a path which computes a transition from one attractor to another using the function `transition.\n\npaths_ends = (fp[stab][1], fp[stab][2])\npath, time, success = transition(sys, paths_ends...);\nnothing #hide\n\nfig = Figure(; size=(600, 400), fontsize=13)\nax = Axis(\n    fig[1, 1];\n    xlabel=\"u\",\n    ylabel=\"v\",\n    aspect=1.4,\n    xgridcolor=:transparent,\n    ygridcolor=:transparent,\n    ylabelrotation=0,\n)\n\nhm = heatmap!(ax, u_range, v_range, z; colormap=:Blues, colorrange=(zmin, zmax))\nColorbar(fig[1, 2], hm; label=\"\", width=15, ticksize=15, tickalign=1)\nstreamplot!(\n    ax,\n    odeSol,\n    (u_min, u_max),\n    (v_min, v_max);\n    gridsize=(20, 20),\n    arrow_size=10,\n    stepsize=0.01,\n    colormap=[:white, :white],\n)\ncolgap!(fig.layout, 7)\nlimits!(u_min, u_max, v_min, v_max)\nfig\n\n[\n    scatter!(ax, Point(fp[i]); color=stab[i] > 0 ? :red : :dodgerblue, markersize=10) for\n    i in eachindex(fp)\n]\nfig\n\nlines!(ax, path; color=:black)\nfig\n\nIf we want to compute many: transitions is the function to use.\n\ntt = transitions(sys, paths_ends..., 3; tmax=1e3);\nnothing #hide\n\nfig = Figure(; size=(600, 400), fontsize=13)\nax = Axis(\n    fig[1, 1];\n    xlabel=\"u\",\n    ylabel=\"v\",\n    aspect=1.4,\n    xgridcolor=:transparent,\n    ygridcolor=:transparent,\n    ylabelrotation=0,\n)\n\nhm = heatmap!(ax, u_range, v_range, z; colormap=:Blues, colorrange=(zmin, zmax))\nColorbar(fig[1, 2], hm; label=\"\", width=15, ticksize=15, tickalign=1)\nstreamplot!(\n    ax,\n    odeSol,\n    (u_min, u_max),\n    (v_min, v_max);\n    gridsize=(20, 20),\n    arrow_size=10,\n    stepsize=0.01,\n    colormap=[:black, :black],\n)\ncolgap!(fig.layout, 7)\nlimits!(u_min, u_max, v_min, v_max)\nfig\n\n[\n    scatter!(ax, Point(fp[i]); color=stab[i] > 0 ? :red : :dodgerblue, markersize=10) for\n    i in eachindex(fp)\n]\n\nfor i in 1:length(tt.paths)\n    lines!(ax, tt.paths[i])\nend\nfig","category":"section"},{"location":"examples/gMAM_Maierstein/#Large-deviation-theory","page":"Large deviations: Maier-Stein system","title":"Large deviation theory","text":"In the context of nonlinear dynamics, Large Deviation Theory provides tools to quantify the probability of rare events that deviate significantly from the system's typical behavior. These rare events might be extreme values of a system's output, sudden transitions between different states, or other phenomena that occur with very low probability but can have significant implications for the system's overall behavior.\n\nLarge deviation theory applies principles from probability theory and statistical mechanics to develop a rigorous mathematical description of these rare events. It uses the concept of a rate function, which measures the exponential decay rate of the probability of large deviations from the mean or typical behavior. This rate function plays a crucial role in quantifying the likelihood of rare events and understanding their impact on the system.\n\nFor example, in a system exhibiting chaotic behavior, LDT can help quantify the probability of sudden large shifts in the system's trajectory. Similarly, in a system with multiple stable states, it can provide insight into the likelihood and pathways of transitions between these states under fluctuations. In the context of the Minimum Action Method (MAM) and the Geometric Minimum Action Method (gMAM), Large Deviation Theory is used to handle the large deviations action functional on the space of curves. This is a key part of how these methods analyze dynamical systems.\n\nThe Maier-Stein model is a typical benchmark to test such LDT techniques. Let us try to reproduce the following figure from Tobias Grafke's blog post:\n\n(Image: maier_stein)\n\nLet us first make an initial path:\n\nxx = range(-1.0, 1.0; length=100)\nyy = 0.3 .* (-xx .^ 2 .+ 1)\ninit = Matrix([xx yy]')\n\ngeometric_min_action_method computes the minimizer of the Freidlin-Wentzell action using the geometric minimum action method (gMAM), to find the minimum action path (instanton) between an initial state xi and final state xf. The Minimum Action Method (MAM) is a more traditional approach, while the Geometric Minimum Action Method (gMAM) is a blend of the original MAM and the string method.\n\nmethod = \"HeymannVandenEijnden\"\ngm = geometric_min_action_method(sys, init; maxiter=500, show_progress=false, method)\nMLP = gm.path\n\nfig = Figure(; size=(600, 400), fontsize=13)\nax = Axis(\n    fig[1, 1];\n    xlabel=\"u\",\n    ylabel=\"v\",\n    aspect=1.4,\n    xgridcolor=:transparent,\n    ygridcolor=:transparent,\n    ylabelrotation=0,\n)\n\nhm = heatmap!(ax, u_range, v_range, z; colormap=:Blues, colorrange=(zmin, zmax))\nColorbar(fig[1, 2], hm; label=\"\", width=15, ticksize=15, tickalign=1)\nstreamplot!(\n    ax,\n    odeSol,\n    (u_min, u_max),\n    (v_min, v_max);\n    gridsize=(20, 20),\n    arrow_size=10,\n    stepsize=0.01,\n    colormap=[:black, :black],\n)\ncolgap!(fig.layout, 7)\nlimits!(u_min, u_max, v_min, v_max)\nfig\n\n[\n    scatter!(ax, Point(fp[i]); color=stab[i] > 0 ? :red : :dodgerblue, markersize=10) for\n    i in eachindex(fp)\n]\n\nlines!(ax, init; linewidth=3, color=:black, linestyle=:dash)\nlines!(ax, MLP; linewidth=3, color=:orange)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"man/largedeviations/#Large-deviation-theory","page":"Large deviation theory","title":"Large deviation theory","text":"This section applies results of large deviation theory (LDT), particularly action minimization problems for computing most probable transition paths in stochastic dynamical systems driven by weak noise. For a description of the theory, see Freidlin and Wentzell [8] and [9]. An overview of numerical methods applying LDT is given in Grafke and Vanden-Eijnden [10].\n\ninfo: Info\nThe methods in this section apply to D-dimensional stochastic dynamical systems of the formtextd mathbfx = mathbfb (mathbfx) textdt + sigma mathbfSigma textdmathbfW_t where the drift field mathbfb may be non-gradient but the noise term must consist of Gaussian noise (mathbfW_t is a D-dimensional vector of independent standard Wiener processes) and a constant covariance matrix mathbfQ = mathbfSigmamathbfSigma^top.This is a special case of the broader class of noise types supported by CoupledSDEs.","category":"section"},{"location":"man/largedeviations/#Action-minimizers","page":"Large deviation theory","title":"Action minimizers","text":"Several methods have been proposed to calculate transition paths that minimize a given action functional. In the weak-noise limit, this minimum action path (or instanton) corresponds to the most probable transition path. While the minimum action method (MAM) is the most basic version, it is often beneficial to minimize the geometric action via a time-independent version called gMAM. The problem can also be cast in a Hamiltonian form, implemented as simple gMAM (sgMAM), which can have numerical advantages.\n\nThese methods apply to non-gradient systems driven by Gaussian noise. In gradient systems, minimum action paths between attractors coincide with heteroclinic orbits, which can be computed via the so-called string method.\n\nTo summarize, the following methods are available:\n\nMinimum action method (MAM)\nGeometric minimum action method (gMAM)\nSimple geometric minimum action method (sgMAM)\nString method","category":"section"},{"location":"man/largedeviations/#Minimum-action-method-(MAM)","page":"Large deviation theory","title":"Minimum action method (MAM)","text":"Minimization of the specified action functional using the optimization algorithm of Optimization.jl. See also E et al. [11].","category":"section"},{"location":"man/largedeviations/#Geometric-minimum-action-method-(gMAM)","page":"Large deviation theory","title":"Geometric minimum action method (gMAM)","text":"Minimization of the geometric action following Heymann and Vanden-Eijnden [12] and Heymann and Vanden-Eijnden [13]. gMAM reformulates MAM to avoid double optimization of both the action and the transition time. It achieves this by using a geometric action functional that is independent of the time parametrization of the path. This reparameterization invariance makes the method more robust and computationally efficient, particularly for multiscale systems.","category":"section"},{"location":"man/largedeviations/#Simple-geometric-minimum-action-method-(sgMAM)","page":"Large deviation theory","title":"Simple geometric minimum action method (sgMAM)","text":"Simplified minimization of the geometric action following Grafke et al. [14]. The simple gMAM reduces the complexity of the original gMAM by requiring only first-order derivatives of the underlying Hamiltonian optimization formulation. This simplifies the numerical treatment and computational complexity.\n\nThe implementation below performs a constrained gradient descent assuming an autonomous system with additive Gaussian noise.","category":"section"},{"location":"man/largedeviations/#MinimumActionPath","page":"Large deviation theory","title":"MinimumActionPath","text":"(gMAM) and (sgMAM) return their output as a MinimumActionPath type:","category":"section"},{"location":"man/largedeviations/#Action-functionals","page":"Large deviation theory","title":"Action functionals","text":"","category":"section"},{"location":"man/largedeviations/#Freidlin-Wentzell-action","page":"Large deviation theory","title":"Freidlin-Wentzell action","text":"","category":"section"},{"location":"man/largedeviations/#Geometric-Freidlin-Wentzell-action","page":"Large deviation theory","title":"Geometric Freidlin-Wentzell action","text":"","category":"section"},{"location":"man/largedeviations/#Onsager-Machlup-action","page":"Large deviation theory","title":"Onsager-Machlup action","text":"For convenience, a general action function is available where the type of functional is set as an argument:","category":"section"},{"location":"man/largedeviations/#String-method","page":"Large deviation theory","title":"String method","text":"The string method is a technique for finding transition paths between two states in a dynamical system. The method represents the path as a \"string\" of points that connects the states and evolves it to minimize the drift along the path. The resulting tangent path is parallel to the drift of the system, i.e., the string method computes the heteroclinic orbit. For non-gradient systems (detailed -balance is broken), the heteroclinic orbit differs from the transition path, it does correctly predict, it correctly captures the deterministic dynamics from the saddle point onward (\"downhill\" portion of the path).","category":"section"},{"location":"man/largedeviations/#CriticalTransitions.min_action_method","page":"Large deviation theory","title":"CriticalTransitions.min_action_method","text":"min_action_method(sys::ContinuousTimeDynamicalSystem, x_i, x_f, T::Real; kwargs...)\n\nMinimizes an action functional to obtain a minimum action path (instanton) between an initial state x_i and final state x_f in phase space.\n\nThis algorithm uses the Optimization.jl package to minimize the specified action functional (either fw_action or om_action) for the system sys over paths connecting x_i to x_f in time T.\n\nThe path is initialized as a straight line between x_i and x_f, parameterized in time via N equidistant points and total time T. Thus, the time step between discretized path points is Delta t = TN. To set an initial path different from a straight line, see the multiple dispatch method\n\nmin_action_method(sys::ContinuousTimeDynamicalSystem, init::Matrix, T::Real; kwargs...).\n\nReturns a MinimumActionPath object containing the optimized path and the action value.\n\nKeyword arguments\n\nfunctional = \"FW\": type of action functional to minimize. Defaults to fw_action, alternative: \"OM\" for om_action.\nN = 100: number of path points to use for the discretization of the path.\nnoise_strength = nothing: noise strength for the action functional. Specify only if functional = \"OM\".\nmethod = Optimisers.Adam(): minimization algorithm (see Optimization.jl)\nad_type = Optimization.AutoFiniteDiff(): type of automatic differentiation to use (see Optimization.jl)\nmaxiter = 100: maximum number of iterations before the algorithm stops.\nabstol=1e-8: absolute tolerance of action gradient to determine convergence\nreltol=1e-8: relative tolerance of action gradient to determine convergence\nverbose = true: whether to print Optimization information during the run\nshow_progress = false: whether to print a progress bar\n\n\n\n\n\nmin_action_method(sys::ContinuousTimeDynamicalSystem, init::Matrix, T::Real; kwargs...)\n\nMinimizes the specified action functional to obtain a minimum action path (instanton) between fixed end points given a system sys and total path time T.\n\nThe initial path init must be a matrix of size (D, N), where D is the dimension of the system and N is the number of path points. The physical time of the path is specified by T, such that the time step between consecutive path points is Delta t = TN.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#CriticalTransitions.geometric_min_action_method","page":"Large deviation theory","title":"CriticalTransitions.geometric_min_action_method","text":"geometric_min_action_method(\n    sys::ContinuousTimeDynamicalSystem,\n    x_i,\n    x_f;\n    N,\n    kwargs...\n) -> MinimumActionPath{_A, _B, _C, Nothing, Nothing, Nothing, Nothing, Nothing} where {_A, _B<:Real, _C}\n\n\nComputes the minimizer of the geometric Freidlin-Wentzell action based on the geometric minimum action method (gMAM), using optimizers of OPtimization.jl or the original formulation by Heymann and Vanden-Eijnden[1]. Only Freidlin-Wentzell action has a geometric formulation.\n\nTo set an initial path different from a straight line, see the multiple dispatch method\n\ngeometric_min_action_method(sys::CoupledSDEs, init::Matrix, arclength::Real; kwargs...).\n\nKeyword arguments\n\nmaxiter::Int=100: maximum number of optimization iterations before the algorithm stops\nabstol=1e-8: absolute tolerance of action gradient to determine convergence\nreltol=1e-8: relative tolerance of action gradient to determine convergence\nmethod = Adam(): minimization algorithm (see below)\n=0.1: step size parameter in gradient descent HeymannVandenEijnden implementation.\nverbose=false: if true, print additional output\nshow_progress=true: if true, display a progress bar\n\nMinimization algorithms\n\nThe method keyword argument takes solver methods of the Optimization.jl package; alternatively, the option method = \"HeymannVandenEijnden\" implements the original gMAM algorithm [12].\n\n\n\n\n\ngeometric_min_action_method(\n    sys::ContinuousTimeDynamicalSystem,\n    init::Matrix;\n    maxiter,\n    abstol,\n    reltol,\n    method,\n    AD,\n    ϵ,\n    verbose,\n    show_progress\n) -> MinimumActionPath{_A, _B, _C, Nothing, Nothing, Nothing, Nothing, Nothing} where {_A, _B<:Real, _C}\n\n\nRuns the geometric Minimum Action Method (gMAM) to find the minimum action path (instanton) from an initial condition init, given a system sys and total arc length arclength.\n\nThe initial path init must be a matrix of size (D, N), where D is the dimension of the system and N is the number of path points.\n\nFor more information see the main method, geometric_min_action_method(sys::CoupledSDEs, x_i, x_f, arclength::Real; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#CriticalTransitions.sgmam","page":"Large deviation theory","title":"CriticalTransitions.sgmam","text":"sgmam(\n    sys::SgmamSystem,\n    x_initial::Array{T, 2};\n    ϵ,\n    iterations,\n    show_progress,\n    reltol\n) -> MinimumActionPath{_A, _B, _C, Nothing, Nothing, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}} where {_A, _B<:Real, _C}\n\n\nPerforms the simplified geometric Minimal Action Method (sgMAM) on the given system sys. Our implementation is only valid for additive noise.\n\nThis method computes the optimal path in the phase space of a Hamiltonian system that minimizes the Freidlin–Wentzell action. The Hamiltonian functions H_x and H_p define the system's dynamics in a doubled phase. The initial state x_initial is evolved iteratively using constrained gradient descent with step size parameter ϵ over a specified number of iterations. The method can display a progress meter and will stop early if the relative tolerance reltol is achieved.\n\nThe function returns a tuple containing the final state, the action value, the Lagrange multipliers, the momentum, and the state derivatives. The implementation is based on the work of Grafke et al. (2019).\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#CriticalTransitions.SgmamSystem","page":"Large deviation theory","title":"CriticalTransitions.SgmamSystem","text":"A structure representing a system with Hamiltonian functions Hx and Hp.\n\nThis system operates in an extended phase space where the Hamiltonian is assumed to be quadratic in the extended momentum. The phase space coordinates x are doubled to form a 2n-dimensional extended phase space.\n\n\n\n\n\n","category":"type"},{"location":"man/largedeviations/#CriticalTransitions.MinimumActionPath","page":"Large deviation theory","title":"CriticalTransitions.MinimumActionPath","text":"struct MinimumActionPath{D, T<:Real, V, Phis, Ahis, Lambda, PV, GPV}\n\nThe minimum action path between two points in a D-dimensional phase space.\n\nFields\n\npath::StateSpaceSet{D, T, V} where {D, T<:Real, V}: The path matrix.\naction::Real: The action value associated to the path.\npath_history::Any: The history of action of the paths in the optimisation algorithm (optional).\naction_history::Any: The history of action of the paths in the optimisation algorithm (optional).\nλ::Any: The Lagrange multiplier parameter for the minimum action path (optional).\ngeneralized_momentum::Any: The generalized momentum of the phase space variables (optional).\npath_velocity::Any: The path velocity (optional).\n\nConstructors\n\nMinimumActionPath(\n    path,\n    action;\n    path_history,\n    action_history,\n    λ,\n    generalized_momentum,\n    path_velocity\n)\n\ndefined at /home/runner/work/CriticalTransitions.jl/CriticalTransitions.jl/src/largedeviations/MinimumActionPath.jl:29.\n\n\n\n\n\n","category":"type"},{"location":"man/largedeviations/#CriticalTransitions.fw_action","page":"Large deviation theory","title":"CriticalTransitions.fw_action","text":"fw_action(sys::CoupledSDEs, path, time) -> Any\n\n\nCalculates the Freidlin-Wentzell action of a given path with time points time in a drift field specified by the deterministic dynamics f = dynamic_rule(sys) and (normalized) noise covariance matrix covariance_matrix(sys).\n\nThe path must be a (D x N) matrix, where D is the dimensionality of the system sys and N is the number of path points. The time array must have length N.\n\nReturns a single number, which is the value of the action functional\n\nS_Tphi_t = frac12 int_0^T  dot phi_t - f(phi_t) ^2_Q textdt\n\nwhere phi_t denotes the path in state space, b the drift field, and T the total time of the path. The subscript Q refers to the generalized norm a_Q^2 = langle a Q^-1 b rangle (see anorm). Here Q is the noise covariance matrix normalized by DL_1(Q), with L_1 being the L1 matrix norm.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#CriticalTransitions.geometric_action","page":"Large deviation theory","title":"CriticalTransitions.geometric_action","text":"geometric_action(sys::CoupledSDEs, path) -> Any\ngeometric_action(sys::CoupledSDEs, path, arclength) -> Any\n\n\nCalculates the geometric action of a given path with specified arclength for the drift field specified by the deterministic dynamics f = dynamic_rule(sys) and (normalized) noise covariance matrix covariance_matrix(sys).\n\nFor a given path varphi, the geometric action bar S corresponds to the minimum of the Freidlin-Wentzell action S_T(varphi) over all travel times T0, where varphi denotes the path's parameterization in physical time (see fw_action). It is given by the integral\n\nbar Svarphi = int_0^L left( varphi_Q  f(varphi)_Q - langle varphi      f(varphi) rangle_Q right)  textds\n\nwhere s is the arclength coordinate, L the arclength, f the drift field, and the subscript Q refers to the generalized dot product langle a b rangle_Q = a^top cdot Q^-1 b (see anorm). Here Q is the noise covariance matrix normalized by DL_1(Q), with L_1 being the L1 matrix norm.\n\nReturns the value of the geometric action bar S.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#CriticalTransitions.om_action","page":"Large deviation theory","title":"CriticalTransitions.om_action","text":"om_action(sys::CoupledSDEs, path, time, noise_strength)\n\nCalculates the Onsager-Machlup action of a given path with time points time for the drift field f = dynamic_rule(sys) at given noise_strength.\n\nThe path must be a (D x N) matrix, where D is the dimensionality of the system sys and N is the number of path points. The time array must have length N.\n\nReturns a single number, which is the value of the action functional\n\nS^sigma_Tphi_t = frac12 int_0^T left(  dot phi_t - f(phi_t) ^2_Q + sigma^2 nabla cdot f right)  textd t\n\nwhere phi_t denotes the path in state space, b the drift field, T the total time of the path, and sigma the noise strength. The subscript Q refers to the generalized norm a_Q^2 = langle a Q^-1 b rangle (see anorm). Here Q is the noise covariance matrix normalized by DL_1(Q), with L_1 being the L1 matrix norm.\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#CriticalTransitions.action","page":"Large deviation theory","title":"CriticalTransitions.action","text":"action(\n    sys::CoupledSDEs,\n    path::Matrix,\n    time,\n    functional;\n    noise_strength\n) -> Any\n\n\nComputes the action functional specified by functional for a given CoupledSDEs sys and path parameterized by time.\n\nfunctional = \"FW\": Returns the Freidlin-Wentzell action (fw_action)\nfunctional = \"OM\": Returns the Onsager-Machlup action (om_action)\n\n\n\n\n\n","category":"function"},{"location":"man/largedeviations/#CriticalTransitions.string_method","page":"Large deviation theory","title":"CriticalTransitions.string_method","text":"string_method(\n    sys::Union{Function, SgmamSystem},\n    x_initial::Matrix;\n    ϵ,\n    iterations,\n    show_progress\n) -> Any\n\n\nCompute the string method for a given system using E et al. (2007).\n\nThe string method is an iterative algorithm used to find minimum energy path (MEP) between two points in phase space. It works by evolving a discretized path (string) according to the system's drift while maintaining equal arc-length parametrization between points.\n\nThis implementation allows for computation between arbitrary points, not just stable fixed points.\n\nArguments\n\nsys::SgmamSystem: The doubled phase space system for which the string method is computed\nx_initial: Initial path discretized as a matrix where each column represents a point on the path\nϵ::Real: Step size for the evolution step\niterations::Int64: Maximum number of iterations for path convergence\nshow_progress::Bool: Whether to display a progress meter during computation\n\nReturns\n\nx: The final converged path representing the MEP\n\n\n\n\n\nstring_method(\n    sys::ContinuousTimeDynamicalSystem,\n    init;\n    kwargs...\n) -> Any\n\n\nCompute the string method for a given system using E et al. (2007).\n\nThe string method is an iterative algorithm used to find minimum energy path (MEP) between two points in phase space. It works by evolving a discretized path (string) according to the system's drift while maintaining equal arc-length parametrization between points.\n\nThis implementation allows for computation between arbitrary points, not just stable fixed points.\n\nArguments\n\nsys::CoupledSDEs: The system for which the string method is computed\nx_initial: Initial path discretized as a matrix where each column represents a point on the path\nϵ::Real: Step size for the evolution step\niterations::Int64: Maximum number of iterations for path convergence\nshow_progress::Bool: Whether to display a progress meter during computation\n\nReturns\n\nx: The final converged path representing the MEP\n\n\n\n\n\n","category":"function"},{"location":"man/transition_path_theory/#Transition-Path-Theory","page":"Transition path theory","title":"Transition Path Theory","text":"Transition Path Theory (TPT) provides a framework for analyzing rare transition events between metastable states in complex systems. This module implements TPT calculations for two-dimensional Langevin systems. The work is base on the theory presented in [15–17] and this python github repo.\n\nwarning: Experimental\nThe functionality provided here is considered experimental and is currently restricted to two-dimensional Langevin dynamics of a particle exposed to a potential U. Hence, the current API is not exported and should be loaded explicitly. We recommend checking out the Transition Path Theory example for a demonstration of the available functionality.\n\nWe consider a Langevin system described by the following stochastic differential equations (SDEs):\n\nbeginaligned\ndot x = p  \ndot p = - gamma p - nabla U(x) + sqrt2gammabeta^-1 dot W_t \nendaligned\n\nwhere x and p are the position and momentum of the particle, gamma is the damping constant, beta = 1k_BT is the inverse temperature and W_t denotes a standard Wiener process.\n\nTo make the code more general, we need to implement the necessary methods for higher-dimensional systems and adapt the API accordingly. ","category":"section"},{"location":"man/transition_path_theory/#Theory-overview","page":"Transition path theory","title":"Theory overview","text":"TPT characterizes transition pathways between two metastable states A and B by computing:\n\nForward and backward committor functions\nReactive probability density\nReactive current\nTransition rates\n\nThe calculations are performed on a triangulated mesh representing the system's state space.","category":"section"},{"location":"man/transition_path_theory/#Committor-functions","page":"Transition path theory","title":"Committor functions","text":"","category":"section"},{"location":"man/transition_path_theory/#Invariant-probability-density","page":"Transition path theory","title":"Invariant probability density","text":"","category":"section"},{"location":"man/transition_path_theory/#Reactive-current","page":"Transition path theory","title":"Reactive current","text":"CriticalTransitions.reactive_current","category":"section"},{"location":"man/transition_path_theory/#Probability-calculations","page":"Transition path theory","title":"Probability calculations","text":"","category":"section"},{"location":"man/transition_path_theory/#References","page":"Transition path theory","title":"References","text":"E. Vanden-Eijnden. Transition Path Theory. In: Computer Simulations in Condensed Matter Systems: From Materials to Chemical Biology Volume 1, edited by M. Ferrario, G. Ciccotti and K. Binder (Springer, Berlin, Heidelberg, 2006); pp. 453–493. Accessed on Aug 2, 2025.\n\n\n\nW. E and E. Vanden-Eijnden. Transition-Path Theory and Path-Finding Algorithms for the Study of Rare Events. Annual Review of Physical Chemistry 61, 391–420 (2010). Accessed on Aug 2, 2025. Publisher: Annual Reviews.\n\n\n\nW. E. and E. Vanden-Eijnden. Towards a Theory of Transition Paths. Journal of Statistical Physics 123, 503–523 (2006). Accessed on Aug 2, 2025.\n\n\n\n","category":"section"},{"location":"man/transition_path_theory/#CriticalTransitions.LangevinSystem","page":"Transition path theory","title":"CriticalTransitions.LangevinSystem","text":"struct LangevinSystem{H, D, KE, T}\n\nA stochastic dynamical system obeying Langevin dynamics of the form.\n\ndot x = p  \ndot p = - gamma p - nabla U(x) + sqrt2gammabeta^-1 dot W_t \n\nwith damping coefficient gamma and inverse temperature beta. The Hamiltonian H = U + K is given by the potential energy U and kinetic energy K = p^22.\n\nFields\n\nHamiltonian::Any: Function that computes the total energy (kinetic + potential) of the system.\ndriftfree::Any: Function representing the divergence-free part of the drift.\nkinetic::Any: Function giving the kinetic energy of the system.\ngamma::Any: Damping coefficient that determines the strength of friction.\nbeta::Any: Inverse temperature parameter (β = 1/kT) that sets the noise intensity.\n\nConstructors\n\nLangevinSystem(Hamiltonian, driftfree, kinetic, gamma, beta)\n\ndefined at /home/runner/work/CriticalTransitions.jl/CriticalTransitions.jl/src/experimental/transition_path_theory/langevin.jl:20.\n\n\n\n\n\n","category":"type"},{"location":"man/transition_path_theory/#CriticalTransitions.committor","page":"Transition path theory","title":"CriticalTransitions.committor","text":"committor(\n    sys::CriticalTransitions.LangevinSystem,\n    mesh::CriticalTransitions.Mesh,\n    Aind,\n    Bind\n) -> Vector{Float64}\n\n\nSolve the committor equation for a two-dimensional Langevin system using finite elements.\n\nArguments\n\nsys::LangevinSystem: The Langevin system containing kinetic energy, drift-free function, beta, and gamma.\nmesh::Mesh: The mesh containing points and triangles.\nAind::Vector{Int}: Indices of mesh points corresponding to set A (Dirichlet boundary condition = 0).\nBind::Vector{Int}: Indices of mesh points corresponding to set B (Dirichlet boundary condition = 1).\n\nReturns\n\nA vector of committor values of length N, where each entry corresponds to a mesh node.\n\nImplementation Details\n\nThis function assembles a global matrix A and right-hand-side vector b for the finite element discretization of the committor equation in Langevin dynamics. The code imposes Dirichlet boundary conditions on specified nodes (Aind set to 0, Bind set to 1). It computes elementwise contributions with stima_Langevin and stimavbdv, applying exponential factors involving beta and gamma to incorporate potential and damping effects. Finally, it solves the resulting linear system for the committor values on the free (non-boundary) nodes.\n\n\n\n\n\n","category":"function"},{"location":"man/transition_path_theory/#CriticalTransitions.invariant_pdf","page":"Transition path theory","title":"CriticalTransitions.invariant_pdf","text":"invariant_pdf(\n    sys::CriticalTransitions.LangevinSystem,\n    mesh::CriticalTransitions.Mesh,\n    Amesh::CriticalTransitions.Mesh,\n    Bmesh::CriticalTransitions.Mesh\n) -> Any\n\n\nCompute the invariant probability density function (PDF) for a Langevin system over a given mesh.\n\nArguments\n\nsys::LangevinSystem: The Langevin system containing the Hamiltonian and beta parameters.\nmesh::Mesh: The main mesh containing points and triangles.\nAmesh::Mesh: The mesh corresponding to region A.\nBmesh::Mesh: The mesh corresponding to region B.\n\nReturns\n\nA scalar value representing the normalization constant Z of the invariant PDF.\n\nImplementation Details\n\nThis function calculates the invariant PDF by integrating the exponential of the negative Hamiltonian over the areas of the triangles in the provided meshes. The normalization constant Z is computed by summing the contributions from the main mesh, region A mesh, and region B mesh.\n\n\n\n\n\n","category":"function"},{"location":"man/transition_path_theory/#CriticalTransitions.probability_reactive","page":"Transition path theory","title":"CriticalTransitions.probability_reactive","text":"probability_reactive(\n    sys::CriticalTransitions.LangevinSystem,\n    mesh::CriticalTransitions.Mesh,\n    q,\n    qminus,\n    Z\n) -> Any\n\n\nCalculate the probability that a trajectory is reactive (transitions from A to B).\n\nArguments\n\nsys::LangevinSystem: System with Hamiltonian and inverse temperature (beta)\nmesh::Mesh: Mesh structure containing points and triangulation\nq: Forward committor function values\nqminus: Backward committor function values\nZ: Partition function value\n\nReturns\n\nProbability (float) of reactive trajectories normalized by partition function\n\n\n\n\n\n","category":"function"},{"location":"man/transition_path_theory/#CriticalTransitions.probability_last_A","page":"Transition path theory","title":"CriticalTransitions.probability_last_A","text":"probability_last_A(\n    sys::CriticalTransitions.LangevinSystem,\n    mesh::CriticalTransitions.Mesh,\n    Ames::CriticalTransitions.Mesh,\n    qminus,\n    Z\n) -> Any\n\n\nCalculate the probability that the last visited metastable state was A.\n\nArguments\n\nsys::LangevinSystem: System with Hamiltonian and inverse temperature (beta)\nmesh::Mesh: Main mesh structure containing points and triangulation\nAmes::Mesh: Mesh structure for region A\nqminus: Backward committor function values\nZ: Partition function value\n\nReturns\n\nProbability (float) that the system was last in state A, normalized by partition function\n\n\n\n\n\n","category":"function"},{"location":"refs/#References","page":"References","title":"References","text":"P. M. Battelino, C. Grebogi, E. Ott, J. A. Yorke and E. D. Yorke. Multiple coexisting attractors, basin boundaries and basic sets. Physica D: Nonlinear Phenomena 32, 296–305 (1988).\n\n\n\nJ. D. Skufca, J. A. Yorke and B. Eckhardt. Edge of chaos in a parallel shear flow. Physical review letters 96, 174101 (2006).\n\n\n\nO. Mehling, R. Börner and V. Lucarini. Limits to predictability of the asymptotic state of the Atlantic Meridional Overturning Circulation in a conceptual climate model. Physica D: Nonlinear Phenomena 459, 134043 (2024).\n\n\n\nT. M. Schneider, J. F. Gibson, M. Lagha, F. De Lillo and B. Eckhardt. Laminar-turbulent boundary in plane Couette flow. Physical Review E 78, 037301 (2008).\n\n\n\nA. Wagemakers, A. Daza and M. A. Sanjuán. The saddle-straddle method to test for Wada basins. Communications in Nonlinear Science and Numerical Simulation 84, 105167 (2020).\n\n\n\nV. Lucarini and T. Bódai. Edge states in the climate system: exploring global instabilities and critical transitions. Nonlinearity 30, R32 (2017).\n\n\n\nR. Börner, R. Deeley, R. Römer, T. Grafke, V. Lucarini and U. Feudel. Saddle avoidance of noise-induced transitions in multiscale systems. Physical Review Research 6, L042053 (2024).\n\n\n\nM. I. Freidlin and A. D. Wentzell. Random perturbations of dynamical systems (Springer, 1998).\n\n\n\nR. Börner. Climate on the Edge: Metastability, Melancholia States and Critical Transitions of the Ocean Circulation. Ph.D. Thesis, University of Reading (2025).\n\n\n\nT. Grafke and E. Vanden-Eijnden. Numerical computation of rare events via large deviation theory. Chaos: An Interdisciplinary Journal of Nonlinear Science 29, 063118 (2019).\n\n\n\nW. E, W. Ren and E. Vanden-Eijnden. Minimum action method for the study of rare events. Communications on Pure and Applied Mathematics 57, 637–656 (2004).\n\n\n\nM. Heymann and E. Vanden-Eijnden. Pathways of Maximum Likelihood for Rare Events in Nonequilibrium Systems: Application to Nucleation in the Presence of Shear. Physical Review Letters 100, 140601 (2008).\n\n\n\nM. Heymann and E. Vanden-Eijnden. The geometric minimum action method: A least action principle on the space of curves. Communications on Pure and Applied Mathematics 61, 1052–1117 (2008).\n\n\n\nT. Grafke, T. Schäfer and E. Vanden-Eijnden. Long Term Effects of Small Random Perturbations on Dynamical Systems: Theoretical and Computational Tools. In: Recent Progress and Modern Challenges in Applied Mathematics, Modeling and Computational Science, edited by R. Melnik, R. Makarov and J. Belair (Springer, 2017); pp. 17–55.\n\n\n\n","category":"section"},{"location":"man/systemanalysis/#Analyzing-a-system's-stability-properties","page":"Stability analysis","title":"Analyzing a system's stability properties","text":"To use the following functionalities, you need to load ChoasTools.jl and Attractors.jl (which are included as dependencies in CriticalTransitions.jl).","category":"section"},{"location":"man/systemanalysis/#Fixed-points","page":"Stability analysis","title":"Fixed points","text":"","category":"section"},{"location":"man/systemanalysis/#Edge-tracking","page":"Stability analysis","title":"Edge tracking","text":"The edge tracking algorithm is a simple numerical method to find the edge state or (possibly chaotic) saddle on the boundary between two basins of attraction. It is first introduced by Battelino et al. [1] and further described by Skufca et al. [2] and Mehling et al. [3].","category":"section"},{"location":"man/systemanalysis/#ChaosTools.fixedpoints","page":"Stability analysis","title":"ChaosTools.fixedpoints","text":"fixedpoints(\n    sys::CoupledSDEs,\n    bmin::Vector,\n    bmax::Vector\n) -> Tuple{Any, Any, Any}\n\n\nReturns fixed points, their eigenvalues and stability of the system sys within the state space volume defined by bmin and bmax.\n\nThis is a wrapper around the fixedpoints function of DynamicalSystems.jl.\n\nInput\n\nbmin (Vector): lower limits of the state space box to be considered, as a vector of coordinates\nbmax (Vector): upper limits\nalternatively box (IntervalBox) can replace bmin and bmax\n\nExample: fixedpoints(sys, [-2,-1,0], [2,1,1]) finds the fixed points of the 3D system sys in a cube defined by the intervals [-2,2] × [-1,1] × [0,1].\n\nOutput\n\n[fp, eigs, stable]\n\nfp: StateSpaceSet of fixed points\neigs: vector of Jacobian eigenvalues of each fixed point\nstable: vector of booleans indicating the stability of each fixed point (true=stable, false=unstable)\n\nAdditional methods\n\nfixedpoints(sys::CoupedSDEs, box)\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#Attractors.edgetracking","page":"Stability analysis","title":"Attractors.edgetracking","text":"edgetracking(ds::DynamicalSystem, attractors::Dict; kwargs...)\n\nTrack along a basin boundary in a dynamical system ds with two or more attractors in order to find an edge state. Results are returned in the form of EdgeTrackingResults, which contains the pseudo-trajectory edge representing the track on the basin boundary, along with additional output (see below).\n\nThe system's attractors are specified as a Dict of StateSpaceSets, as in AttractorsViaProximity or the output of extract_attractors. By default, the algorithm is initialized from the first and second attractor in attractors. Alternatively, the initial states can be set via keyword arguments u1, u2 (see below). Note that the two initial states must belong to different basins of attraction.\n\nKeyword arguments\n\nbisect_thresh = 1e-7: distance threshold for bisection.\ndiverge_thresh = 1e-6: distance threshold for parallel integration.\nu1: first initial state (defaults to first point in first entry of attractors).\nu2: second initial state (defaults to first point in second entry of attractors).\nmaxiter = 100: maximum number of iterations before the algorithm stops.\nabstol = 1e-9: distance threshold for convergence of the updated edge state.\nT_transient = 0.0: transient time before the algorithm starts saving the edge track.\ntmax = Inf: maximum integration time of parallel trajectories until re-bisection.\nΔt = 0.01: time step passed to step! when evolving the two trajectories.\nshow_progress = true: if true, shows progress bar and information while running.\nverbose = true: if false, silences print output and warnings while running.\nkw...: additional keyword arguments to be passed to AttractorsViaProximity. We strongly recommend to either pass in a high Ttr, or a very small ε, (smaller than the default estimated by AttractorsViaProximity) to avoid transient parts of trajectories wrongly being classified as having converged.\n\nDescription\n\nThe edge tracking algorithm is a numerical method to find an edge state or (possibly chaotic) saddle on the boundary between two basins of attraction. Introduced by [1] and further described by [2], the algorithm has been applied to, e.g., the laminar-turbulent boundary in plane Couette flow [4], Wada basins [5], as well as Melancholia states in conceptual [3] and intermediate-complexity [6] climate models. Relying only on forward integration of the system, it works even in high-dimensional systems with complicated fractal basin boundary structures.\n\nThe algorithm consists of two main steps: bisection and tracking. First, it iteratively bisects along a straight line in state space between the intial states u1 and u2 to find the separating basin boundary. The bisection stops when the two updated states are less than bisect_thresh (Euclidean distance in state space) apart from each other. Next, a ParallelDynamicalSystem is initialized from these two updated states and integrated forward until the two trajectories diverge from each other by more than diverge_thresh (Euclidean distance). The two final states of the parallel integration are then used as new states u1 and u2 for a new bisection, and so on, until a stopping criterion is fulfilled.\n\nTwo stopping criteria are implemented via the keyword arguments maxiter and abstol. Either the algorithm stops when the number of iterations reaches maxiter, or when the state space position of the updated edge point changes by less than abstol (in Euclidean distance) compared to the previous iteration. Convergence below abstol happens after sufficient iterations if the edge state is a saddle point. However, the edge state may also be an unstable limit cycle or a chaotic saddle. In these cases, the algorithm will never actually converge to a point but (after a transient period) continue populating the set constituting the edge state by tracking along it.\n\nA central idea behind this algorithm is that basin boundaries are typically the stable manifolds of unstable sets, namely edge states or saddles. The flow along the basin boundary will thus lead to these sets, and the iterative bisection neutralizes the unstable direction of the flow away from the basin boundary. If the system possesses multiple edge states, the algorithm will find one of them depending on where the initial bisection locates the boundary.\n\nOutput\n\nReturns a data type EdgeTrackingResults containing the results.\n\nSometimes, the AttractorMapper used in the algorithm may erroneously identify both states u1 and u2 with the same basin of attraction due to being very close to the basin boundary. If this happens, a warning is raised and EdgeTrackingResults.success = false.\n\n\n\n\n\nedgetracking(ds::CoupledSDEs, attractors::Dict; diffeq, kwars...)\n\nRuns the edge tracking algorithm for the deterministic part of the CoupledSDEs ds.\n\nKeyword arguments\n\ndiffeq=(;alg = Vern9(), reltol=1e-11): ODE solver settings\nkwargs...: all keyword arguments of Attractors.edgetracking\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#Attractors.bisect_to_edge","page":"Stability analysis","title":"Attractors.bisect_to_edge","text":"bisect_to_edge(pds::ParallelDynamicalSystem, mapper::AttractorMapper; kwargs...) -> u1, u2\n\nFinds the basin boundary between two states u1, u2 = current_states(pds) by bisecting along a straight line in phase space. The states u1 and u2 must belong to different basins.\n\nReturns a triple u1, u2, success, where u1, u2 are two new states located on either side of the basin boundary that lie less than bisect_thresh (Euclidean distance in state space) apart from each other, and success is a Bool indicating whether the bisection was successful (it may fail if the mapper maps both states to the same basin of attraction, in which case a warning is raised).\n\nKeyword arguments\n\nbisect_thresh = 1e-7: The maximum (Euclidean) distance between the two returned states.\n\nDescription\n\npds is a ParallelDynamicalSystem with two states. The mapper must be an AttractorMapper of subtype AttractorsViaProximity or AttractorsViaRecurrences.\n\ninfo: Info\nIf the straight line between u1 and u2 intersects the basin boundary multiple times, the method will find one of these intersection points. If more than two attractors exist, one of the two returned states may belong to a different basin than the initial conditions u1 and u2. A warning is raised if the bisection involves a third basin.\n\n\n\n\n\nbisect_to_edge(ds::CoupledSDEs, attractors::Dict;\n    u1, u2, bisect_thresh, diffeq, verbose, kwargs...)\n\nRuns the bisect_to_edge function for the deterministic part of the CoupledSDEs ds.\n\nKeyword arguments\n\nu1: State 1 (default: first state in attractors)\nu2: State 2 (default: second state in attractors)\nbisect_thresh=1e-6: distance threshold\ndiffeq=(;alg = Vern9(), reltol=1e-11): ODE solver settings\nverbose=false: Verbosity of output\nϵ_mapper=nothing: ϵ argument of Attractors.AttractorsViaProximity\nkwargs...: Keyword arguments passed to Attractors.AttractorsViaProximity\n\n\n\n\n\n","category":"function"},{"location":"man/systemanalysis/#Attractors.EdgeTrackingResults","page":"Stability analysis","title":"Attractors.EdgeTrackingResults","text":"EdgeTrackingResults(edge, track1, track2, time, bisect_idx)\n\nData type that stores output of the edgetracking algorithm.\n\nFields\n\nedge::StateSpaceSet: the pseudo-trajectory representing the tracked edge segment (given by the average in state space between track1 and track2)\ntrack1::StateSpaceSet: the pseudo-trajectory tracking the edge within basin 1\ntrack2::StateSpaceSet: the pseudo-trajectory tracking the edge within basin 2\ntime::Vector: time points of the above StateSpaceSets\nbisect_idx::Vector: indices of time at which a re-bisection occurred\nsuccess::Bool: indicates whether the edge tracking has been successful or not\n\n\n\n\n\n","category":"type"},{"location":"examples/RateSystem/#Example:-Defining-a-RateSystem","page":"Nonautonomous system","title":"Example: Defining a RateSystem","text":"","category":"section"},{"location":"examples/RateSystem/#Basic-concept","page":"Nonautonomous system","title":"Basic concept","text":"Consider an autonomous deterministic dynamical system ds (e.g. a CoupledODEs) of which you want to ramp one parameter, i.e. change the parameter's value over time.\n\nUsing the RateSystem type, you can easily achieve this in two steps:\n\nSpecify a ForcingProfile that describes the shape of the parameter ramping p(t) over an interval tin I\nApply this parametric forcing to the system ds by constructing a RateSystem, i.e. a nonautonomous system in which the parameters are explicitly time-dependent.\n\n(Image: Schematic explaining RateSystem construction)\n\nYou can rescale the forcing profile in system time units by specifying the start time and duration of the forcing change. Then, for\n\nt < forcing_start_time\nthe system is autonomous, with parameters given by the underlying autonomous system\nforcing_start_time < t < forcing_start_time + forcing_duration\nthe system is non-autonomous with the parameter change given by the ForcingProfile, scaled in magnitude by forcing_scale\nt > forcing_start_time + forcing_duration\nthe system is again autonomous, with parameters fixed at their values attained at the end of the forcing interval (i.e. t = forcing_start_time + forcing_duration).\n\nThis setting is widely used and convenient for studying rate-dependent tipping.","category":"section"},{"location":"examples/RateSystem/#Example","page":"Nonautonomous system","title":"Example","text":"As a simple prototypical example, let's consider the following one-dimensional autonomous system with one stable fixed point, given by the ordinary differential equation:\n\nbeginaligned\n    dotx = (x+p)^2 - 1\nendaligned\n\nThe parameter p shifts the location of the equilibria dot x = 0. We implement this system as follows:\n\nusing CriticalTransitions\n\nfunction f(u, p, t)\n    x = u[1]\n    dx = (x + p[1])^2 - 1\n    return SVector{1}(dx)\nend\n\nx0 = [-1.0] # Initial state\np0 = [0.0]  # Initial parameter value\n\nds = CoupledODEs(f, x0, p0) # Autonomous system\n\nNow, we want to explore a non-autonomous version of this system by applying a parameter change over a given time interval.","category":"section"},{"location":"examples/RateSystem/#Forcing-profile","page":"Nonautonomous system","title":"Forcing profile","text":"First, create a ForcingProfile to specify the functional form of the parameter change p(t), here a hyperbolic tangent:\n\nprofile(t) = tanh(t)\ninterval = (-5.0, 5.0)\n\nfp = ForcingProfile(profile, interval)\n\nLet's plot the forcing profile:\n\nusing CairoMakie\n\ntime_range = range(fp.interval[1], fp.interval[2]; length=100);\n\nfig = Figure();\nax = Axis(fig[1, 1]; xlabel=\"t (arbitrary units)\", ylabel=\"profile (arbitrary units)\");\nlines!(ax, time_range, fp.profile.(time_range); linewidth=2);\nfig\n\nNote that the interval is given in arbitrary units - the profile is rescaled to your system's units in the next step.","category":"section"},{"location":"examples/RateSystem/#Applying-the-forcing","page":"Nonautonomous system","title":"Applying the forcing","text":"Now, specify how the forcing profile fp should be applied to the pidx-th parameter of your system ds by constructing a RateSystem.\n\npidx = 1                    # parameter index\nforcing_start_time = 20.0   # system time units\nforcing_duration = 105.0    # system time units\nforcing_scale = 3.0\nt0 = 0.0                    # system initial time\n\nrs = RateSystem(ds, fp, pidx;\n    forcing_start_time, forcing_duration, forcing_scale, t0)\n\nThe forcing_scale is a multiplication factor that scales the profile fp.profile. Here, we have p(5)-p(-5) approx 2, so the amplitude of the parameter change is 6 after multiplying with forcing_scale = 3.\n\nIn the RateSystem, the time dependence of the parameter p[pidx] thus looks like this:\n\nT = forcing_duration + 40.0 # Total time\nt_points = range(t0, t0+T, length=100)\n\nparameter(t) = parameters(rs, t)[pidx] # Returns the parameter value at time t\n\nfig = Figure();\nax = Axis(fig[1, 1]; xlabel=\"Time (system units)\", ylabel=\"p[1]\");\nlines!(ax, t_points, parameter.(t_points); linewidth=2);\nfig\n\ntip: Modifying the forcing\nIn a RateSystem, the forcing can easily be modified to implement different forcing rates and forcing amplitudes.Via set_forcing_duration!(rs, length), you can change the length of the forcing interval and thus the rate of change of the forcing.\nVia set_forcing_scale!(rs, factor), you can change the magnitude of the forcing by a given factor.","category":"section"},{"location":"examples/RateSystem/#Simulating-trajectories","page":"Nonautonomous system","title":"Simulating trajectories","text":"The RateSystem type behaves just like the type of underlyinh autonomous system, in this case a CoupledODEs. Thus, we can simply call the trajectory function to simulate either the autonomous system ds or the nonautonomous system rs.\n\ntraj_ds = trajectory(ds, T, x0)\ntraj_rs = trajectory(rs, T, x0)\n\nLet's compare the two trajectories:\n\nfig = Figure();\naxs = Axis(fig[1, 1]; xlabel=\"Time\", ylabel=\"x\");\nlines!(\n    axs,\n    t0 .+ traj_ds[2],\n    traj_ds[1][:, 1];\n    linewidth=2,\n    label=\"Autonomous CoupledODEs (ds)\",\n);\nlines!(\n    axs,\n    traj_rs[2],\n    traj_rs[1][:, 1];\n    linewidth=2,\n    label=\"Nonautonomous RateSystem (rs)\",\n);\naxislegend(axs; position=:lb);\nfig\n\nWhile the autonomous system ds remains at the fixed point x^*=-1, the nonautonomous system tracks the moving equilibrium until reaching the stable fixed point x^*=-7 of the future limit system (i.e. the autonomous limit system after the parameter change) where p=6.","category":"section"},{"location":"man/system_construction/#Defining-a-forced-dynamical-system","page":"Define your system","title":"Defining a forced dynamical system","text":"This section explains how to specify your dynamical system and forcing of interest.\n\nTo specify a system, CriticalTransitions provides three core system types:\n\nCoupledODEs - used to define a deterministic system of ordinary differential equations  of the form fractextdmathbfutextdt = mathbff(mathbfu p t).\nCoupledSDEs - used to define a system of stochastic differential equations of the form textdmathbfu = mathbff(mathbfu p t) textdt + mathbfg(mathbfu p t) textdmathcalN_t.\nRateSystem - used to define a non-autonomous system with parametric forcing of the form fractextdmathbfutextdt = mathbff(mathbfu(t) p(t)).\n\nThe CoupledODEs and CoupledSDEs system types are inherited from DynamicalSystemsBase.jl. The RateSystem type is added in CriticalTransitions.jl to enable easy construction of non-autonomous dynamical systems in which a parameter changes over time.","category":"section"},{"location":"man/system_construction/#Deterministic:-CoupledODEs","page":"Define your system","title":"Deterministic: CoupledODEs","text":"","category":"section"},{"location":"man/system_construction/#Stochastic:-CoupledSDEs","page":"Define your system","title":"Stochastic: CoupledSDEs","text":"tip: Tip\nCheck out some examples of how to construct different types of stochastic dynamics here.\n\ninfo: Info\nNote that nonlinear mixings of the Noise Process mathcalW fall into the class of random ordinary differential equations (RODEs) which have a separate set of solvers. See this example of DifferentialEquations.jl.","category":"section"},{"location":"man/system_construction/#CoupledSDEs-API","page":"Define your system","title":"CoupledSDEs API","text":"","category":"section"},{"location":"man/system_construction/#Non-autonomous:-RateSystem","page":"Define your system","title":"Non-autonomous: RateSystem","text":"(Image: Schematic explaining RateSystem construction)","category":"section"},{"location":"man/system_construction/#RateSystem-API","page":"Define your system","title":"RateSystem API","text":"","category":"section"},{"location":"man/system_construction/#Converting-between-systems","page":"Define your system","title":"Converting between systems","text":"The deterministic part of a CoupledSDEs can be extracted as a  CoupledODEs, making it compatible with functionality of DynamicalSystems.jl. In turn, a CoupledODEs can easily be extended into a CoupledSDEs.\n\nFor example, the Lyapunov spectrum of a CoupledSDEs in the absence of noise, here exemplified by the FitzHugh-Nagumo model, can be computed by typing:\n\nusing CriticalTransitions\nusing ChaosTools: lyapunovspectrum\n\nfunction fitzhugh_nagumo(u, p, t)\n    x, y = u\n    ϵ, β = p\n    dx = (-x^3 + x - y)/ϵ\n    dy = -β*y + x\n    return SVector{2}([dx, dy])\nend\n\np = [1.,3.]\n\n# Define the CoupledSDEs\nsys = CoupledSDEs(fitzhugh_nagumo, ones(2), p; noise_strength=0.1)\n\n# Compute Lyapunov spectrum of deterministic flow\nls = lyapunovspectrum(CoupledODEs(sys), 10000)","category":"section"},{"location":"man/system_construction/#DynamicalSystemsBase.CoupledODEs","page":"Define your system","title":"DynamicalSystemsBase.CoupledODEs","text":"CoupledODEs <: ContinuousTimeDynamicalSystem\nCoupledODEs(f, u0 [, p]; diffeq, t0 = 0.0)\n\nA deterministic continuous time dynamical system defined by a set of coupled ordinary differential equations as follows:\n\nfracdvecudt = vecf(vecu p t)\n\nAn alias for CoupledODE is ContinuousDynamicalSystem.\n\nOptionally provide the parameter container p and initial time as keyword t0.\n\nFor construction instructions regarding f, u0 see the DynamicalSystems.jl tutorial.\n\nDifferentialEquations.jl interfacing\n\nThe ODEs are evolved via the solvers of DifferentialEquations.jl. When initializing a CoupledODEs, you can specify the solver that will integrate f in time, along with any other integration options, using the diffeq keyword. For example you could use diffeq = (abstol = 1e-9, reltol = 1e-9). If you want to specify a solver, do so by using the keyword alg, e.g.: diffeq = (alg = Tsit5(), reltol = 1e-6). This requires you to have been first using OrdinaryDiffEq (or smaller library package such as OrdinaryDiffEqVerner) to access the solvers. The default diffeq is:\n\n(alg = OrdinaryDiffEqTsit5.Tsit5{typeof(OrdinaryDiffEqCore.triviallimiter!), typeof(OrdinaryDiffEqCore.triviallimiter!), Static.False}(OrdinaryDiffEqCore.triviallimiter!, OrdinaryDiffEqCore.triviallimiter!, static(false)), abstol = 1.0e-6, reltol = 1.0e-6)\n\ndiffeq keywords can also include callback for event handling .\n\nThe convenience constructors CoupledODEs(prob::ODEProblem [, diffeq]) and CoupledODEs(ds::CoupledODEs [, diffeq]) are also available. Use ODEProblem(ds::CoupledODEs, tspan = (t0, Inf)) to obtain the problem.\n\nTo integrate with ModelingToolkit.jl, the dynamical system must be created via the ODEProblem (which itself is created via ModelingToolkit.jl), see the Tutorial for an example.\n\nDev note: CoupledODEs is a light wrapper of ODEIntegrator from DifferentialEquations.jl.\n\n\n\n\n\n","category":"type"},{"location":"man/system_construction/#DynamicalSystemsBase.CoupledSDEs","page":"Define your system","title":"DynamicalSystemsBase.CoupledSDEs","text":"CoupledSDEs <: ContinuousTimeDynamicalSystem\nCoupledSDEs(f, u0 [, p]; kwargs...)\n\nA stochastic continuous time dynamical system defined by a set of coupled stochastic differential equations (SDEs) as follows:\n\ntextdmathbfu = mathbff(mathbfu p t) textdt + mathbfg(mathbfu p t) textdmathcalN_t\n\nwhere mathbfu(t) is the state vector at time t, mathbff describes the deterministic dynamics, and the noise term mathbfg(mathbfu p t) textdmathcalN_t describes the stochastic forcing in terms of a noise function (or diffusion function) mathbfg and a noise process mathcalN_t. The parameters of the functions mathcalf and mathcalg are contained in the vector p.\n\nThere are multiple ways to construct a CoupledSDEs depending on the type of stochastic forcing.\n\nThe only required positional arguments are the deterministic dynamic rule f(u, p, t), the initial state u0, and optinally the parameter container p (by default p = nothing). For construction instructions regarding f, u0 see the DynamicalSystems.jl tutorial .\n\nBy default, the noise term is standard Brownian motion, i.e. additive Gaussian white noise with identity covariance matrix. To construct different noise structures, see below.\n\nNoise term\n\nThe noise term can be specified via several keyword arguments. Based on these keyword arguments, the noise function g is constructed behind the scenes unless explicitly given.\n\nThe noise strength (i.e. the magnitude of the stochastic forcing) can be scaled with noise_strength (defaults to 1.0). This factor is multiplied with the whole noise term.\nFor non-diagonal and correlated noise, a covariance matrix can be provided via covariance (defaults to identity matrix of size length(u0).)\nFor more complicated noise structures, including state- and time-dependent noise, the noise function g can be provided explicitly as a keyword argument (defaults to nothing). For construction instructions, continue reading.\n\nThe function g interfaces to the diffusion function specified in an SDEProblem of DynamicalSystems.jl. g must follow the same syntax as f, i.e., g(u, p, t) for out-of-place (oop) and g!(du, u, p, t) for in-place (iip).\n\nUnless g is of vector form and describes diagonal noise, a prototype type instance for the output of g must be specified via the keyword argument noise_prototype. It can be of any type A that has the method LinearAlgebra.mul!(Y, A, B) -> Y defined. Commonly, this is a matrix or sparse matrix. If this is not given, it defaults to nothing, which means the g should be interpreted as being diagonal.\n\nThe noise process can be specified via noise_process. It defaults to a standard Wiener process (Gaussian white noise). For details on defining noise processes, see the docs of DiffEqNoiseProcess.jl . A complete list of the pre-defined processes can be found here. Note that DiffEqNoiseProcess.jl also has an interface for defining custom noise processes.\n\nBy combining g and noise_process, you can define different types of stochastic systems. Examples of different types of stochastic systems are listed on the StochasticDiffEq.jl tutorial page. A quick overview of common types of stochastic systems can also be found in the online docs for CoupledSDEs.\n\nKeyword arguments\n\ng: noise function (default nothing)\nnoise_strength: scaling factor for noise strength (default 1.0)\ncovariance: noise covariance matrix (default nothing)\nnoise_prototype: prototype instance for the output of g (default nothing)\nnoise_process: stochastic process as provided by DiffEqNoiseProcess.jl (default nothing, i.e. standard Wiener process)\nt0: initial time (default 0.0)\ndiffeq: DiffEq solver settings (see below)\nseed: random number seed (default UInt64(0))\n\nDifferentialEquations.jl interfacing\n\nThe CoupledSDEs is evolved using the solvers of DifferentialEquations.jl. To specify a solver via the diffeq keyword argument, use the flag alg, which can be accessed after loading StochasticDiffEq.jl (using StochasticDiffEq). The default diffeq is:\n\n(alg = SOSRA(), abstol = 1.0e-2, reltol = 1.0e-2)\n\ndiffeq keywords can also include a callback for event handling .\n\nDev note: CoupledSDEs is a light wrapper of  SDEIntegrator from StochasticDiffEq.jl. The integrator is available as the field integ, and the SDEProblem is integ.sol.prob. The convenience syntax SDEProblem(ds::CoupledSDEs, tspan = (t0, Inf)) is available to extract the problem.\n\nConverting between CoupledSDEs and CoupledODEs\n\nYou can convert a CoupledSDEs system to CoupledODEs to analyze its deterministic part using the function CoupledODEs(ds::CoupledSDEs; diffeq, t0). Similarly, use CoupledSDEs(ds::CoupledODEs, p; kwargs...) to convert a CoupledODEs into a CoupledSDEs.\n\n\n\n\n\n","category":"type"},{"location":"man/system_construction/#CriticalTransitions.solver","page":"Define your system","title":"CriticalTransitions.solver","text":"solver(ds::ContinuousTimeDynamicalSystem) -> Any\n\n\nReturns the SDE solver specified in the diffeq settings of the CoupledSDEs.\n\n\n\n\n\n","category":"function"},{"location":"man/system_construction/#CriticalTransitions.drift","page":"Define your system","title":"CriticalTransitions.drift","text":"drift(\n    sys::Union{CoupledODEs{IIP}, CoupledSDEs{IIP}},\n    x;\n    t\n) -> Any\n\n\nReturns the deterministic drift f(x) of the CoupledSDEs sys at state x. For time-dependent systems, the time can be specified as a keyword argument t (by default t=0).\n\n\n\n\n\n","category":"function"},{"location":"man/system_construction/#CriticalTransitions.div_drift","page":"Define your system","title":"CriticalTransitions.div_drift","text":"div_drift(sys::ContinuousTimeDynamicalSystem, x) -> Any\ndiv_drift(sys::ContinuousTimeDynamicalSystem, x, t) -> Any\n\n\nComputes the divergence of the drift field f(x) at state x. For time- dependent systems, the time can be specified as a keyword argument t (by default t=0).\n\n\n\n\n\n","category":"function"},{"location":"man/system_construction/#StochasticSystemsBase.covariance_matrix","page":"Define your system","title":"StochasticSystemsBase.covariance_matrix","text":"covariance_matrix(ds::CoupledSDEs)\n\nReturns the covariance matrix of the stochastic term of the CoupledSDEs ds, provided that the diffusion function g can be expressed as a constant invertible matrix. If this is not the case, returns nothing.\n\nSee also diffusion_matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/system_construction/#StochasticSystemsBase.diffusion_matrix","page":"Define your system","title":"StochasticSystemsBase.diffusion_matrix","text":"diffusion_matrix(ds::CoupledSDEs)\n\nReturns the diffusion matrix of the stochastic term of the CoupledSDEs ds, provided that the diffusion function g can be expressed as a constant invertible matrix. If this is not the case, returns nothing.\n\nNote: The diffusion matrix Σ is the square root of the noise covariance matrix Q (see covariance_matrix), defined via the Cholesky decomposition Q = Σ Σ^top.\n\n\n\n\n\n","category":"function"},{"location":"man/system_construction/#CriticalTransitions.noise_process","page":"Define your system","title":"CriticalTransitions.noise_process","text":"noise_process(sys::CoupledSDEs) -> Any\n\n\nFetches the stochastic process mathcalN specified in the intergrator of sys. Returns the type DiffEqNoiseProcess.NoiseProcess.\n\n\n\n\n\n","category":"function"},{"location":"man/system_construction/#CriticalTransitions.RateSystem","page":"Define your system","title":"CriticalTransitions.RateSystem","text":"RateSystem <: ContinuousTimeDynamicalSystem\nRateSystem(ds::ContinuousTimeDynamicalSystem, fp::ForcingProfile, pidx; kwargs...)\n\nA non-autonomous dynamical system constructed by applying a time-dependent parametric forcing protocol (ForcingProfile) to an underlying autonomous continuous-time dynamical system ds.\n\nThe ForcingProfile, applied to the parameter with index pidx, describes the functional form of the parameter evolution over a given interval. This interval is rescaled in system time units by defining its start time (forcing_start_time) and duration (forcing_duration). The magnitude of the forcing can be adjusted by scaling the forcing profile by a factor forcing_scale.\n\nThe integer pidx refers to the relevant index of the parameter container p of ds.\n\nBefore t = forcing_start_time, the system parameters correspond to that of the underlying autonomous system ds. At the end of the forcing interval (t = forcing_start_time + forcing_duration), the parameters are frozen at their current value and thereafter the system is again autonomous.\n\nKeyword arguments\n\nforcing_start_time = fp.interval[1]: Time when parameter change starts\nforcing_duration = fp.interval[2] - fp.interval[1]: Duration of the parameter change (in system time units)\nforcing_scale = 1.0: Amplitude multiplication factor of the forcing protocol\nt0 = 0.0: Initial time of the system\n\n\n\n\n\n","category":"type"},{"location":"man/system_construction/#CriticalTransitions.ForcingProfile","page":"Define your system","title":"CriticalTransitions.ForcingProfile","text":"ForcingProfile(profile::Function, interval)\n\nTime-dependent forcing profile p(t) describing the evolution of a parameter over a domain interval interval = (start, end). Used to define a parametric forcing when  constructing a non-autonomous RateSystem.\n\nKeyword arguments\n\nprofile: function p(t) from ℝ  ℝ describing the parameter change\ninterval: domain interval over which the profile is considered\n\nNote: The units of t are arbitrary; the forcing profile is rescaled in system time units and magnitude when using it to construct a RateSystem.\n\nConvenience functions\n\nForcingProfile(:linear): Creates a linear ramp from 0 to 1.\nForcingProfile(:tanh): Creates a hyperbolic tangent ramping from 0 to 1.\n\n\n\n\n\n","category":"type"},{"location":"man/system_construction/#CriticalTransitions.frozen_system","page":"Define your system","title":"CriticalTransitions.frozen_system","text":"frozen_system(rs::RateSystem, t) -> CoupledODEs\n\n\nReturns an autonomous dynamical system of type DynamicalSystemsBase.CoupledODEs  corresponding to the frozen system of the non-autonomous RateSystem rs at time t.\n\n\n\n\n\n","category":"function"},{"location":"man/system_construction/#CriticalTransitions.parameters","page":"Define your system","title":"CriticalTransitions.parameters","text":"parameters(rs::RateSystem, t) -> Any\n\n\nReturns the parameter vector of a RateSystem at time t (in system time units).\n\n\n\n\n\n","category":"function"},{"location":"man/system_construction/#CriticalTransitions.set_forcing_start!","page":"Define your system","title":"CriticalTransitions.set_forcing_start!","text":"set_forcing_start!(rs::RateSystem, start_time)\n\n\nSets the start time (forcing_start_time) of the forcing protocol applied to the RateSystem rs.\n\n\n\n\n\n","category":"function"},{"location":"man/system_construction/#CriticalTransitions.set_forcing_duration!","page":"Define your system","title":"CriticalTransitions.set_forcing_duration!","text":"set_forcing_duration!(\n    rs::RateSystem,\n    duration\n) -> RateSystem\n\n\nSets the duration (forcing_duration) of the forcing protocol applied to the RateSystem rs.\n\n\n\n\n\n","category":"function"},{"location":"man/system_construction/#CriticalTransitions.set_forcing_scale!","page":"Define your system","title":"CriticalTransitions.set_forcing_scale!","text":"set_forcing_scale!(rs::RateSystem, scale) -> RateSystem\n\n\nSets the amplitude (forcing_scale) of the forcing protocol applied to the RateSystem rs.\n\n\n\n\n\n","category":"function"},{"location":"man/system_construction/#DynamicalSystemsBase.CoupledODEs-Tuple{CoupledSDEs}","page":"Define your system","title":"DynamicalSystemsBase.CoupledODEs","text":"CoupledODEs(ds::CoupledSDEs; kwargs...)\n\nConverts a CoupledSDEs into a CoupledODEs by extracting the deterministic part of ds.\n\n\n\n\n\n","category":"method"},{"location":"man/system_construction/#DynamicalSystemsBase.CoupledSDEs-Tuple{CoupledODEs, Any}","page":"Define your system","title":"DynamicalSystemsBase.CoupledSDEs","text":"CoupledSDEs(ds::CoupledODEs, p; kwargs...)\n\nConverts a CoupledODEs  system into a CoupledSDEs.\n\n\n\n\n\n","category":"method"},{"location":"examples/sgMAM_KPO/","page":"Simple gMAM: Kerr Parametric Oscillator","title":"Simple gMAM: Kerr Parametric Oscillator","text":"We demonstrate the simple geometric minimum action method (sgMAM) on the Kerr parametric oscillator (KPO). The method computes the optimal path between two attractors in the phase space that minimizes the action of the system. It is a simplification of the geometric minimum action method (gMAM) by avoiding the computation of the second order derivatives of the extended Hamiltonian of the optimisation problem.\n\nusing CriticalTransitions, CairoMakie\n\nThe KPO equation is a nonlinear ordinary differential equation that describes the response of the nonlinear parametrically driven resonator at its dominant resonant condition. The equation of motion are of the form:\n\ndotmathbfx = mathbff(mathbfx) + sigmamathbfξ(t)\n\nwhere f is an autonemous drift function and and we have brownian noise ξ with intensity σ.\n\nHere we define the define the drift of each separable variable u and v. In addition, we hard-code the Jacobian of the drift function.\n\nconst λ = 3 / 1.21 * 2 / 295\nconst ω0 = 1.000\nconst ω = 1.000\nconst γ = 1 / 295\nconst η = 0\nconst α = -1\n\nfunction fu(u, v)\n    return (-4 * γ * ω * u - 2 * λ * v - 4 * (ω0 - ω^2) * v - 3 * α * v * (u^2 + v^2)) /\n           (8 * ω)\nend\nfunction fv(u, v)\n    return (-4 * γ * ω * v - 2 * λ * u + 4 * (ω0 - ω^2) * u + 3 * α * u * (u^2 + v^2)) /\n           (8 * ω)\nend\nstream(u, v) = Point2f(fu(u, v), fv(u, v))\ndfvdv(u, v) = (-4 * γ * ω + 6 * α * u * v) / (8 * ω)\ndfudu(u, v) = (-4 * γ * ω - 6 * α * u * v) / (8 * ω)\ndfvdu(u, v) = (-2 * λ + 4 * (ω0 - ω^2) + 9 * α * u^2 + 3 * α * v^2) / (8 * ω)\ndfudv(u, v) = (-2 * λ - 4 * (ω0 - ω^2) - 3 * α * u^2 - 9 * α * v^2) / (8 * ω)\n\nThe optimisation is performed in a doubled phase space, i.e., every variable of the SDE system is considered as a generelised coordinate mathbfx and gets a corresponding generalised momentum mathbfp. The makes it that also systems with dissipative flow can be solved. As such, we extend the phase space by defining the hamiltionian\n\nH = sum_i fracp_i^22 + f_i(mathbfx)p_i\n\nHence, to use the sgMAM method, we need to define the derivatives of the Hamiltonian with respect to the phase space coordinates and the generalised momentum:\n\nfunction H_x(x, p) # ℜ² → ℜ²\n    u, v = eachrow(x)\n    pu, pv = eachrow(p)\n\n    H_u = @. pu * dfudu(u, v) + pv * dfvdu(u, v)\n    H_v = @. pu * dfudv(u, v) + pv * dfvdv(u, v)\n    return Matrix([H_u H_v]')\nend\nfunction H_p(x, p) # ℜ² → ℜ²\n    u, v = eachrow(x)\n    pu, pv = eachrow(p)\n\n    H_pu = @. pu + fu(u, v)\n    H_pv = @. pv + fv(u, v)\n    return Matrix([H_pu H_pv]')\nend\n\nsys = SgmamSystem{false,2}(H_x, H_p)\n\nWe saved this function in the SgmamSystem struct. We want to find the optimal path between two attractors in the phase space. We define the initial trajectory as wiggle between the two attractors.\n\nNt = 500  # number of discrete time steps\ns = collect(range(0; stop=1, length=Nt))\n\nxa = [-0.0208, 0.0991]\nxb = -xa\nxsaddle = [0.0, 0.0]\n\nInitial trajectory\n\nxx = @. (xb[1] - xa[1]) * s + xa[1] + 4 * s * (1 - s) * xsaddle[1]\nyy = @. (xb[2] - xa[2]) * s + xa[2] + 4 * s * (1 - s) * xsaddle[2] + 0.01 * sin(2π * s)\nx_initial = Matrix([xx yy]')\n\nThe optimisation is the performed by the sgmam function:\n\nMLP = sgmam(sys, x_initial; iterations=1_000, ϵ=10e2, show_progress=false)\nx_min = MLP.path;\nnothing #hide\n\nThe function returns the optimal path x_min, the minimal action S_min, the Lagrange multipliers lambda associated with the optimal path, the optimal generalised momentum p, and the time derivative of the optimal path xdot. We can plot the initial trajectory and the optimal path:\n\nfig, ax, _ = lines(\n    x_initial[1, :], x_initial[2, :]; label=\"init\", linewidth=3, color=:black\n)\nlines!(x_min[:, 1], x_min[:, 2]; label=\"MLP\", linewidth=3, color=:red)\nstreamplot!(\n    ax,\n    stream,\n    (-0.08, 0.08),\n    (-0.15, 0.15);\n    gridsize=(20, 20),\n    arrow_size=10,\n    stepsize=0.001,\n    colormap=[:gray, :gray],\n)\naxislegend(ax)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/OC_mam/#Example:-Minimum-action-method-using-optimal-control","page":"Minimal action method: Optimal Control problem","title":"Example: Minimum action method using optimal control","text":"The Minimal Action Method is a numerical technique for finding the most probable transition pathway between stable states in stochastic dynamical systems. It achieves this by minimizing an action functional that represents the path's deviation from the deterministic dynamics, effectively identifying the path of least resistance through the system's landscape. This tutorial demonstrates how to implement MAM as an optimal control problem.","category":"section"},{"location":"examples/OC_mam/#Required-Packages","page":"Minimal action method: Optimal Control problem","title":"Required Packages","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots, Printf","category":"section"},{"location":"examples/OC_mam/#Problem-Setup","page":"Minimal action method: Optimal Control problem","title":"Problem Setup","text":"We'll consider a 2D system with a double-well flow, called the Maier-Stein model. It is a famous benchmark problem as it exhibits non-gradient dynamics with two stable equilibrium points at (-1,0) and (1,0), connected by a non-trivial transition path. The system's deterministic dynamics are given by:\n\nDefine the vector field\n\nf(u, v) = [u - u^3 - 10*u*v^2, -(1 - u^2)*v]\nf(x) = f(x...)\nnothing # hide","category":"section"},{"location":"examples/OC_mam/#Optimal-Control-Formulation","page":"Minimal action method: Optimal Control problem","title":"Optimal Control Formulation","text":"The minimal action path minimizes the deviation from the deterministic dynamics:\n\nfunction ocp(T)\n    action = @def begin\n        t ∈ [0, T], time\n        x ∈ R², state\n        u ∈ R², control\n        x(0) == [-1, 0]    # Starting point (left well)\n        x(T) == [1, 0]     # End point (right well)\n        ẋ(t) == u(t)       # Path dynamics\n        ∫(sum((u(t) - f(x(t))) .^ 2)) → min  # Minimize deviation from deterministic flow\n    end\n    return action\nend\nnothing # hide","category":"section"},{"location":"examples/OC_mam/#Initial-Guess","page":"Minimal action method: Optimal Control problem","title":"Initial Guess","text":"We provide an initial guess for the path using a simple interpolation:\n\nT = 50 # Time horizon\n\nx1(t) = -(1 - t/T) + t/T # Linear interpolation for x₁\nx2(t) = 0.3(-x1(t)^2 + 1) # Parabolic guess for x₂\n\nx(t) = [x1(t), x2(t)]\nu(t) = f(x(t))\n\ninit = (state=x, control=u) # Initial guess\nnothing # hide","category":"section"},{"location":"examples/OC_mam/#Solving-the-Problem","page":"Minimal action method: Optimal Control problem","title":"Solving the Problem","text":"We solve the problem in two steps for better accuracy:\n\nsol = solve(ocp(T); init=init, grid_size=50) # First solve with coarse grid\nsol = solve(ocp(T); init=sol, grid_size=1000) # Refine solution\nobjective(sol) # Objective value","category":"section"},{"location":"examples/OC_mam/#Visualizing-Results","page":"Minimal action method: Optimal Control problem","title":"Visualizing Results","text":"Let's plot the solution trajectory and phase space:\n\n#plot(sol)\n\nMLP = state(sol).(time_grid(sol))\nscatter(\n    first.(MLP),\n    last.(MLP);\n    title=\"Minimal Action Path\",\n    xlabel=\"u\",\n    ylabel=\"v\",\n    label=\"Transition path\",\n) # Phase space plot\n\nThe resulting path shows the most likely transition between the two stable states given a transient time T=50, minimizing the action functional while respecting the system's dynamics.","category":"section"},{"location":"examples/OC_mam/#Minimize-with-respect-to-T","page":"Minimal action method: Optimal Control problem","title":"Minimize with respect to T","text":"To find the maximum likelihood path, we also need to minimize the transient time T. Hence, we perform a discrete continuation over the parameter T by solving the optimal control problem over a continuous range of final times T, using each solution to initialize the next problem.\n\nobjectives = []\nTs = range(1, 100, 30)\nsol = solve(ocp(Ts[1]); display=false, init=init, grid_size=50)\nprintln(\" Time   Objective     Iterations\")\nfor T in Ts\n    global sol = solve(ocp(T); display=false, init=sol, grid_size=1000, tol=1e-8)\n    @printf(\"%6.2f  %9.6e  %d\\n\", T, objective(sol), iterations(sol))\n    push!(objectives, objective(sol))\nend\n\nT_min = Ts[argmin(objectives)]\nplt1 = scatter(Ts, log10.(objectives); xlabel=\"Time\", label=\"Objective (log10)\")\nvline!(plt1, [T_min]; label=\"Minimum\", z_order=:back)\nplt2 = scatter(\n    Ts[10:30], log10.(objectives[10:30]); xlabel=\"Time\", label=\"Objective (log10)\"\n)\nvline!(plt2, [T_min]; label=\"Minimum\", z_order=:back)\nplot(plt1, plt2; layout=(2, 1), size=(800, 800))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"man/sampling/#Sampling-transitions","page":"Sampling transitions","title":"Sampling transitions","text":"","category":"section"},{"location":"man/sampling/#Direct-simulation","page":"Sampling transitions","title":"Direct simulation","text":"These functions generate noise-induced transitions between a given initial and final state via Monte Carlo rejection sampling. While transition samples one transition, the transitions function generates an ensemble of transition paths. It supports parallelization on multiple threads to speed up the run.\n\nResults from the transitions function are organized in the following types:","category":"section"},{"location":"man/sampling/#Pathspace-sampling","page":"Sampling transitions","title":"Pathspace sampling","text":"todo: System-independent implementation of pathspace sampling\nWe are planning to add a general implementation of pathspace sampling as described in Börner et al. [7] (see article's Supplemental Material), where transition paths are sampled as stochastic bridges between a fixed start and end point in state space under stochastic gradient descent in pathspace.","category":"section"},{"location":"man/sampling/#CriticalTransitions.transition","page":"Sampling transitions","title":"CriticalTransitions.transition","text":"transition(\n    sys::CoupledSDEs,\n    x_i,\n    x_f;\n    radii,\n    tmax,\n    radius_directions,\n    cut_start,\n    kwargs...\n) -> Tuple{Any, Any, Bool}\n\n\nGenerates a sample transition from point x_i to point x_f.\n\nThis function simulates sys in time, starting from initial condition x_i, until entering a ball of given radius around x_f. If a seed was given to sys the solver is initialized with this seed. To change the seed you can pass a new seed to the seed keyword.\n\nKeyword arguments\n\nradii=(0.1, 0.1): radius of the ball around x_i and x_f, respectively\ntmax=1e3: maximum time until the simulation stops even x_f has not been reached\nradius_directions=1:length(sys.u): the directions in phase space to consider when calculating the radii rad_i and rad_f. Defaults to all directions. To consider only a subspace of state space, insert a vector of indices of the dimensions to be included.\ncut_start=true: if false, returns the whole trajectory up to the transition\nkwargs...: keyword arguments passed to CommonSolve.solve\n\nOutput\n\n[path, times, success]\n\npath (Matrix): transition path (size [dim × N], where N is the number of time points)\ntimes (Vector): time values (since start of simulation) of the path points (size N)\nsuccess (bool): if true, a transition occurred (i.e. the ball around x_f has been reached), else false\n\nSee also transitions, trajectory.\n\n\n\n\n\n","category":"function"},{"location":"man/sampling/#CriticalTransitions.transitions","page":"Sampling transitions","title":"CriticalTransitions.transitions","text":"transitions(\n    sys::CoupledSDEs,\n    x_i,\n    x_f;\n    ...\n) -> CriticalTransitions.TransitionEnsemble{_A, _B, EnsembleSolution{T, N, S}} where {_A, _B, T, N, S}\ntransitions(\n    sys::CoupledSDEs,\n    x_i,\n    x_f,\n    N::Int64;\n    radii,\n    tmax,\n    Nmax,\n    cut_start,\n    radius_directions,\n    show_progress,\n    EnsembleAlg,\n    kwargs...\n) -> CriticalTransitions.TransitionEnsemble{_A, _B, EnsembleSolution{T, N, S}} where {_A, _B, T, N, S}\n\n\nGenerates an ensemble of N transition samples of sys from point x_i to point x_f. The transitions is by default simulated using threading. To sample the transitions in serial, GPU or Distributed enverionment, pass the desired SciMLBase.EnsembleAlgorithm to the EnsembleAlg algorithm.\n\nKeyword arguments\n\nradii=(0.1, 0.1): radius of the ball around x_i and x_f, respectively\nNmax: number of attempts before the algorithm stops even if less than N transitions occurred.\ntmax=1e3: maximum time when the simulation stops even x_f has not been reached\nradius_directions=1:length(sys.u): the directions in phase space to consider when calculating the radii rad_i and rad_f. Defaults to all directions. To consider only a subspace of state space, insert a vector of indices of the dimensions to be included.\ncut_start=true: if false, returns the whole trajectory up to the transition\nshow_progress=true: shows a progress bar with respect to Nmax\nkwargs...: keyword arguments passed to CommonSolve.solve\n\nSee also transition.\n\nReturns a TransitionEnsemble object.\n\n\n\n\n\n","category":"function"},{"location":"man/sampling/#CriticalTransitions.TransitionEnsemble","page":"Sampling transitions","title":"CriticalTransitions.TransitionEnsemble","text":"struct TransitionEnsemble{SSS, T, ES}\n\nEnsemble of transition paths between two points in a state space.\n\nFields\n\npaths::Vector: paths sampled from the transition process\ntimes::Array{Vector{T}, 1} where T: coresponsing times of the paths\nstats::CriticalTransitions.TransitionStatistics: statistics of the ensemble\nsciml_ensemble::Any: original ensemble solution of the SciML Ensemble problem\n\nConstructors\n\nTransitionEnsemble(sim, success_rate)\n\ndefined at /home/runner/work/CriticalTransitions.jl/CriticalTransitions.jl/src/trajectories/TransitionEnsemble.jl:55.\n\n\n\n\n\n","category":"type"},{"location":"man/sampling/#CriticalTransitions.TransitionStatistics","page":"Sampling transitions","title":"CriticalTransitions.TransitionStatistics","text":"struct TransitionStatistics{T}\n\nStatistics of the ensemble of transition paths between two points in a state space.\n\nFields\n\nsuccess_rate::Any: success rate of the transition process\nresidence_time::Any: mean residence time of the transition process\ntransition_time::Any: mean transition time of the transition process\nrareness::Any: rareness of the transition process\n\nConstructors\n\nTransitionStatistics(sim, success_rate)\n\ndefined at /home/runner/work/CriticalTransitions.jl/CriticalTransitions.jl/src/trajectories/TransitionEnsemble.jl:23.\n\n\n\n\n\n","category":"type"},{"location":"man/bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"P. M. Battelino, C. Grebogi, E. Ott, J. A. Yorke and E. D. Yorke. Multiple coexisting attractors, basin boundaries and basic sets. Physica D: Nonlinear Phenomena 32, 296–305 (1988).\n\n\n\nJ. D. Skufca, J. A. Yorke and B. Eckhardt. Edge of chaos in a parallel shear flow. Physical review letters 96, 174101 (2006).\n\n\n\nO. Mehling, R. Börner and V. Lucarini. Limits to predictability of the asymptotic state of the Atlantic Meridional Overturning Circulation in a conceptual climate model. Physica D: Nonlinear Phenomena 459, 134043 (2024).\n\n\n\nT. M. Schneider, J. F. Gibson, M. Lagha, F. De Lillo and B. Eckhardt. Laminar-turbulent boundary in plane Couette flow. Physical Review E 78, 037301 (2008).\n\n\n\nA. Wagemakers, A. Daza and M. A. Sanjuán. The saddle-straddle method to test for Wada basins. Communications in Nonlinear Science and Numerical Simulation 84, 105167 (2020).\n\n\n\nV. Lucarini and T. Bódai. Edge states in the climate system: exploring global instabilities and critical transitions. Nonlinearity 30, R32 (2017).\n\n\n\nR. Börner, R. Deeley, R. Römer, T. Grafke, V. Lucarini and U. Feudel. Saddle avoidance of noise-induced transitions in multiscale systems. Physical Review Research 6, L042053 (2024).\n\n\n\nM. I. Freidlin and A. D. Wentzell. Random perturbations of dynamical systems (Springer, 1998).\n\n\n\nR. Börner. Climate on the Edge: Metastability, Melancholia States and Critical Transitions of the Ocean Circulation. Ph.D. Thesis, University of Reading (2025).\n\n\n\nT. Grafke and E. Vanden-Eijnden. Numerical computation of rare events via large deviation theory. Chaos: An Interdisciplinary Journal of Nonlinear Science 29, 063118 (2019).\n\n\n\nW. E, W. Ren and E. Vanden-Eijnden. Minimum action method for the study of rare events. Communications on Pure and Applied Mathematics 57, 637–656 (2004).\n\n\n\nM. Heymann and E. Vanden-Eijnden. Pathways of Maximum Likelihood for Rare Events in Nonequilibrium Systems: Application to Nucleation in the Presence of Shear. Physical Review Letters 100, 140601 (2008).\n\n\n\nM. Heymann and E. Vanden-Eijnden. The geometric minimum action method: A least action principle on the space of curves. Communications on Pure and Applied Mathematics 61, 1052–1117 (2008).\n\n\n\nT. Grafke, T. Schäfer and E. Vanden-Eijnden. Long Term Effects of Small Random Perturbations on Dynamical Systems: Theoretical and Computational Tools. In: Recent Progress and Modern Challenges in Applied Mathematics, Modeling and Computational Science, edited by R. Melnik, R. Makarov and J. Belair (Springer, 2017); pp. 17–55.\n\n\n\nE. Vanden-Eijnden. Transition Path Theory. In: Computer Simulations in Condensed Matter Systems: From Materials to Chemical Biology Volume 1, edited by M. Ferrario, G. Ciccotti and K. Binder (Springer, Berlin, Heidelberg, 2006); pp. 453–493. Accessed on Aug 2, 2025.\n\n\n\nW. E and E. Vanden-Eijnden. Transition-Path Theory and Path-Finding Algorithms for the Study of Rare Events. Annual Review of Physical Chemistry 61, 391–420 (2010). Accessed on Aug 2, 2025. Publisher: Annual Reviews.\n\n\n\nW. E. and E. Vanden-Eijnden. Towards a Theory of Transition Paths. Journal of Statistical Physics 123, 503–523 (2006). Accessed on Aug 2, 2025.\n\n\n\n","category":"section"},{"location":"quickstart/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"quickstart/#Installation","page":"Getting started","title":"Installation","text":"To install the Julia language, we recommend juliaup.\n\nCriticalTransitions is a registered Julia package (as of v0.7) and can be installed with the Julia package manager:\n\njulia> ]\nPkg>   add CriticalTransitions\n\nor \n\nusing Pkg; Pkg.add(\"CriticalTransitions\")\n\nThe package is currently tested to be compatible with Julia versions 1.10-1.12.","category":"section"},{"location":"quickstart/#Basic-usage","page":"Getting started","title":"Basic usage","text":"The general workflow of CriticalTransitions.jl consists of two steps, similar to DynamicalSystems.jl:\n\nDefine your dynamical system (see Defining a forced dynamical system)\nInvestigate the system by calling methods (see Index)\n\nSome methods are only loaded as extensions when loading other dependency packages (see Extensions).","category":"section"},{"location":"quickstart/#Documentation","page":"Getting started","title":"Documentation","text":"The Tutorial and code examples in the Examples section illustrate some use cases of the package. All available methods and types are documented in the Manual section (see Index for an overview).","category":"section"},{"location":"quickstart/#Index","page":"Getting started","title":"Index","text":"A quick overview of available features:\n\nDefining a system and its forcing\n\nDynamicalSystemsBase.CoupledODEs\nDynamicalSystemsBase.CoupledSDEs (alias for StochSystem)\nCriticalTransitions.RateSystem\nCriticalTransitions.ForcingProfile\n\nSystem analysis and simulation\n\nPages = [\"man/systemanalysis.md\", \"man/simulation.md\"]\n\nStochastic dynamics: Transition path sampling, large deviation theory\n\nPages = [\"man/sampling.md\", \"man/largedeviations.md\"]\n\nNonautonomous dynamics: Rate-induced tipping \n\nPages = [\"man/r-tipping.md\"]\n\nMore\n\nPages = [\"man/utils.md\"]","category":"section"},{"location":"quickstart/#Extensions","page":"Getting started","title":"Extensions","text":"Loading the ChaosTools dependency makes the functions fixedpoints and intervals_to_box available.\n\nusing CriticalTransitions\nusing ChaosTools\n\n# Now the following functions are available\nfixedpoints()\nintervals_to_box()\n\nLoading the Attractors dependency makes the functions edgetracking and bisect_to_edge available.\n\nusing CriticalTransitions\nusing Attractors\n\n# Now the following functions are available\nedgetracking()\nbisect_to_edge()","category":"section"},{"location":"#CriticalTransitions.jl","page":"Home","title":"CriticalTransitions.jl","text":"A Julia package for numerical investigation of noise- and rate-induced transitions in dynamical systems.\n\nThis package provides a toolbox for dynamical systems under time-dependent forcing, with a focus on tipping phenomena and metastability.  Building on DynamicalSystems.jl and DifferentialEquations.jl, the code adds functionality specifically to study stochastic and non-autonomous dynamics – while keeping a familiar user interface and taking advantage of the powerful existing solvers in Julia.","category":"section"},{"location":"#Purpose","page":"Home","title":"Purpose","text":"The DynamicalSystems.jl ecosystem offers various functions to simulate and analyze dynamical systems in continuous time, centered around the CoupledODEs type that interfaces with the solvers of DifferentialEquations.jl. However, dedicated functionality for stochastic and/or explicitly time-dependent dynamics has largely been missing in this framework. CriticalTransitions.jl seeks to fill this gap.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"tip: With this package, you can\neasily construct stochastic and nonautonomous dynamical systems\nefficiently sample transition path ensembles\ncalculate minimum action paths and critical forcing rates\nuse a growing toolbox of tested and documented functions implementing concepts of large deviation theory, transition path theory, and rate-induced tipping... and more, check out the Examples and Manual sections of these docs!\n\nukw: Planned features\nRare event simulation: importance sampling, AMS\nQuasipotentials: Ordered line integral method (OLIM)\nSymbolic differentiation of action functionalsMissing a feature? Open an issue and tell us about it!","category":"section"},{"location":"#People","page":"Home","title":"People","text":"Main developers:\n\nReyk Börner (@reykboerner)\nOrjan Ameye (@oameye)\nRyan Deeley (@ryandeeley)\nRaphael Römer (@raphael-roemer)\n\nThanks to George Datseris, Jeroen Wouters, Calvin Nesbitt, Tobias Grafke & Oliver Mehling.\n\nThis package got started in the EU-funded CriticalEarth project.","category":"section"}]
}

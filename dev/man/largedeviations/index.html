<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Large deviation theory · CriticalTransitions.jl</title><meta name="title" content="Large deviation theory · CriticalTransitions.jl"/><meta property="og:title" content="Large deviation theory · CriticalTransitions.jl"/><meta property="twitter:title" content="Large deviation theory · CriticalTransitions.jl"/><meta name="description" content="Documentation for CriticalTransitions.jl."/><meta property="og:description" content="Documentation for CriticalTransitions.jl."/><meta property="twitter:description" content="Documentation for CriticalTransitions.jl."/><meta property="og:url" content="https://juliadynamics.github.io/CriticalTransitions.jl/man/largedeviations/"/><meta property="twitter:url" content="https://juliadynamics.github.io/CriticalTransitions.jl/man/largedeviations/"/><link rel="canonical" href="https://juliadynamics.github.io/CriticalTransitions.jl/man/largedeviations/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.jpg" alt="CriticalTransitions.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CriticalTransitions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quickstart/">Getting started</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/tutorial/">Tutorial</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Defining a system</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/stochastic-dynamics/">Stochastic system</a></li><li><a class="tocitem" href="../../examples/RateSystem/">Nonautonomous system</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">System analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/gMAM_Maierstein/">Large deviations: Maier-Stein system</a></li><li><a class="tocitem" href="../../examples/sgMAM_KPO/">Simple gMAM: Kerr Parametric Oscillator</a></li><li><a class="tocitem" href="../../examples/OC_mam/">Minimal action method: Optimal Control problem</a></li><li><a class="tocitem" href="../../examples/potential_string/">String method: Muller-Brown potential</a></li><li><a class="tocitem" href="../../examples/transition_path_theory_double_well/">Transition path theory: Finite element method</a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../system_construction/">Define your system</a></li><li><a class="tocitem" href="../systemanalysis/">Stability analysis</a></li><li><a class="tocitem" href="../simulation/">Simulating the system</a></li><li><a class="tocitem" href="../sampling/">Sampling transitions</a></li><li class="is-active"><a class="tocitem" href>Large deviation theory</a><ul class="internal"><li><a class="tocitem" href="#Action-minimizers"><span>Action minimizers</span></a></li><li><a class="tocitem" href="#Action-functionals"><span>Action functionals</span></a></li><li><a class="tocitem" href="#String-method"><span>String method</span></a></li></ul></li><li><a class="tocitem" href="../r-tipping/">Rate-induced transitions</a></li><li><a class="tocitem" href="../transition_path_theory/">Transition path theory</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../bibliography/">Bibliography</a></li></ul></li><li><a class="tocitem" href="../../refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Large deviation theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Large deviation theory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/CriticalTransitions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/main/docs/src/man/largedeviations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Large-deviation-theory"><a class="docs-heading-anchor" href="#Large-deviation-theory">Large deviation theory</a><a id="Large-deviation-theory-1"></a><a class="docs-heading-anchor-permalink" href="#Large-deviation-theory" title="Permalink"></a></h1><p>This section applies results of large deviation theory (LDT), particularly action minimization problems for computing most probable transition paths in stochastic dynamical systems driven by weak noise. For a description of the theory, see <a href="../../refs/#freidlin_random_1998">Freidlin and Wentzell [8]</a> and [<a href="../../refs/#borner_climate_2025">9</a>]. An overview of numerical methods applying LDT is given in <a href="../../refs/#grafke_numerical_2019">Grafke and Vanden-Eijnden [10]</a>.</p><div class="admonition is-info" id="Info-1cbe1a3f19a9f912"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-1cbe1a3f19a9f912" title="Permalink"></a></header><div class="admonition-body"><p>The methods in this section apply to <span>$D$</span>-dimensional stochastic dynamical systems of the form</p><p class="math-container">\[\text{d} \mathbf{x} = \mathbf{b} (\mathbf{x}) \text{d}t + \sigma \mathbf{\Sigma} \text{d}\mathbf{W}_t \,,\]</p><p>where the drift field <span>$\mathbf{b}$</span> may be non-gradient but the noise term must consist of Gaussian noise (<span>$\mathbf{W}_t$</span> is a <span>$D$</span>-dimensional vector of independent standard Wiener processes) and a constant covariance matrix <span>$\mathbf{Q} = \mathbf{\Sigma}\mathbf{\Sigma}^\top$</span>.</p><p>This is a special case of the broader class of noise types supported by <a href="../system_construction/#DynamicalSystemsBase.CoupledSDEs"><code>CoupledSDEs</code></a>.</p></div></div><h2 id="Action-minimizers"><a class="docs-heading-anchor" href="#Action-minimizers">Action minimizers</a><a id="Action-minimizers-1"></a><a class="docs-heading-anchor-permalink" href="#Action-minimizers" title="Permalink"></a></h2><p>Several methods have been proposed to calculate transition paths that minimize a given <a href="#Action-functionals">action functional</a>. In the weak-noise limit, this minimum action path (or instanton) corresponds to the most probable transition path. While the minimum action method (MAM) is the most basic version, it is often beneficial to minimize the <a href="#Geometric-Freidlin-Wentzell-action">geometric action</a> via a time-independent version called gMAM. The problem can also be cast in a Hamiltonian form, implemented as simple gMAM (sgMAM), which can have numerical advantages.</p><p>These methods apply to non-gradient systems driven by Gaussian noise. In gradient systems, minimum action paths between attractors coincide with heteroclinic orbits, which can be computed via the so-called string method.</p><p>To summarize, the following methods are available:</p><ul><li>Minimum action method <a href="#Minimum-action-method-(MAM)">(MAM)</a></li><li>Geometric minimum action method <a href="#Geometric-minimum-action-method-(gMAM)">(gMAM)</a></li><li>Simple geometric minimum action method <a href="#Simple-geometric-minimum-action-method-(sgMAM)">(sgMAM)</a></li><li><a href="#String-method">String method</a></li></ul><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Use when</th><th style="text-align: right">Requirements (this package)</th><th style="text-align: right">Not suitable when</th></tr><tr><td style="text-align: right"><strong>MAM</strong></td><td style="text-align: right">You want a <strong>minimum action path</strong> for a specified travel time <span>$T$</span> (FW/OM action minimization).</td><td style="text-align: right"><code>CoupledSDEs</code> with <strong>additive</strong>, <strong>invertible</strong>, <strong>autonomous</strong> noise (constant covariance); discretized path uses <strong>equispaced time</strong>.</td><td style="text-align: right"><strong>Multiplicative/state-dependent noise</strong>, <strong>degenerate/non-invertible</strong> noise, <strong>non-autonomous</strong> noise; when the transition time is unknown and you want a time-reparameterization-invariant formulation (prefer gMAM/sgMAM).</td></tr><tr><td style="text-align: right"><strong>gMAM</strong></td><td style="text-align: right">You want a <strong>time-reparameterization-invariant</strong> minimum action path (no explicit optimization over <span>$T$</span>).</td><td style="text-align: right">Same as MAM for <code>CoupledSDEs</code>: <strong>additive</strong>, <strong>invertible</strong>, <strong>autonomous</strong> noise (constant covariance).</td><td style="text-align: right"><strong>Multiplicative/state-dependent</strong>, <strong>degenerate</strong>, or <strong>non-autonomous</strong> noise; if you need the Onsager–Machlup functional (only FW has a geometric formulation).</td></tr><tr><td style="text-align: right"><strong>sgMAM</strong></td><td style="text-align: right">You want a <strong>Hamiltonian/simple gMAM</strong> formulation that can be efficient in practice.</td><td style="text-align: right">Same as MAM <strong>and</strong> <strong>diagonal</strong> noise covariance (implementation restriction); assumes <strong>additive</strong> noise.</td><td style="text-align: right"><strong>Non-diagonal</strong> covariance; <strong>multiplicative/state-dependent</strong> or <strong>degenerate</strong> noise; models where the required derivatives/Jacobian are not available or are too expensive.</td></tr><tr><td style="text-align: right"><strong>String method</strong></td><td style="text-align: right">You want a <strong>minimum energy path / heteroclinic orbit</strong> driven by the deterministic drift (typical use: <strong>gradient</strong> systems).</td><td style="text-align: right">Deterministic drift field (works for <code>ContinuousTimeDynamicalSystem</code>; does not rely on an SDE noise model).</td><td style="text-align: right">In <strong>non-gradient</strong> systems if you need the <em>most probable</em> noise-induced transition path (string gives the deterministic heteroclinic orbit, which generally differs from the instanton).</td></tr></table><h4 id="Variants-and-extensions"><a class="docs-heading-anchor" href="#Variants-and-extensions">Variants and extensions</a><a id="Variants-and-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Variants-and-extensions" title="Permalink"></a></h4><p>The literature contains a number of extensions of MAM-type methods that may be relevant depending on the model class and numerical difficulties. These variants are not currently implemented in <code>CriticalTransitions.jl</code>, but serve as useful pointers:</p><ul><li><strong>tMAM / optimal linear time scaling</strong>: avoids explicit optimization over the transition time by introducing an optimal linear time scaling; can be combined with adaptivity in time discretization <a href="../../refs/#wan_tmam_2015">Wan [11]</a>.</li><li><strong>Adaptive MAM</strong>: uses a moving-mesh strategy to concentrate grid points in dynamically important portions of the path, improving efficiency and robustness <a href="../../refs/#zhou_adaptive_mam_2008">Zhou <em>et al.</em> [12]</a>.</li><li><strong>Non-Gaussian (jump / Lévy) noise</strong>: for systems driven by jump noise, the rate function and path optimization problem differ from the Freidlin–Wentzell diffusive setting; see e.g. an optimal-control-based approach in <a href="../../refs/#wei_most_likely_jumps_2023">Wei <em>et al.</em> [13]</a>.</li><li><strong>Multiplicative / state-dependent noise</strong>: extensions of geometric action minimization to degenerate or multiplicative noise are discussed in <a href="../../refs/#grafke_small_random_2017">Grafke <em>et al.</em> [14]</a>; the current <code>sgMAM</code> implementation assumes additive noise.</li></ul><h3 id="Minimum-action-method-(MAM)"><a class="docs-heading-anchor" href="#Minimum-action-method-(MAM)">Minimum action method (MAM)</a><a id="Minimum-action-method-(MAM)-1"></a><a class="docs-heading-anchor-permalink" href="#Minimum-action-method-(MAM)" title="Permalink"></a></h3><p>Minimization of the specified action functional using the optimization algorithm of <code>Optimization.jl</code>. See also <a href="../../refs/#e_minimum_2004">E <em>et al.</em> [15]</a>.</p><article><details class="docstring" open="true"><summary id="CriticalTransitions.min_action_method"><a class="docstring-binding" href="#CriticalTransitions.min_action_method"><code>CriticalTransitions.min_action_method</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">min_action_method(sys::ContinuousTimeDynamicalSystem, x_i, x_f, T::Real; kwargs...)</code></pre><p>Minimizes an action functional to obtain a minimum action path (instanton) between an initial state <code>x_i</code> and final state <code>x_f</code> in phase space.</p><p>This algorithm uses the <a href="https://github.com/SciML/Optimization.jl"><code>Optimization.jl</code></a> package to minimize the specified action functional (either <a href="#CriticalTransitions.fw_action"><code>fw_action</code></a> or <a href="#CriticalTransitions.om_action"><code>om_action</code></a>) for the system <code>sys</code> over paths connecting <code>x_i</code> to <code>x_f</code> in time <code>T</code>.</p><p>The path is initialized as a straight line between <code>x_i</code> and <code>x_f</code>, parameterized in time via <code>N</code> equidistant points and total time <code>T</code>. Thus, the time step between discretized path points is <span>$\Delta t = T/N$</span>. To set an initial path different from a straight line, see the multiple dispatch method</p><blockquote><p><code>min_action_method(sys::ContinuousTimeDynamicalSystem, init::Matrix, T::Real; kwargs...)</code>.</p></blockquote><p>Returns a <a href="#MinimumActionPath"><code>MinimumActionPath</code></a> object containing the optimized path and the action value.</p><p><strong>Keyword arguments</strong></p><ul><li><code>functional = &quot;FW&quot;</code>: type of action functional to minimize. Defaults to <a href="#CriticalTransitions.fw_action"><code>fw_action</code></a>, alternative: &quot;OM&quot; for <a href="#CriticalTransitions.om_action"><code>om_action</code></a></li><li><code>points = 100</code>: number of path points to use for the discretization of the path</li><li><code>noise_strength = nothing</code>: noise strength for the action functional. Specify only if <code>functional = &quot;OM&quot;</code></li><li><code>optimizer = Optimisers.Adam()</code>: minimization algorithm from <a href="https://docs.sciml.ai/Optimization/stable/optimization_packages/optimisers/"><code>Optimization.jl</code></a></li><li><code>ad_type = Optimization.AutoFiniteDiff()</code>: type of automatic differentiation to use (see <a href="https://docs.sciml.ai/Optimization/stable/optimization_packages/optimisers/"><code>Optimization.jl</code></a>)</li><li><code>maxiters = 100</code>: maximum number of iterations before the algorithm stops</li><li><code>abstol::Real=NaN</code>: absolute tolerance of action gradient to determine convergence</li><li><code>reltol::Real=NaN</code>: relative tolerance of action gradient to determine convergence</li><li><code>verbose = false</code>: whether to print Optimization information during the run</li><li><code>show_progress = false</code>: whether to print a progress bar</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/83501fb3561416175939251d8561678f9c2dc727/src/largedeviations/min_action_method.jl#L1-L36">source</a></section><section><div><pre><code class="language-julia hljs">min_action_method(sys::ContinuousTimeDynamicalSystem, init::Matrix, T::Real; kwargs...)</code></pre><p>Minimizes the specified action functional to obtain a minimum action path (instanton) between fixed end points given a system <code>sys</code> and total path time <code>T</code>.</p><p>The initial path <code>init</code> must be a matrix of size <code>(D, N)</code>, where <code>D</code> is the dimension of the system and <code>N</code> is the number of path points. The physical time of the path is specified by <code>T</code>, such that the time step between consecutive path points is <span>$\Delta t = T/N$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/83501fb3561416175939251d8561678f9c2dc727/src/largedeviations/min_action_method.jl#L44-L54">source</a></section></details></article><h3 id="Geometric-minimum-action-method-(gMAM)"><a class="docs-heading-anchor" href="#Geometric-minimum-action-method-(gMAM)">Geometric minimum action method (gMAM)</a><a id="Geometric-minimum-action-method-(gMAM)-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-minimum-action-method-(gMAM)" title="Permalink"></a></h3><p>Minimization of the geometric action following <a href="../../refs/#heymann_pathways_2008">Heymann and Vanden-Eijnden [16]</a> and <a href="../../refs/#heymann_geometric_2008">Heymann and Vanden-Eijnden [17]</a>. gMAM reformulates MAM to avoid double optimization of both the action and the transition time. It achieves this by using a <a href="#Geometric-Freidlin-Wentzell-action">geometric action</a> functional that is independent of the time parametrization of the path. This reparameterization invariance makes the method more robust and computationally efficient, particularly for multiscale systems.</p><article><details class="docstring" open="true"><summary id="CriticalTransitions.geometric_min_action_method"><a class="docstring-binding" href="#CriticalTransitions.geometric_min_action_method"><code>CriticalTransitions.geometric_min_action_method</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">geometric_min_action_method(
    sys::ContinuousTimeDynamicalSystem,
    init::Matrix;
    maxiters,
    abstol,
    reltol,
    optimizer,
    ad_type,
    stepsize,
    verbose,
    show_progress
) -&gt; MinimumActionPath{_A, _B, _C, Nothing, Nothing, Nothing, Nothing, Nothing} where {_A, _B&lt;:Real, _C}
</code></pre><p>Runs the geometric Minimum Action Method (gMAM) to find the minimum action path (instanton) from an initial condition <code>init</code>, given a system <code>sys</code> and total arc length <code>arclength</code>.</p><p>The initial path <code>init</code> must be a matrix of size <code>(D, N)</code>, where <code>D</code> is the dimension of the system and <code>N</code> is the number of path points.</p><p>For more information see the main method, <a href="#CriticalTransitions.geometric_min_action_method"><code>geometric_min_action_method(sys::CoupledSDEs, x_i, x_f, arclength::Real; kwargs...)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/83501fb3561416175939251d8561678f9c2dc727/src/largedeviations/geometric_min_action_method.jl#L41">source</a></section></details></article><h3 id="Simple-geometric-minimum-action-method-(sgMAM)"><a class="docs-heading-anchor" href="#Simple-geometric-minimum-action-method-(sgMAM)">Simple geometric minimum action method (sgMAM)</a><a id="Simple-geometric-minimum-action-method-(sgMAM)-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-geometric-minimum-action-method-(sgMAM)" title="Permalink"></a></h3><p>Simplified minimization of the geometric action following <a href="../../refs/#grafke_long_2017">Grafke <em>et al.</em> [18]</a>. The simple gMAM reduces the complexity of the original gMAM by requiring only first-order derivatives of the underlying Hamiltonian optimization formulation. This simplifies the numerical treatment and computational complexity.</p><p>The implementation below performs a constrained gradient descent assuming an autonomous system with additive Gaussian noise.</p><article><details class="docstring" open="true"><summary id="CriticalTransitions.simple_geometric_min_action_method"><a class="docstring-binding" href="#CriticalTransitions.simple_geometric_min_action_method"><code>CriticalTransitions.simple_geometric_min_action_method</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simple_geometric_min_action_method(
    sys::ExtendedPhaseSpace,
    x_initial::Array{T, 2};
    stepsize,
    maxiters,
    show_progress,
    verbose,
    abstol,
    reltol
) -&gt; MinimumActionPath{_A, _B, _C, Nothing, Nothing, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}} where {_A, _B&lt;:Real, _C}
</code></pre><p>Performs the simplified geometric Minimal Action Method (sgMAM) on the given system <code>sys</code>. Our implementation is only valid for additive noise.</p><p>This method computes the optimal path in the phase space of a Hamiltonian system that minimizes the Freidlin–Wentzell action. The Hamiltonian functions <code>H_x</code> and <code>H_p</code> define the system&#39;s dynamics in a doubled phase. The initial state <code>x_initial</code> is evolved iteratively using constrained gradient descent with step size parameter <code>stepsize</code> over a specified number of iterations. The method can display a progress meter and will stop early if the absolute tolerance <code>abstol</code> or relative tolerance <code>reltol</code> is achieved.</p><p>The function returns a <a href="#MinimumActionPath"><code>MinimumActionPath</code></a> containing the final path, the action value, the Lagrange multipliers (<code>.λ</code>), the momentum (<code>.generalized_momentum</code>), and the state derivatives (<code>.path_velocity</code>). The implementation is based on the work of <a href="https://homepages.warwick.ac.uk/staff/T.Grafke/simplified-geometric-minimum-action-method-for-the-computation-of-instantons.html">Grafke et al. (2019)</a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>stepsize::Real=1e-1</code>: step size for gradient descent. Default: <code>0.1</code></li><li><code>maxiters::Int=1000</code>: maximum number of iterations before the algorithm stops</li><li><code>show_progress::Bool=false</code>: if true, display a progress bar</li><li><code>verbose::Bool=false</code>: if true, print additional output</li><li><code>abstol::Real=NaN</code>: absolute tolerance for early stopping based on action change</li><li><code>reltol::Real=NaN</code>: relative tolerance for early stopping based on action change</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/83501fb3561416175939251d8561678f9c2dc727/src/largedeviations/sgMAM.jl#L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CriticalTransitions.ExtendedPhaseSpace"><a class="docstring-binding" href="#CriticalTransitions.ExtendedPhaseSpace"><code>CriticalTransitions.ExtendedPhaseSpace</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A structure representing a extanded phase space system where your dissipative vector field is embedded in a doubled dimensional phase space. Given old phase space coordinates <code>x</code> of a vector field <code>f(x)</code>, we can define the canonical momenta <code>p</code>, such that the new phase space coordinates are <code>(x, p)</code>. The dynamics in this extended phase space are then governed by the Hamtiltonian system:</p><p><span>$H = p^2 + x \dot f(x)$</span></p><p>Hence, this system operates in an extended phase space where the Hamiltonian is assumed to be quadratic in the extended momentum.</p><p>The struct <code>ExtendedPhaseSpace</code> holds the Hamilton&#39;s functions <code>H_x</code> and <code>H_p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/83501fb3561416175939251d8561678f9c2dc727/src/largedeviations/sgMAM.jl#L1-L9">source</a></section></details></article><h4 id="Performance-notes-(sgMAM)"><a class="docs-heading-anchor" href="#Performance-notes-(sgMAM)">Performance notes (sgMAM)</a><a id="Performance-notes-(sgMAM)-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-notes-(sgMAM)" title="Permalink"></a></h4><p>sgMAM repeatedly evaluates <code>H_p(x, p)</code> and <code>H_x(x, p)</code> along a discretized path. If this allocates, sgMAM will be slow.</p><p>Key reason for performance differences:</p><ul><li><code>ExtendedPhaseSpace(ds::CoupledSDEs)</code> typically relies on <code>jacobian(ds)</code> (often automatic differentiation unless you provide an analytic Jacobian) and evaluates it pointwise along the path.</li><li>A hardcoded <code>ExtendedPhaseSpace(H_x, H_p)</code> with analytic expressions operating on the full <code>D×Nt</code> path matrix usually allocates far less.</li></ul><p>Benchmark pattern:</p><pre><code class="language-julia hljs">using CriticalTransitions
using BenchmarkTools

sys_fast = ExtendedPhaseSpace{false,2}(H_x, H_p)  # hardcoded analytic H_x/H_p

ds = CoupledSDEs(KPO, zeros(2), ())
sys_generic = ExtendedPhaseSpace(ds)              # uses jacobian(ds)

@btime simple_geometric_min_action_method($sys_fast,    $x_initial; maxiters=100, stepsize=0.5, show_progress=false)
@btime simple_geometric_min_action_method($sys_generic, $x_initial; maxiters=100, stepsize=0.5, show_progress=false)</code></pre><p>Aside: the same “vectorized + allocation-free inner loop” principle also tends to make <a href="#CriticalTransitions.string_method"><code>string_method</code></a> faster when used with <code>ExtendedPhaseSpace</code>.</p><h3 id="MinimumActionPath"><a class="docs-heading-anchor" href="#MinimumActionPath"><code>MinimumActionPath</code></a><a id="MinimumActionPath-1"></a><a class="docs-heading-anchor-permalink" href="#MinimumActionPath" title="Permalink"></a></h3><p><a href="#Geometric-minimum-action-method-(gMAM)">(gMAM)</a> and <a href="#Simple-geometric-minimum-action-method-(sgMAM)">(sgMAM)</a> return their output as a <code>MinimumActionPath</code> type:</p><article><details class="docstring" open="true"><summary id="CriticalTransitions.MinimumActionPath"><a class="docstring-binding" href="#CriticalTransitions.MinimumActionPath"><code>CriticalTransitions.MinimumActionPath</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct MinimumActionPath{D, T&lt;:Real, V, Phis, Ahis, Lambda, PV, GPV}</code></pre><p>The minimum action path between two points in a D-dimensional phase space.</p><p><strong>Fields</strong></p><ul><li><p><code>path::StateSpaceSet{D, T, V} where {D, T&lt;:Real, V}</code>: The path matrix.</p></li><li><p><code>action::Real</code>: The action value associated to the path.</p></li><li><p><code>path_history::Any</code>: The history of action of the paths in the optimisation algorithm (optional).</p></li><li><p><code>action_history::Any</code>: The history of action of the paths in the optimisation algorithm (optional).</p></li><li><p><code>λ::Any</code>: The Lagrange multiplier parameter for the minimum action path (optional).</p></li><li><p><code>generalized_momentum::Any</code>: The generalized momentum of the phase space variables (optional).</p></li><li><p><code>path_velocity::Any</code>: The path velocity (optional).</p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">MinimumActionPath(
    path,
    action;
    path_history,
    action_history,
    λ,
    generalized_momentum,
    path_velocity
)</code></pre><p>defined at <a href="https://github.com/JuliaDynamics/CriticalTransitions.jl/tree/83501fb3561416175939251d8561678f9c2dc727//src/largedeviations/MinimumActionPath.jl#L29"><code>/home/runner/work/CriticalTransitions.jl/CriticalTransitions.jl/src/largedeviations/MinimumActionPath.jl:29</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/83501fb3561416175939251d8561678f9c2dc727/src/largedeviations/MinimumActionPath.jl#L1">source</a></section></details></article><h2 id="Action-functionals"><a class="docs-heading-anchor" href="#Action-functionals">Action functionals</a><a id="Action-functionals-1"></a><a class="docs-heading-anchor-permalink" href="#Action-functionals" title="Permalink"></a></h2><h3 id="Freidlin-Wentzell-action"><a class="docs-heading-anchor" href="#Freidlin-Wentzell-action">Freidlin-Wentzell action</a><a id="Freidlin-Wentzell-action-1"></a><a class="docs-heading-anchor-permalink" href="#Freidlin-Wentzell-action" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="CriticalTransitions.fw_action"><a class="docstring-binding" href="#CriticalTransitions.fw_action"><code>CriticalTransitions.fw_action</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fw_action(sys::CoupledSDEs, path, time) -&gt; Any
</code></pre><p>Calculates the Freidlin-Wentzell action of a given <code>path</code> with time points <code>time</code> in a drift field specified by the deterministic dynamics <code>f = dynamic_rule(sys)</code> and (normalized) noise covariance matrix <code>covariance_matrix(sys)</code>.</p><p>The path must be a <code>(D x N)</code> matrix, where <code>D</code> is the dimensionality of the system <code>sys</code> and <code>N</code> is the number of path points. The <code>time</code> array must have length <code>N</code>.</p><p>Returns a single number, which is the value of the action functional</p><p><span>$S_T[\phi_t] = \frac{1}{2} \int_0^T || \dot \phi_t - f(\phi_t) ||^2_Q \text{d}t$</span></p><p>where <span>$\phi_t$</span> denotes the path in state space, <span>$b$</span> the drift field, and <span>$T$</span> the total time of the path. The subscript <span>$Q$</span> refers to the generalized norm <span>$||a||_Q^2 := \langle a, Q^{-1} b \rangle$</span> (see <code>anorm</code>). Here <span>$Q$</span> is the noise covariance matrix normalized by <span>$D/L_1(Q)$</span>, with <span>$L_1$</span> being the L1 matrix norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/83501fb3561416175939251d8561678f9c2dc727/src/largedeviations/action.jl#L1">source</a></section></details></article><h3 id="Geometric-Freidlin-Wentzell-action"><a class="docs-heading-anchor" href="#Geometric-Freidlin-Wentzell-action">Geometric Freidlin-Wentzell action</a><a id="Geometric-Freidlin-Wentzell-action-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-Freidlin-Wentzell-action" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="CriticalTransitions.geometric_action"><a class="docstring-binding" href="#CriticalTransitions.geometric_action"><code>CriticalTransitions.geometric_action</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">geometric_action(sys::CoupledSDEs, path) -&gt; Any
geometric_action(sys::CoupledSDEs, path, arclength) -&gt; Any
</code></pre><p>Calculates the geometric action of a given <code>path</code> with specified <code>arclength</code> for the drift field specified by the deterministic dynamics <code>f = dynamic_rule(sys)</code> and (normalized) noise covariance matrix <code>covariance_matrix(sys)</code>.</p><p>For a given path <span>$\varphi$</span>, the geometric action <span>$\bar S$</span> corresponds to the minimum of the Freidlin-Wentzell action <span>$S_T(\varphi)$</span> over all travel times <span>$T&gt;0$</span>, where <span>$\varphi$</span> denotes the path&#39;s parameterization in physical time (see <a href="#CriticalTransitions.fw_action"><code>fw_action</code></a>). It is given by the integral</p><p><span>$\bar S[\varphi] = \int_0^L \left( ||\varphi&#39;||_Q \, ||f(\varphi)||_Q - \langle \varphi&#39;, \,     f(\varphi) \rangle_Q \right) \, \text{d}s$</span></p><p>where <span>$s$</span> is the arclength coordinate, <span>$L$</span> the arclength, <span>$f$</span> the drift field, and the subscript <span>$Q$</span> refers to the generalized dot product <span>$\langle a, b \rangle_Q := a^{\top} \cdot Q^{-1} b$</span> (see <code>anorm</code>). Here <span>$Q$</span> is the noise covariance matrix normalized by <span>$D/L_1(Q)$</span>, with <span>$L_1$</span> being the L1 matrix norm.</p><p>Returns the value of the geometric action <span>$\bar S$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/83501fb3561416175939251d8561678f9c2dc727/src/largedeviations/action.jl#L90">source</a></section><section><div><pre><code class="language-julia hljs">geometric_action(b::Function, path, arclength=1.0; A=nothing)</code></pre><p>Geometric Freidlin-Wentzell action for a drift field <code>b</code> and a discrete <code>path</code>.</p><p>This is a drift-only convenience overload that uses the same integrand as <code>geometric_action(sys::CoupledSDEs, ...)</code>, but requires an explicit inverse covariance (<code>A = Q^{-1}</code>) if you want anything other than the identity metric.</p><p>If <code>A === nothing</code>, it defaults to the identity metric.</p><p>The <code>path</code> must be a <code>(D × N)</code> matrix with points in columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/83501fb3561416175939251d8561678f9c2dc727/src/largedeviations/action.jl#L119-L131">source</a></section></details></article><h3 id="Onsager-Machlup-action"><a class="docs-heading-anchor" href="#Onsager-Machlup-action">Onsager-Machlup action</a><a id="Onsager-Machlup-action-1"></a><a class="docs-heading-anchor-permalink" href="#Onsager-Machlup-action" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="CriticalTransitions.om_action"><a class="docstring-binding" href="#CriticalTransitions.om_action"><code>CriticalTransitions.om_action</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">om_action(sys::CoupledSDEs, path, time, noise_strength)</code></pre><p>Calculates the Onsager-Machlup action of a given <code>path</code> with time points <code>time</code> for the drift field <code>f = dynamic_rule(sys)</code> at given <code>noise_strength</code>.</p><p>The path must be a <code>(D x N)</code> matrix, where <code>D</code> is the dimensionality of the system <code>sys</code> and <code>N</code> is the number of path points. The <code>time</code> array must have length <code>N</code>.</p><p>Returns a single number, which is the value of the action functional</p><p><span>$S^{\sigma}_T[\phi_t] = \frac{1}{2} \int_0^T \left( || \dot \phi_t - f(\phi_t) ||^2_Q + \sigma^2 \nabla \cdot f \right) \, \text{d} t$</span></p><p>where <span>$\phi_t$</span> denotes the path in state space, <span>$b$</span> the drift field, <span>$T$</span> the total time of the path, and <span>$\sigma$</span> the noise strength. The subscript <span>$Q$</span> refers to the generalized norm <span>$||a||_Q^2 := \langle a, Q^{-1} b \rangle$</span> (see <code>anorm</code>). Here <span>$Q$</span> is the noise covariance matrix normalized by <span>$D/L_1(Q)$</span>, with <span>$L_1$</span> being the L1 matrix norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/83501fb3561416175939251d8561678f9c2dc727/src/largedeviations/action.jl#L36-L54">source</a></section></details></article><p>For convenience, a general <a href="#CriticalTransitions.action"><code>action</code></a> function is available where the type of functional is set as an argument:</p><article><details class="docstring" open="true"><summary id="CriticalTransitions.action"><a class="docstring-binding" href="#CriticalTransitions.action"><code>CriticalTransitions.action</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">action(
    sys::CoupledSDEs,
    path::Matrix,
    time,
    functional;
    noise_strength
) -&gt; Any
</code></pre><p>Computes the action functional specified by <code>functional</code> for a given CoupledSDEs <code>sys</code> and <code>path</code> parameterized by <code>time</code>.</p><ul><li><code>functional = &quot;FW&quot;</code>: Returns the Freidlin-Wentzell action (<a href="#CriticalTransitions.fw_action"><code>fw_action</code></a>)</li><li><code>functional = &quot;OM&quot;</code>: Returns the Onsager-Machlup action (<a href="#CriticalTransitions.om_action"><code>om_action</code></a>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/83501fb3561416175939251d8561678f9c2dc727/src/largedeviations/action.jl#L71">source</a></section></details></article><h2 id="String-method"><a class="docs-heading-anchor" href="#String-method">String method</a><a id="String-method-1"></a><a class="docs-heading-anchor-permalink" href="#String-method" title="Permalink"></a></h2><p>The string method is a technique for finding transition paths between two states in a dynamical system <a href="../../refs/#e_string_2007">E <em>et al.</em> [19]</a>. The method represents the path as a &quot;string&quot; of points that connects the states and evolves it to minimize the drift along the path. The resulting tangent path is parallel to the drift of the system, i.e., the string method computes the heteroclinic orbit. For non-gradient systems (detailed -balance is broken), the heteroclinic orbit differs from the transition path, it does correctly predict, it correctly captures the deterministic dynamics from the saddle point onward (&quot;downhill&quot; portion of the path).</p><article><details class="docstring" open="true"><summary id="CriticalTransitions.string_method"><a class="docstring-binding" href="#CriticalTransitions.string_method"><code>CriticalTransitions.string_method</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">string_method(
    sys::Union{Function, ExtendedPhaseSpace},
    x_initial::Matrix;
    stepsize,
    integrator,
    maxiters,
    show_progress
) -&gt; MinimumActionPath{_A, _B, _C, Nothing, Nothing, Nothing, Nothing, Nothing} where {_A, _B&lt;:Real, _C}
</code></pre><p>Compute the string method for a given system using the method of <a href="../../refs/#e_string_2007">E <em>et al.</em> [19]</a>.</p><p>The string method is an iterative algorithm used to find minimum energy path (MEP) between two points in phase space. It works by evolving a discretized path (string) according to the system&#39;s drift while maintaining equal arc-length parametrization between points.</p><p>This implementation allows for computation between arbitrary points, not just stable fixed points.</p><p><strong>References</strong></p><ul><li>[<a href="../../refs/#e_string_2007">19</a>]</li><li><a href="https://github.com/gideonsimpson/StringMethod.jl"><code>StringMethod.jl</code></a></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>stepsize::Real=1e-1</code>: Step size for the evolution step. Default: <code>0.1</code></li><li><code>integrator=Euler()</code>: SciML integrator algorithm (e.g. <code>Euler()</code>, <code>Tsit5()</code>)</li><li><code>maxiters::Int=1000</code>: Maximum number of iterations for path convergence</li><li><code>show_progress::Bool=false</code>: Whether to display a progress meter during computation</li></ul><p><strong>Returns</strong></p><p>A <a href="#MinimumActionPath"><code>MinimumActionPath</code></a> containing the converged path and action value.</p><p>For <code>sys::CoupledSDEs</code> the <code>.action</code> field is computed as the geometric Freidlin-Wentzell action via <a href="#CriticalTransitions.geometric_action"><code>geometric_action</code></a>. For drift-only systems (e.g. <code>sys::Function</code>) the same geometric action is computed assuming an identity noise covariance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/83501fb3561416175939251d8561678f9c2dc727/src/largedeviations/string_method.jl#L1-L29">source</a></section><section><div><pre><code class="language-julia hljs">string_method(
    sys::ContinuousTimeDynamicalSystem,
    init;
    kwargs...
) -&gt; MinimumActionPath{_A, _B, _B1, Nothing, Nothing, Nothing, Nothing, Nothing} where {_A, _B&lt;:Real, _B1}
</code></pre><p>Compute the string method for a given system using the method of <a href="../../refs/#e_string_2007">E <em>et al.</em> [19]</a>.</p><p>The string method is an iterative algorithm used to find minimum energy path (MEP) between two points in phase space. It works by evolving a discretized path (string) according to the system&#39;s drift while maintaining equal arc-length parametrization between points.</p><p>This implementation allows for computation between arbitrary points, not just stable fixed points.</p><p><strong>References</strong></p><ul><li>[<a href="../../refs/#e_string_2007">19</a>]</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>stepsize::Real=1e-1</code>: Step size for the evolution step. Default: <code>0.1</code></li><li><code>integrator=Euler()</code>: SciML integrator algorithm (e.g. <code>Euler()</code>, <code>Tsit5()</code>)</li><li><code>maxiters::Int=1000</code>: Maximum number of iterations for path convergence</li><li><code>show_progress::Bool=false</code>: Whether to display a progress meter during computation</li></ul><p><strong>Returns</strong></p><p>A <a href="#MinimumActionPath"><code>MinimumActionPath</code></a> containing the converged path and action value.</p><p>For <code>sys::CoupledSDEs</code>, the action is computed using the system&#39;s noise covariance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CriticalTransitions.jl/blob/83501fb3561416175939251d8561678f9c2dc727/src/largedeviations/string_method.jl#L68-L93">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sampling/">« Sampling transitions</a><a class="docs-footer-nextpage" href="../r-tipping/">Rate-induced transitions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 18 February 2026 08:57">Wednesday 18 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
